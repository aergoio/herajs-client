/*!
 * herajs v0.0.1
 * (c) 2018 AERGO
 * Released under _resolvense.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('http'), require('https'), require('url')) :
	typeof define === 'function' && define.amd ? define(['http', 'https', 'url'], factory) :
	(global.herajs = factory(global.http,global.https,global.url));
}(this, (function (http,https,url) { 'use strict';

	http = http && http.hasOwnProperty('default') ? http['default'] : http;
	https = https && https.hasOwnProperty('default') ? https['default'] : https;
	url = url && url.hasOwnProperty('default') ? url['default'] : url;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var $jscomp={scope:{},getGlobal:function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal?commonjsGlobal:a}};$jscomp.global=$jscomp.getGlobal(commonjsGlobal);$jscomp.initSymbol=function(){$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol);$jscomp.initSymbol=function(){};};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(a){return "jscomp_symbol_"+a+$jscomp.symbolCounter_++};
	$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();$jscomp.global.Symbol.iterator||($jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));$jscomp.initSymbolIterator=function(){};};$jscomp.makeIterator=function(a){$jscomp.initSymbolIterator();$jscomp.initSymbol();$jscomp.initSymbolIterator();var b=a[Symbol.iterator];if(b)return b.call(a);var c=0;return {next:function(){return c<a.length?{done:!1,value:a[c++]}:{done:!0}}}};
	$jscomp.arrayFromIterator=function(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c};$jscomp.arrayFromIterable=function(a){return a instanceof Array?a:$jscomp.arrayFromIterator($jscomp.makeIterator(a))};$jscomp.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.prototype=new c;a.prototype.constructor=a;for(var d in b)if(Object.defineProperties){var e=Object.getOwnPropertyDescriptor(b,d);e&&Object.defineProperty(a,d,e);}else a[d]=b[d];};$jscomp.array=$jscomp.array||{};
	$jscomp.iteratorFromArray=function(a,b){$jscomp.initSymbolIterator();a instanceof String&&(a+="");var c=0,d={next:function(){if(c<a.length){var e=c++;return {value:b(e,a[e]),done:!1}}d.next=function(){return {done:!0,value:void 0}};return d.next()}};$jscomp.initSymbol();$jscomp.initSymbolIterator();d[Symbol.iterator]=function(){return d};return d};
	$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return {i:e,v:f}}return {i:-1,v:void 0}};
	$jscomp.array.from=function(a,b,c){$jscomp.initSymbolIterator();b=null!=b?b:function(a){return a};var d=[];$jscomp.initSymbol();$jscomp.initSymbolIterator();var e=a[Symbol.iterator];"function"==typeof e&&(a=e.call(a));if("function"==typeof a.next)for(;!(e=a.next()).done;)d.push(b.call(c,e.value));else for(var e=a.length,f=0;f<e;f++)d.push(b.call(c,a[f]));return d};$jscomp.array.of=function(a){return $jscomp.array.from(arguments)};
	$jscomp.array.entries=function(){return $jscomp.iteratorFromArray(this,function(a,b){return [a,b]})};$jscomp.array.installHelper_=function(a,b){!Array.prototype[a]&&Object.defineProperties&&Object.defineProperty&&Object.defineProperty(Array.prototype,a,{configurable:!0,enumerable:!1,writable:!0,value:b});};$jscomp.array.entries$install=function(){$jscomp.array.installHelper_("entries",$jscomp.array.entries);};$jscomp.array.keys=function(){return $jscomp.iteratorFromArray(this,function(a){return a})};
	$jscomp.array.keys$install=function(){$jscomp.array.installHelper_("keys",$jscomp.array.keys);};$jscomp.array.values=function(){return $jscomp.iteratorFromArray(this,function(a,b){return b})};$jscomp.array.values$install=function(){$jscomp.array.installHelper_("values",$jscomp.array.values);};
	$jscomp.array.copyWithin=function(a,b,c){var d=this.length;a=Number(a);b=Number(b);c=Number(null!=c?c:d);if(a<b)for(c=Math.min(c,d);b<c;)b in this?this[a++]=this[b++]:(delete this[a++],b++);else for(c=Math.min(c,d+b-a),a+=c-b;c>b;)--c in this?this[--a]=this[c]:delete this[a];return this};$jscomp.array.copyWithin$install=function(){$jscomp.array.installHelper_("copyWithin",$jscomp.array.copyWithin);};
	$jscomp.array.fill=function(a,b,c){var d=this.length||0;0>b&&(b=Math.max(0,d+b));if(null==c||c>d)c=d;c=Number(c);0>c&&(c=Math.max(0,d+c));for(b=Number(b||0);b<c;b++)this[b]=a;return this};$jscomp.array.fill$install=function(){$jscomp.array.installHelper_("fill",$jscomp.array.fill);};$jscomp.array.find=function(a,b){return $jscomp.findInternal(this,a,b).v};$jscomp.array.find$install=function(){$jscomp.array.installHelper_("find",$jscomp.array.find);};
	$jscomp.array.findIndex=function(a,b){return $jscomp.findInternal(this,a,b).i};$jscomp.array.findIndex$install=function(){$jscomp.array.installHelper_("findIndex",$jscomp.array.findIndex);};$jscomp.ASSUME_NO_NATIVE_MAP=!1;
	$jscomp.Map$isConformant=function(){if($jscomp.ASSUME_NO_NATIVE_MAP)return !1;var a=$jscomp.global.Map;if(!a||!a.prototype.entries||"function"!=typeof Object.seal)return !1;try{var b=Object.seal({x:4}),c=new a($jscomp.makeIterator([[b,"s"]]));if("s"!=c.get(b)||1!=c.size||c.get({x:4})||c.set({x:4},"t")!=c||2!=c.size)return !1;var d=c.entries(),e=d.next();if(e.done||e.value[0]!=b||"s"!=e.value[1])return !1;e=d.next();return e.done||4!=e.value[0].x||"t"!=e.value[1]||!d.next().done?!1:!0}catch(f){return !1}};
	$jscomp.Map=function(a){this.data_={};this.head_=$jscomp.Map.createHead();this.size=0;if(a){a=$jscomp.makeIterator(a);for(var b;!(b=a.next()).done;)b=b.value,this.set(b[0],b[1]);}};
	$jscomp.Map.prototype.set=function(a,b){var c=$jscomp.Map.maybeGetEntry(this,a);c.list||(c.list=this.data_[c.id]=[]);c.entry?c.entry.value=b:(c.entry={next:this.head_,previous:this.head_.previous,head:this.head_,key:a,value:b},c.list.push(c.entry),this.head_.previous.next=c.entry,this.head_.previous=c.entry,this.size++);return this};
	$jscomp.Map.prototype["delete"]=function(a){a=$jscomp.Map.maybeGetEntry(this,a);return a.entry&&a.list?(a.list.splice(a.index,1),a.list.length||delete this.data_[a.id],a.entry.previous.next=a.entry.next,a.entry.next.previous=a.entry.previous,a.entry.head=null,this.size--,!0):!1};$jscomp.Map.prototype.clear=function(){this.data_={};this.head_=this.head_.previous=$jscomp.Map.createHead();this.size=0;};$jscomp.Map.prototype.has=function(a){return !!$jscomp.Map.maybeGetEntry(this,a).entry};
	$jscomp.Map.prototype.get=function(a){return (a=$jscomp.Map.maybeGetEntry(this,a).entry)&&a.value};$jscomp.Map.prototype.entries=function(){return $jscomp.Map.makeIterator_(this,function(a){return [a.key,a.value]})};$jscomp.Map.prototype.keys=function(){return $jscomp.Map.makeIterator_(this,function(a){return a.key})};$jscomp.Map.prototype.values=function(){return $jscomp.Map.makeIterator_(this,function(a){return a.value})};
	$jscomp.Map.prototype.forEach=function(a,b){for(var c=this.entries(),d;!(d=c.next()).done;)d=d.value,a.call(b,d[1],d[0],this);};$jscomp.Map.maybeGetEntry=function(a,b){var c=$jscomp.Map.getId(b),d=a.data_[c];if(d&&Object.prototype.hasOwnProperty.call(a.data_,c))for(var e=0;e<d.length;e++){var f=d[e];if(b!==b&&f.key!==f.key||b===f.key)return {id:c,list:d,index:e,entry:f}}return {id:c,list:d,index:-1,entry:void 0}};
	$jscomp.Map.makeIterator_=function(a,b){var c=a.head_,d={next:function(){if(c){for(;c.head!=a.head_;)c=c.previous;for(;c.next!=c.head;)return c=c.next,{done:!1,value:b(c)};c=null;}return {done:!0,value:void 0}}};$jscomp.initSymbol();$jscomp.initSymbolIterator();d[Symbol.iterator]=function(){return d};return d};$jscomp.Map.mapIndex_=0;$jscomp.Map.createHead=function(){var a={};return a.previous=a.next=a.head=a};
	$jscomp.Map.getId=function(a){if(!(a instanceof Object))return "p_"+a;if(!($jscomp.Map.idKey in a))try{$jscomp.Map.defineProperty(a,$jscomp.Map.idKey,{value:++$jscomp.Map.mapIndex_});}catch(b){}return $jscomp.Map.idKey in a?a[$jscomp.Map.idKey]:"o_ "+a};$jscomp.Map.defineProperty=Object.defineProperty?function(a,b,c){Object.defineProperty(a,b,{value:String(c)});}:function(a,b,c){a[b]=String(c);};$jscomp.Map.Entry=function(){};
	$jscomp.Map$install=function(){$jscomp.initSymbol();$jscomp.initSymbolIterator();$jscomp.Map$isConformant()?$jscomp.Map=$jscomp.global.Map:($jscomp.initSymbol(),$jscomp.initSymbolIterator(),$jscomp.Map.prototype[Symbol.iterator]=$jscomp.Map.prototype.entries,$jscomp.initSymbol(),$jscomp.Map.idKey=Symbol("map-id-key"),$jscomp.Map$install=function(){});};$jscomp.math=$jscomp.math||{};
	$jscomp.math.clz32=function(a){a=Number(a)>>>0;if(0===a)return 32;var b=0;0===(a&4294901760)&&(a<<=16,b+=16);0===(a&4278190080)&&(a<<=8,b+=8);0===(a&4026531840)&&(a<<=4,b+=4);0===(a&3221225472)&&(a<<=2,b+=2);0===(a&2147483648)&&b++;return b};$jscomp.math.imul=function(a,b){a=Number(a);b=Number(b);var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};$jscomp.math.sign=function(a){a=Number(a);return 0===a||isNaN(a)?a:0<a?1:-1};
	$jscomp.math.log10=function(a){return Math.log(a)/Math.LN10};$jscomp.math.log2=function(a){return Math.log(a)/Math.LN2};$jscomp.math.log1p=function(a){a=Number(a);if(.25>a&&-.25<a){for(var b=a,c=1,d=a,e=0,f=1;e!=d;)b*=a,f*=-1,d=(e=d)+f*b/++c;return d}return Math.log(1+a)};$jscomp.math.expm1=function(a){a=Number(a);if(.25>a&&-.25<a){for(var b=a,c=1,d=a,e=0;e!=d;)b*=a/++c,d=(e=d)+b;return d}return Math.exp(a)-1};$jscomp.math.cosh=function(a){a=Number(a);return (Math.exp(a)+Math.exp(-a))/2};
	$jscomp.math.sinh=function(a){a=Number(a);return 0===a?a:(Math.exp(a)-Math.exp(-a))/2};$jscomp.math.tanh=function(a){a=Number(a);if(0===a)return a;var b=Math.exp(-2*Math.abs(a)),b=(1-b)/(1+b);return 0>a?-b:b};$jscomp.math.acosh=function(a){a=Number(a);return Math.log(a+Math.sqrt(a*a-1))};$jscomp.math.asinh=function(a){a=Number(a);if(0===a)return a;var b=Math.log(Math.abs(a)+Math.sqrt(a*a+1));return 0>a?-b:b};
	$jscomp.math.atanh=function(a){a=Number(a);return ($jscomp.math.log1p(a)-$jscomp.math.log1p(-a))/2};$jscomp.math.hypot=function(a,b,c){a=Number(a);b=Number(b);var d,e,f,g=Math.max(Math.abs(a),Math.abs(b));for(d=2;d<arguments.length;d++)g=Math.max(g,Math.abs(arguments[d]));if(1E100<g||1E-100>g){a/=g;b/=g;f=a*a+b*b;for(d=2;d<arguments.length;d++)e=Number(arguments[d])/g,f+=e*e;return Math.sqrt(f)*g}f=a*a+b*b;for(d=2;d<arguments.length;d++)e=Number(arguments[d]),f+=e*e;return Math.sqrt(f)};
	$jscomp.math.trunc=function(a){a=Number(a);if(isNaN(a)||Infinity===a||-Infinity===a||0===a)return a;var b=Math.floor(Math.abs(a));return 0>a?-b:b};$jscomp.math.cbrt=function(a){if(0===a)return a;a=Number(a);var b=Math.pow(Math.abs(a),1/3);return 0>a?-b:b};$jscomp.number=$jscomp.number||{};$jscomp.number.isFinite=function(a){return "number"!==typeof a?!1:!isNaN(a)&&Infinity!==a&&-Infinity!==a};$jscomp.number.isInteger=function(a){return $jscomp.number.isFinite(a)?a===Math.floor(a):!1};
	$jscomp.number.isNaN=function(a){return "number"===typeof a&&isNaN(a)};$jscomp.number.isSafeInteger=function(a){return $jscomp.number.isInteger(a)&&Math.abs(a)<=$jscomp.number.MAX_SAFE_INTEGER};$jscomp.number.EPSILON=function(){return Math.pow(2,-52)}();$jscomp.number.MAX_SAFE_INTEGER=function(){return 9007199254740991}();$jscomp.number.MIN_SAFE_INTEGER=function(){return -9007199254740991}();$jscomp.object=$jscomp.object||{};
	$jscomp.object.assign=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(d)for(var e in d)Object.prototype.hasOwnProperty.call(d,e)&&(a[e]=d[e]);}return a};$jscomp.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};$jscomp.ASSUME_NO_NATIVE_SET=!1;
	$jscomp.Set$isConformant=function(){if($jscomp.ASSUME_NO_NATIVE_SET)return !1;var a=$jscomp.global.Set;if(!a||!a.prototype.entries||"function"!=typeof Object.seal)return !1;try{var b=Object.seal({x:4}),c=new a($jscomp.makeIterator([b]));if(!c.has(b)||1!=c.size||c.add(b)!=c||1!=c.size||c.add({x:4})!=c||2!=c.size)return !1;var d=c.entries(),e=d.next();if(e.done||e.value[0]!=b||e.value[1]!=b)return !1;e=d.next();return e.done||e.value[0]==b||4!=e.value[0].x||e.value[1]!=e.value[0]?!1:d.next().done}catch(f){return !1}};
	$jscomp.Set=function(a){this.map_=new $jscomp.Map;if(a){a=$jscomp.makeIterator(a);for(var b;!(b=a.next()).done;)this.add(b.value);}this.size=this.map_.size;};$jscomp.Set.prototype.add=function(a){this.map_.set(a,a);this.size=this.map_.size;return this};$jscomp.Set.prototype["delete"]=function(a){a=this.map_["delete"](a);this.size=this.map_.size;return a};$jscomp.Set.prototype.clear=function(){this.map_.clear();this.size=0;};$jscomp.Set.prototype.has=function(a){return this.map_.has(a)};
	$jscomp.Set.prototype.entries=function(){return this.map_.entries()};$jscomp.Set.prototype.values=function(){return this.map_.values()};$jscomp.Set.prototype.forEach=function(a,b){var c=this;this.map_.forEach(function(d){return a.call(b,d,d,c)});};$jscomp.Set$install=function(){$jscomp.Map$install();$jscomp.Set$isConformant()?$jscomp.Set=$jscomp.global.Set:($jscomp.initSymbol(),$jscomp.initSymbolIterator(),$jscomp.Set.prototype[Symbol.iterator]=$jscomp.Set.prototype.values,$jscomp.Set$install=function(){});};
	$jscomp.string=$jscomp.string||{};$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
	$jscomp.string.fromCodePoint=function(a){for(var b="",c=0;c<arguments.length;c++){var d=Number(arguments[c]);if(0>d||1114111<d||d!==Math.floor(d))throw new RangeError("invalid_code_point "+d);65535>=d?b+=String.fromCharCode(d):(d-=65536,b+=String.fromCharCode(d>>>10&1023|55296),b+=String.fromCharCode(d&1023|56320));}return b};
	$jscomp.string.repeat=function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var c="";a;)if(a&1&&(c+=b),a>>>=1)b+=b;return c};$jscomp.string.repeat$install=function(){String.prototype.repeat||(String.prototype.repeat=$jscomp.string.repeat);};
	$jscomp.string.codePointAt=function(a){var b=$jscomp.checkStringArgs(this,null,"codePointAt"),c=b.length;a=Number(a)||0;if(0<=a&&a<c){a|=0;var d=b.charCodeAt(a);if(55296>d||56319<d||a+1===c)return d;a=b.charCodeAt(a+1);return 56320>a||57343<a?d:1024*(d-55296)+a+9216}};$jscomp.string.codePointAt$install=function(){String.prototype.codePointAt||(String.prototype.codePointAt=$jscomp.string.codePointAt);};
	$jscomp.string.includes=function(a,b){return -1!==$jscomp.checkStringArgs(this,a,"includes").indexOf(a,b||0)};$jscomp.string.includes$install=function(){String.prototype.includes||(String.prototype.includes=$jscomp.string.includes);};$jscomp.string.startsWith=function(a,b){var c=$jscomp.checkStringArgs(this,a,"startsWith");a+="";for(var d=c.length,e=a.length,f=Math.max(0,Math.min(b|0,c.length)),g=0;g<e&&f<d;)if(c[f++]!=a[g++])return !1;return g>=e};
	$jscomp.string.startsWith$install=function(){String.prototype.startsWith||(String.prototype.startsWith=$jscomp.string.startsWith);};$jscomp.string.endsWith=function(a,b){var c=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===b&&(b=c.length);for(var d=Math.max(0,Math.min(b|0,c.length)),e=a.length;0<e&&0<d;)if(c[--d]!=a[--e])return !1;return 0>=e};$jscomp.string.endsWith$install=function(){String.prototype.endsWith||(String.prototype.endsWith=$jscomp.string.endsWith);};
	var COMPILED$1=!0,goog=goog||{};goog.global=commonjsGlobal;goog.isDef=function(a){return void 0!==a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]?c[d]:c[d]={};};
	goog.define=function(a,b){var c=b;goog.exportPath_(a,c);};goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=!goog.DEBUG;
	goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;goog.provide=function(a){goog.constructNamespace_(a);};goog.constructNamespace_=function(a,b){goog.exportPath_(a,b);};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly.");if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;};goog.module.get=function(a){return goog.module.getInternal_(a)};
	goog.module.getInternal_=function(a){};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return null!=goog.moduleLoaderState_};
	goog.module.declareLegacyNamespace=function(){goog.moduleLoaderState_.declareLegacyNamespace=!0;};
	goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};goog.getObjectByName=function(a,b){for(var c=a.split("."),d=b||goog.global,e;e=c.shift();)if(goog.isDefAndNotNull(d[e]))d=d[e];else return null;return d};goog.globalize=function(a,b){var c=b||goog.global,d;for(d in a)c[d]=a[d];};goog.addDependency=function(a,b,c,d){if(goog.DEPENDENCIES_ENABLED){var e;a=a.replace(/\\/g,"/");for(var f=goog.dependencies_,g=0;e=b[g];g++)f.nameToPath[e]=a,f.pathIsModule[a]=!!d;for(d=0;b=c[d];d++)a in f.requires||(f.requires[a]={}),f.requires[a][b]=!0;}};
	goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a);};goog.require=function(a){};
	goog.basePath="";goog.nullFunction=function(){};goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a};};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED$1;
	goog.DEPENDENCIES_ENABLED&&(goog.dependencies_={pathIsModule:{},nameToPath:{},requires:{},visited:{},written:{},deferred:{}},goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_())for(var a=goog.global.document.getElementsByTagName("SCRIPT"),b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?"),d=-1==d?c.length:
	d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}},goog.importScript_=function(a,b){(goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_)(a,b)&&(goog.dependencies_.written[a]=!0);},goog.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.importModule_=function(a){goog.importScript_("",'goog.retrieveAndExecModule_("'+a+'");')&&(goog.dependencies_.written[a]=!0);},goog.queuedModules_=[],goog.wrapModule_=function(a,b){return goog.LOAD_MODULE_USING_EVAL&&
	goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(b+"\n//# sourceURL="+a+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+b+"\n;return exports});\n//# sourceURL="+a+"\n"},goog.loadQueuedModules_=function(){var a=goog.queuedModules_.length;if(0<a){var b=goog.queuedModules_;goog.queuedModules_=[];for(var c=0;c<a;c++)goog.maybeProcessDeferredPath_(b[c]);}},goog.maybeProcessDeferredDep_=function(a){goog.isDeferredModule_(a)&&goog.allDepsAreAvailable_(a)&&(a=goog.getPathFromDeps_(a),
	goog.maybeProcessDeferredPath_(goog.basePath+a));},goog.isDeferredModule_=function(a){return (a=goog.getPathFromDeps_(a))&&goog.dependencies_.pathIsModule[a]?goog.basePath+a in goog.dependencies_.deferred:!1},goog.allDepsAreAvailable_=function(a){if((a=goog.getPathFromDeps_(a))&&a in goog.dependencies_.requires)for(var b in goog.dependencies_.requires[a])if(!goog.isProvided_(b)&&!goog.isDeferredModule_(b))return !1;return !0},goog.maybeProcessDeferredPath_=function(a){if(a in goog.dependencies_.deferred){var b=
	goog.dependencies_.deferred[a];delete goog.dependencies_.deferred[a];goog.globalEval(b);}},goog.loadModuleFromUrl=function(a){goog.retrieveAndExecModule_(a);},goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:void 0,declareLegacyNamespace:!1};var c;if(goog.isFunction(a))c=a.call(goog.global,{});else if(goog.isString(a))c=goog.loadModuleFromSource_.call(goog.global,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;
	if(!goog.isString(d)||!d)throw Error('Invalid module name "'+d+'"');goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&Object.seal(c);goog.loadedModules_[d]=c;}finally{goog.moduleLoaderState_=b;}},goog.loadModuleFromSource_=function(a){eval(a);return {}},goog.writeScriptSrcNode_=function(a){goog.global.document.write('<script type="text/javascript" src="'+a+'">\x3c/script>');},goog.appendScriptSrcNode_=function(a){var b=goog.global.document,
	c=b.createElement("script");c.type="text/javascript";c.src=a;c.defer=!1;c.async=!1;b.head.appendChild(c);},goog.writeScriptTag_=function(a,b){if(goog.inHtmlDocument_()){var c=goog.global.document;if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&"complete"==c.readyState){if(/\bdeps.js$/.test(a))return !1;throw Error('Cannot write "'+a+'" after document load');}var d=goog.IS_OLD_IE_;void 0===b?d?(d=" onreadystatechange='goog.onScriptLoad_(this, "+ ++goog.lastNonModuleScriptIndex_+")' ",c.write('<script type="text/javascript" src="'+
	a+'"'+d+">\x3c/script>")):goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING?goog.appendScriptSrcNode_(a):goog.writeScriptSrcNode_(a):c.write('<script type="text/javascript">'+b+"\x3c/script>");return !0}return !1},goog.lastNonModuleScriptIndex_=0,goog.onScriptLoad_=function(a,b){"complete"==a.readyState&&goog.lastNonModuleScriptIndex_==b&&goog.loadQueuedModules_();return !0},goog.writeScripts_=function(a){function b(a){if(!(a in e.written||a in e.visited)){e.visited[a]=!0;if(a in e.requires)for(var f in e.requires[a])if(!goog.isProvided_(f))if(f in
	e.nameToPath)b(e.nameToPath[f]);else throw Error("Undefined nameToPath for "+f);a in d||(d[a]=!0,c.push(a));}}var c=[],d={},e=goog.dependencies_;b(a);for(a=0;a<c.length;a++){var f=c[a];goog.dependencies_.written[f]=!0;}var g=goog.moduleLoaderState_;goog.moduleLoaderState_=null;for(a=0;a<c.length;a++)if(f=c[a])e.pathIsModule[f]?goog.importModule_(goog.basePath+f):goog.importScript_(goog.basePath+f);else throw goog.moduleLoaderState_=g,Error("Undefined script input");goog.moduleLoaderState_=g;},goog.getPathFromDeps_=
	function(a){return a in goog.dependencies_.nameToPath?goog.dependencies_.nameToPath[a]:null},goog.findBasePath_(),goog.global.CLOSURE_NO_DEPS||goog.importScript_(goog.basePath+"deps.js"));goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
	goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return b.responseText};
	goog.retrieveAndExecModule_=function(a){};
	goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
	else if("function"==b&&"undefined"==typeof a.call)return "object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return "array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return "array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isString=function(a){return "string"==typeof a};
	goog.isBoolean=function(a){return "boolean"==typeof a};goog.isNumber=function(a){return "number"==typeof a};goog.isFunction=function(a){return "function"==goog.typeOf(a)};goog.isObject=function(a){var b=typeof a;return "object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return !!a[goog.UID_PROPERTY_]};
	goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_];}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(a.clone)return a.clone();var b="array"==b?[]:{},c;for(c in a)b[c]=goog.cloneObject(a[c]);return b}return a};
	goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};
	goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c];};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return +new Date};
	goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_)if(goog.global.eval("var _evalTest_ = 1;"),"undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_;}catch(d){}goog.evalWorksForGlobals_=!0;}else goog.evalWorksForGlobals_=!1;if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=!1;c.appendChild(b.createTextNode(a));
	b.body.appendChild(c);b.body.removeChild(c);}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;goog.getCssName=function(a,b){var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")},d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};return b?a+"-"+d(b):d(a)};
	goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b;};goog.getMsg=function(a,b){b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,d){return null!=b&&d in b?b[d]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c);};goog.exportProperty=function(a,b,c){a[b]=c;};
	goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)};};
	goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if(d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];for(var f=!1,g=a.constructor;g;g=
	g.superClass_&&g.superClass_.constructor)if(g.prototype[b]===d)f=!0;else if(f)return g.prototype[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){a.call(goog.global);};goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;
	goog.defineClass.createSealingConstructor_=function(a,b){if(goog.defineClass.SEAL_CLASS_INSTANCES&&Object.seal instanceof Function){if(b&&b.prototype&&b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_])return a;var c=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===c&&Object.seal(b);return b};return c}return a};goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);};goog.tagUnsealableClass=function(a){};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else{var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));this.reportErrorToServer=!0;};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.string={};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(0,b.length))};
	goog.string.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};goog.string.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};
	goog.string.isEmptyOrWhitespace=function(a){return /^[\s\xa0]*$/.test(a)};goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return !/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return !/[^a-zA-Z]/.test(a)};
	goog.string.isNumeric=function(a){return !/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return !/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return " "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};
	goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};
	goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=function(a,b){var c=String(a).toLowerCase(),d=String(b).toLowerCase();return c<d?-1:c==d?0:1};
	goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return -1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
	goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
	goog.string.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.AMP_RE_,"&amp;").replace(goog.string.LT_RE_,"&lt;").replace(goog.string.GT_RE_,"&gt;").replace(goog.string.QUOT_RE_,"&quot;").replace(goog.string.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.NULL_RE_,"&#0;"),goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));else{if(!goog.string.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.LT_RE_,
	"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.NULL_RE_,"&#0;"));goog.string.DETECT_DOUBLE_ESCAPING&&-1!=a.indexOf("e")&&(a=a.replace(goog.string.E_RE_,"&#101;"));}return a};goog.string.AMP_RE_=/&/g;goog.string.LT_RE_=/</g;goog.string.GT_RE_=/>/g;goog.string.QUOT_RE_=/"/g;
	goog.string.SINGLE_QUOTE_RE_=/'/g;goog.string.NULL_RE_=/\x00/g;goog.string.E_RE_=/e/g;goog.string.ALL_RE_=goog.string.DETECT_DOUBLE_ESCAPING?/[\x00&<>"'e]/:/[\x00&<>"']/;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
	goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
	goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'},d;d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var g=c[a];if(g)return g;if("#"==b.charAt(0)){var h=Number("0"+b.substr(1));isNaN(h)||(g=String.fromCharCode(h));}g||(d.innerHTML=a+" ",g=d.firstChild.nodeValue.slice(0,-1));return c[a]=g})};
	goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return "&";case "lt":return "<";case "gt":return ">";case "quot":return '"';default:if("#"==c.charAt(0)){var d=Number("0"+c.substr(1));if(!isNaN(d))return String.fromCharCode(d)}return a}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
	goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
	goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e);}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"<"};goog.string.jsEscapeCache_={"'":"\\'"};
	goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d));}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
	goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b,c=a.charCodeAt(0);if(31<c&&127>c)b=a;else{if(256>c){if(b="\\x",16>c||256<c)b+="0";}else b="\\u",4096>c&&(b+="0");b+=c.toString(16).toUpperCase();}return goog.string.jsEscapeCache_[a]=b};goog.string.contains=function(a,b){return -1!=a.indexOf(b)};
	goog.string.caseInsensitiveContains=function(a,b){return goog.string.contains(a.toLowerCase(),b.toLowerCase())};goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){var c=new RegExp(goog.string.regExpEscape(b),"");return a.replace(c,"")};
	goog.string.removeAll=function(a,b){var c=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(c,"")};goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};
	goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};
	goog.string.compareVersions=function(a,b){for(var c=0,d=goog.string.trim(String(a)).split("."),e=goog.string.trim(String(b)).split("."),f=Math.max(d.length,e.length),g=0;0==c&&g<f;g++){var h=d[g]||"",k=e[g]||"",l=RegExp("(\\d*)(\\D*)","g"),p=RegExp("(\\d*)(\\D*)","g");do{var m=l.exec(h)||["","",""],n=p.exec(k)||["","",""];if(0==m[0].length&&0==n[0].length)break;var c=0==m[1].length?0:parseInt(m[1],10),q=0==n[1].length?0:parseInt(n[1],10),c=goog.string.compareElements_(c,q)||goog.string.compareElements_(0==
	m[2].length,0==n[2].length)||goog.string.compareElements_(m[2],n[2]);}while(0==c)}return c};goog.string.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;goog.string.createUniqueString=function(){return "goog_"+goog.string.uniqueStringCounter_++};
	goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return /^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return /^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};
	goog.string.toTitleCase=function(a,b){var c=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(c?"|["+c+"]+":"")+")([a-z])","g"),function(a,b,c){return b+c.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};
	goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f];}return d[b.length]};goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){b.unshift(a);goog.debug.Error.call(this,goog.string.subs.apply(null,b));b.shift();this.messagePattern=a;};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
	goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c)var e=e+(": "+c),f=d;else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a);};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a);};goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)));};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.");};
	goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};var jspb={Map:function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_();}};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1]);}this.arrClean=!0;};
	jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray();}}}else{this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value]);}this.arrClean=!0;}return this.arr_};
	jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value]);}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f);}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a;};
	jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};$jscomp.initSymbol();"undefined"!=typeof Symbol&&($jscomp.initSymbol(),$jscomp.initSymbolIterator(),jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1;};
	jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value]);}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)]);}return new jspb.Map.ArrayIteratorIterable_(a)};
	jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
	jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this);}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
	jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage();}};
	jspb.Map.deserializeBinary=function(a,b,c,d,e,f){for(var g=void 0;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g=new a.valueCtor_,d.call(b,g,e)):g=d.call(b));}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g);};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
	jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0;};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=!1;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
	goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};
	goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return -1};
	goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c);}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a);};goog.array.forEachRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,d=d-1;0<=d;--d)d in e&&b.call(c,e[d],d,a);};
	goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k);}return e};
	goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
	goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return !0;return !1};
	goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return !1;return !0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d;},c);return d};
	goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return -1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
	goog.array.findIndexRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,d=d-1;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return -1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0;};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b);};
	goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b);};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b);};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d);};goog.array.remove=function(a,b){var c=goog.array.indexOf(a,b),d;(d=0<=c)&&goog.array.removeAt(a,c);return d};
	goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++;});return d};goog.array.concat=function(a){return Array.prototype.concat.apply(Array.prototype,arguments)};
	goog.array.join=function(a){return Array.prototype.concat.apply(Array.prototype,arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return []};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g];}else a.push(d);}};
	goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
	goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;for(var d={},e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g);}b.length=e;};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
	goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1,l;l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l);}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare);};goog.array.stableSort=function(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||goog.array.defaultCompare;goog.array.sort(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value;};
	goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))});};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c);};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return !1}return !0};
	goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return !1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return !1;return !0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
	goog.array.inverseDefaultCompare=function(a,b){return -goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
	goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f);}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e;});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return [];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
	goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192)for(var f=goog.array.slice(d,e,e+8192),f=goog.array.flatten.apply(null,f),g=0;g<f.length;g++)b.push(f[g]);else b.push(d);}return b};
	goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0]);};
	goog.array.zip=function(a){if(!arguments.length)return [];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e);}return b};goog.array.shuffle=function(a,b){for(var c=b||Math.random,d=a.length-1;0<d;d--){var e=Math.floor(c()*(d+1)),f=a[d];a[d]=a[e];a[e]=f;}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b]);});return c};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){for(var e=a.charCodeAt(d);255<e;)b[c++]=e&255,e>>=8;b[c++]=e;}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192)var d=goog.array.slice(a,c,c+8192),b=b+String.fromCharCode.apply(null,d);return b};goog.crypt.byteArrayToHex=function(a){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join("")};
	goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
	goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128);}return b};
	goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63);}else if(239<e&&365>e){var f=a[c++],g=a[c++],h=a[c++],e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023));}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63);}return b.join("")};
	goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_();};
	goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.caseInsensitiveContains(b,a)};
	goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=RegExp("(\\w[\\w ]+)/([^\\s]+)\\s*(?:\\((.*?)\\))?","g"),c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
	goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
	goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};
	goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,
	b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.object={};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a);};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return !0;return !1};goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return !1;return !0};
	goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};
	goog.object.getValueByKeys=function(a,b){for(var c=goog.isArrayLike(b),d=c?b:arguments,c=c?0:1;c<d.length&&(a=a[d[c]],goog.isDef(a));c++);return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return !0;return !1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};goog.object.findValue=function(a,b,c){return (b=goog.object.findKey(a,b,c))&&a[b]};
	goog.object.isEmpty=function(a){for(var b in a)return !1;return !0};goog.object.clear=function(a){for(var b in a)delete a[b];};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c);};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};goog.object.set=function(a,b,c){a[b]=c;};
	goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return !1;for(c in b)if(!(c in a))return !1;return !0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
	goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();var b="array"==b?[]:{},c;for(c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}};
	goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
	goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return !!Object.isFrozen&&Object.isFrozen(a)};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")||goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdge_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")};
	goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdge_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};
	goog.labs.userAgent.browser.matchIosWebview_=function(){return (goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
	goog.labs.userAgent.browser.matchChrome_=function(){return (goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchOpera_()&&!goog.labs.userAgent.browser.matchEdge_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
	goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdge_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;
	goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
	goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);var b=goog.labs.userAgent.util.extractVersionTuples(b),c={};goog.array.forEach(b,function(a){c[a[0]]=a[1];});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera","OPR"]):goog.labs.userAgent.browser.isEdge()?
	a(["Edge"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
	goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];var b="",c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0";}else b="7.0";else b=c[1];return b};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
	goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
	goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){var a=goog.labs.userAgent.util.extractVersionTuples(a),b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return "Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];var a=a[0],c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return ""};
	goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){var c=goog.array.find(a,function(a){return b==a[0]});return c&&c[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
	goog.userAgent.getNavigator=function(){return goog.global.navigator||null};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;
	goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;
	goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigator();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;goog.userAgent.ASSUME_IPAD=!1;
	goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();
	goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigator();return !!a&&goog.string.contains(a.appVersion||"","X11")};goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();
	goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.operaVersion_=function(){var a=goog.global.opera.version;try{return a()}catch(b){return a}};
	goog.userAgent.determineVersion_=function(){if(goog.userAgent.OPERA&&goog.global.opera)return goog.userAgent.operaVersion_();var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),b>parseFloat(a))?String(b):a};
	goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return /rv\:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return /Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return /WebKit\/(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};goog.userAgent.VERSION=goog.userAgent.determineVersion_();
	goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.userAgent.isVersionOrHigherCache_[a]||(goog.userAgent.isVersionOrHigherCache_[a]=0<=goog.string.compareVersions(goog.userAgent.VERSION,a))};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
	goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){var a=goog.global.document,b=goog.userAgent.getDocumentMode_();return a&&goog.userAgent.IE?b||("CSS1Compat"==a.compatMode?parseInt(goog.userAgent.VERSION,10):5):void 0}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
	goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
	goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
	goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
	goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.byteToCharMap_=null;goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.byteToCharMapWebSafe_=null;goog.crypt.base64.ENCODED_VALS_BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.ENCODED_VALS_BASE+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.ENCODED_VALS_BASE+"-_.";
	goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
	goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");goog.crypt.base64.init_();for(var c=b?goog.crypt.base64.byteToCharMapWebSafe_:goog.crypt.base64.byteToCharMap_,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,h=g?a[e+1]:0,k=e+2<a.length,l=k?a[e+2]:0,p=f>>2,f=(f&3)<<4|h>>4,h=(h&15)<<2|l>>6,l=l&63;k||(l=64,g||(h=64));d.push(c[p],c[f],c[h],c[l]);}return d.join("")};
	goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a);});return c};
	goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a);});return c};goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=new Uint8Array(Math.ceil(3*a.length/4)),c=0;goog.crypt.base64.decodeStringInternal_(a,function(a){b[c++]=a;});return b.subarray(0,c)};
	goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}};
	goog.crypt.base64.init_=function(){if(!goog.crypt.base64.byteToCharMap_){goog.crypt.base64.byteToCharMap_={};goog.crypt.base64.charToByteMap_={};goog.crypt.base64.byteToCharMapWebSafe_={};for(var a=0;a<goog.crypt.base64.ENCODED_VALS.length;a++)goog.crypt.base64.byteToCharMap_[a]=goog.crypt.base64.ENCODED_VALS.charAt(a),goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[a]]=a,goog.crypt.base64.byteToCharMapWebSafe_[a]=goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a),a>=goog.crypt.base64.ENCODED_VALS_BASE.length&&
	(goog.crypt.base64.charToByteMap_[goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a)]=a);}};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e;};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f;};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return !!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
	jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
	jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedFloatingPointFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
	a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b]);};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog.isArray(a)};
	jspb.Message.initPivotAndExtensionObject_=function(a,b){if(a.array.length){var c=a.array.length-1,d=a.array[c];if(d&&"object"==typeof d&&!jspb.Message.isArray_(d)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&d instanceof Uint8Array)){a.pivot_=jspb.Message.getFieldNumber_(a,c);a.extensionObject_=d;return}}-1<b?(a.pivot_=b,a.extensionObject_=null):a.pivot_=Number.MAX_VALUE;};
	jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={});};jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};
	jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h;}}};
	jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
	else f.binaryWriterFn.call(b,g.fieldIndex,h);}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");var g;c.isMessageType()?(g=new c.ctor,f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn)):g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g);}else b.skipField();};
	jspb.Message.getField=function(a,b){if(b<a.pivot_){var c=jspb.Message.getIndex_(a,b),d=a.array[c];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[c]=[]:d}if(a.extensionObject_)return d=a.extensionObject_[b],d===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:d};
	jspb.Message.getRepeatedField=function(a,b){if(b<a.pivot_){var c=jspb.Message.getIndex_(a,b),d=a.array[c];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[c]=[]:d}d=a.extensionObject_[b];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:d};jspb.Message.getOptionalFloatingPointField=function(a,b){var c=jspb.Message.getField(a,b);return null==c?c:+c};
	jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedFloatingPointFields_||(a.convertedFloatingPointFields_={});if(!a.convertedFloatingPointFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedFloatingPointFields_[b]=!0;}return c};
	jspb.Message.bytesAsB64=function(a){if(null==a||goog.isString(a))return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if(goog.isString(a))return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
	jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||goog.isString(a[0])?a:goog.array.map(a,jspb.Message.bytesAsB64)};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
	jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b);});}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;
	jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];if(!c)return c=jspb.Message.getField(a,b),c||(c=[],jspb.Message.setField(a,b,c)),a.wrappers_[b]=new jspb.Map(c,d)};jspb.Message.setField=function(a,b,c){b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);};jspb.Message.setProto3IntField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};
	jspb.Message.setProto3StringIntField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"0");};jspb.Message.setProto3FloatField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};jspb.Message.setProto3BooleanField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,!1);};jspb.Message.setProto3StringField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"");};jspb.Message.setProto3BytesField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"");};
	jspb.Message.setProto3EnumField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){c!=d?jspb.Message.setField(a,b,c):a.array[jspb.Message.getIndex_(a,b)]=null;};jspb.Message.addToRepeatedField=function(a,b,c,d){a=jspb.Message.getRepeatedField(a,b);void 0!=d?a.splice(d,0,c):a.push(c);};
	jspb.Message.setOneofField=function(a,b,c,d){(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));jspb.Message.setField(a,b,d);};jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0));}return c?(jspb.Message.setField(a,c,d),c):0};
	jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e);}return a.wrappers_[c]};jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};
	jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e;}};jspb.Message.setWrapperField=function(a,b,c){a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;jspb.Message.setField(a,b,d);};
	jspb.Message.setOneofWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;jspb.Message.setOneofField(a,b,c,e);};jspb.Message.setRepeatedWrapperField=function(a,b,c){a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;jspb.Message.setField(a,b,d);};
	jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
	jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray();}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
	jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return !this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
	jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
	jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray(),d=b.toArray(),e=[],f=0,g=c.length>d.length?c.length:d.length;a.getJsPbMessageId()&&(e[0]=a.getJsPbMessageId(),f=1);for(;f<g;f++)jspb.Message.compareFields(c[f],d[f])||(e[f]=d[f]);return new a.constructor(e)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
	jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return !1;return !0};
	jspb.Message.compareFields=function(a,b){if(a==b)return !0;if(!goog.isObject(a)||!goog.isObject(b))return goog.isNumber(a)&&isNaN(a)||goog.isNumber(b)&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return !1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return !1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return !1;return !0}if(a.constructor===Array){for(var d=void 0,e=void 0,f=Math.max(a.length,b.length),c=0;c<f;c++){var g=a[c],h=b[c];g&&g.constructor==
	Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return !1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
	jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
	jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");for(var c=jspb.Message.clone(a),d=b.toArray(),e=c.toArray(),f=d.length=0;f<e.length;f++)d[f]=e[f];b.wrappers_=c.wrappers_;b.extensionObject_=c.extensionObject_;};
	jspb.Message.clone_=function(a){var b;if(goog.isArray(a)){for(var c=Array(a.length),d=0;d<a.length;d++)b=a[d],null!=b&&(c[d]="object"==typeof b?jspb.Message.clone_(goog.asserts.assert(b)):b);return c}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);c={};for(d in a)b=a[d],null!=b&&(c[d]="object"==typeof b?jspb.Message.clone_(goog.asserts.assert(b)):b);return c};jspb.Message.registerMessageType=function(a,b){jspb.Message.registry_[a]=b;b.messageId=a;};
	jspb.Message.registry_={};jspb.Message.messageSetExtensions={};jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b;};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
	jspb.arith.UInt64.prototype.msb=function(){return !!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return !!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
	jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){for(var c=a&65535,d=a>>>16,e=b&65535,f=b>>>16,g=c*e+65536*(c*f&65535)+65536*(d*e&65535),c=d*f+(c*f>>>16)+(d*e>>>16);4294967296<=g;)g-=4294967296,c+=1;return new jspb.arith.UInt64(g>>>0,c>>>0)};
	jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
	jspb.arith.UInt64.prototype.div=function(a){if(0==a)return [];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return [b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();)var b=b.div(10),c=b[0],a=b[1].lo+a,b=c;""==a&&(a="0");return a};
	jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c);}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b;};
	jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
	jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return (a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryConstants={};jspb.ConstBinaryMessage=function(){};jspb.BinaryMessage=function(){};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
	jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
	jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
	jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a;};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a;};
	jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c;};
	jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;var c;0===a?0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648):isNaN(a)?(jspb.utils.split64High=0,jspb.utils.split64Low=2147483647):a>jspb.BinaryConstants.FLOAT32_MAX?(jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0):a<jspb.BinaryConstants.FLOAT32_MIN?(a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|a)>>>0):(c=Math.floor(Math.log(a)/
	Math.LN2),a*=Math.pow(2,-c),a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607,jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0);};
	jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0;}else{var d=
	Math.floor(Math.log(a)/Math.LN2);1024==d&&(d=1023);c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c;}};
	jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0;};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+a};
	jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));var d=jspb.utils.joinUint64(a,b);return c?-d:d};jspb.utils.joinZigzag64=function(a,b){var c=a&1;a=(a>>>1|b<<31)>>>0;b>>>=1;c&&(a=a+1>>>0,0==a&&(b=b+1>>>0));var d=jspb.utils.joinUint64(a,b);return c?-d:d};jspb.utils.joinFloat32=function(a,b){var c=2*(a>>31)+1,d=a>>>23&255,e=a&8388607;return 255==d?e?NaN:Infinity*c:0==d?c*Math.pow(2,-149)*e:c*Math.pow(2,d-150)*(e+Math.pow(2,23))};
	jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047,e=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?e?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*e:c*Math.pow(2,d-1075)*(e+jspb.BinaryConstants.TWO_TO_52)};jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");
	jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a){for(var b=1E7,c=0;7>c;c++){var b=b/10,d=a/b%10>>>0;if(0!=d||h)h=!0,k+=g[d];}}if(2097151>=b)return ""+(jspb.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215,e=b>>16&65535,f=(a&16777215)+6777216*d+6710656*e,d=d+8147497*e,e=2*e;1E7<=f&&(d+=Math.floor(f/1E7),f%=1E7);1E7<=d&&(e+=Math.floor(d/1E7),d%=1E7);var g=jspb.utils.DIGITS,h=!1,k="";(e||h)&&c(e);(d||h)&&c(d);(f||h)&&c(f);return k};
	jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);var d=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+d:d};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);var c=jspb.utils.split64Low,d=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(c,d):jspb.utils.joinUnsignedDecimalString(c,d)};
	jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
	jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++){var d=a*e[c]+b;e[c]=d&255;b=d>>>8;}}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255;}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,jspb.utils.DIGITS.indexOf(a[f]));d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));};
	jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.DIGITS[d>>4];b[2*c+3]=jspb.utils.DIGITS[d&15];}return b.join("")};jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++)var d=jspb.utils.DIGITS.indexOf(a[2*c+2]),e=jspb.utils.DIGITS.indexOf(a[2*c+3]),b=String.fromCharCode(16*d+e)+b;return b};
	jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);var c=jspb.utils.split64Low,d=jspb.utils.split64High;return b?jspb.utils.joinInt64(c,d):jspb.utils.joinUint64(c,d)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
	jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7;}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7;}if(a[b++]!=g)break;f++;b+=e;}return f};
	jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
	jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7;}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g;}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16);}return b+'"'};
	jspb.utils.debugScalarToTextFormat=function(a){return goog.isString(a)?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d;}return b};
	jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryEncoder=function(){this.buffer_=[];};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
	jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a);};
	jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b);};
	jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a);};
	jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else{for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1);}};
	jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0);};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarint64(parseInt(a,10));};jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};
	jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low);};
	jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert(goog.isBoolean(a)||goog.isNumber(a));this.buffer_.push(a?1:0);};
	jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a);};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a);};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++);}else this.buffer_.push(d>>
	12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128);}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[];};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length;};
	jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop(),b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++;};
	jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c));};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c);};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[];};
	jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length;}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
	jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a));};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop());};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b);};
	jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
	break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()");}};
	jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b));};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b));};
	jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b));};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b));};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b));};
	jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b));};jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};
	jspb.BinaryWriter.prototype.writeInt32String=function(a,b){if(null!=b){var c=parseInt(b,10);goog.asserts.assert(c>=-jspb.BinaryConstants.TWO_TO_31&&c<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32_(a,c);}};jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b));};
	jspb.BinaryWriter.prototype.writeInt64String=function(a,b){if(null!=b){var c=jspb.arith.Int64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};
	jspb.BinaryWriter.prototype.writeUint32String=function(a,b){if(null!=b){var c=parseInt(b,10);goog.asserts.assert(0<=c&&c<jspb.BinaryConstants.TWO_TO_32);this.writeUnsignedVarint32_(a,c);}};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b));};
	jspb.BinaryWriter.prototype.writeUint64String=function(a,b){if(null!=b){var c=jspb.arith.UInt64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b));};
	jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b));};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&(goog.asserts.assert(+b>=-jspb.BinaryConstants.TWO_TO_63&&+b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64String_(a,b));};
	jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b));};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b));};
	jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){if(null!=b){var c=jspb.arith.UInt64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b));};
	jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b));};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){if(null!=b){var c=jspb.arith.Int64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};
	jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b));};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b));};jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert(goog.isBoolean(b)||goog.isNumber(b)),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b));};
	jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeString=function(a,b){if(null!=b){var c=this.beginDelimited_(a);this.encoder_.writeString(b);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writeBytes=function(a,b){if(null!=b){var c=jspb.utils.byteSourceToUint8Array(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(c.length);this.appendUint8Array_(c);}};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a));};
	jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP));};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b));};
	jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b));};jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e);}};
	jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP);};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c]);};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint32(b[d]);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint32(parseInt(b[d],10));this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint64(b[d]);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++){var e=jspb.arith.Int64.fromString(b[d]);this.encoder_.writeSplitVarint64(e.lo,e.hi);}this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint32(b[d]);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint32(parseInt(b[d],10));this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint64(b[d]);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++){var e=jspb.arith.UInt64.fromString(b[d]);this.encoder_.writeSplitVarint64(e.lo,e.hi);}this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint32(b[d]);this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint64(b[d]);this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint64(parseInt(b[d],10));this.endDelimited_(c);}};
	jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeUint32(b[c]);}};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeUint64(b[c]);}};
	jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitFixed64(d.lo,d.hi);}}};
	jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt32(b[c]);}};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt64(b[c]);}};
	jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt64String(b[c]);}};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeFloat(b[c]);}};
	jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeDouble(b[c]);}};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(b.length);for(var c=0;c<b.length;c++)this.encoder_.writeBool(b[c]);}};
	jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeEnum(b[d]);this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeFixedHash64(b[c]);}};
	jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeVarintHash64(b[d]);this.endDelimited_(c);}};jspb.BinaryIterator=function(a,b,c){this.elements_=this.nextMethod_=this.decoder_=null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!0;this.init_(a,b,c);};jspb.BinaryIterator.prototype.init_=function(a,b,c){a&&b&&(this.decoder_=a,this.nextMethod_=b);this.elements_=c||null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!this.decoder_&&!this.elements_;this.next();};jspb.BinaryIterator.instanceCache_=[];
	jspb.BinaryIterator.alloc=function(a,b,c){if(jspb.BinaryIterator.instanceCache_.length){var d=jspb.BinaryIterator.instanceCache_.pop();d.init_(a,b,c);return d}return new jspb.BinaryIterator(a,b,c)};jspb.BinaryIterator.prototype.free=function(){this.clear();100>jspb.BinaryIterator.instanceCache_.length&&jspb.BinaryIterator.instanceCache_.push(this);};
	jspb.BinaryIterator.prototype.clear=function(){this.decoder_&&this.decoder_.free();this.elements_=this.nextMethod_=this.decoder_=null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!0;};jspb.BinaryIterator.prototype.get=function(){return this.nextValue_};jspb.BinaryIterator.prototype.atEnd=function(){return this.atEnd_};
	jspb.BinaryIterator.prototype.next=function(){var a=this.nextValue_;this.decoder_?this.decoder_.atEnd()?(this.nextValue_=null,this.atEnd_=!0):this.nextValue_=this.nextMethod_.call(this.decoder_):this.elements_&&(this.cursor_==this.elements_.length?(this.nextValue_=null,this.atEnd_=!0):this.nextValue_=this.elements_[this.cursor_++]);return a};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.tempHigh_=this.tempLow_=this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c);};
	jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this);};jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};
	jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=goog.isDef(b)?b:0;this.end_=goog.isDef(c)?this.start_+c:this.bytes_.length;this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};
	jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a;};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a;};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};
	jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
	jspb.BinaryDecoder.prototype.readSplitVarint64_=function(){for(var a,b=0,c,d=0;4>d;d++)if(a=this.bytes_[this.cursor_++],b|=(a&127)<<7*d,128>a){this.tempLow_=b>>>0;this.tempHigh_=0;return}a=this.bytes_[this.cursor_++];b|=(a&127)<<28;c=0|(a&127)>>4;if(128>a)this.tempLow_=b>>>0,this.tempHigh_=c>>>0;else{for(d=0;5>d;d++)if(a=this.bytes_[this.cursor_++],c|=(a&127)<<7*d+3,128>a){this.tempLow_=b>>>0;this.tempHigh_=c>>>0;return}goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=
	!0;}};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++;};jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--;};
	jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a,b=this.bytes_;a=b[this.cursor_+0];var c=a&127;if(128>a)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+1];c|=(a&127)<<7;if(128>a)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+2];c|=(a&127)<<14;if(128>a)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+3];c|=(a&127)<<21;if(128>a)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
	this.end_),c;a=b[this.cursor_+4];c|=(a&15)<<28;if(128>a)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
	jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinUint64(this.tempLow_,this.tempHigh_)};
	jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){this.readSplitVarint64_();return jspb.utils.joinUnsignedDecimalString(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readSignedVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinInt64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){this.readSplitVarint64_();return jspb.utils.joinSignedDecimalString(this.tempLow_,this.tempHigh_)};
	jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinZigzag64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readZigzagVarint64().toString()};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};
	jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8|c<<16|d<<24)>>>0};
	jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
	jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
	jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
	jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return !!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
	jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63);}else if(240>f){var g=b[c++],h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63);}else if(248>f){var g=b[c++],h=b[c++],k=b[c++],f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63,f=f-65536;d.push((f>>10&1023)+55296,(f&1023)+56320);}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0);}e+=goog.crypt.byteArrayToString(d);
	this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};
	jspb.BinaryDecoder.prototype.readVarintHash64=function(){this.readSplitVarint64_();return jspb.utils.joinHash64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6],a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;};jspb.BinaryReader.instanceCache_=[];
	jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
	jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this);};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
	jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
	jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a);};
	jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return !1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3,a=a&7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type"),
	this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return !0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_);};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader();};
	jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint();};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else{var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a);}};
	jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4);};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8);};
	jspb.BinaryReader.prototype.skipGroup=function(){var a=[this.nextField_];do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP)a.push(this.nextField_);else if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP&&this.nextField_!=a.pop()){goog.asserts.fail("Unmatched end-group tag");this.error_=!0;break}}while(0<a.length)};
	jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.");}};
	jspb.BinaryReader.prototype.registerReadCallback=function(a,b){goog.isNull(this.readCallbacks_)&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b;};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(!goog.isNull(this.readCallbacks_));a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
	jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
	case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
	default:goog.asserts.fail("Invalid field type in readAny()");}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32(),d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c);};
	jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0);};
	jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a,a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
	jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
	jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
	jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
	jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
	jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
	jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
	jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return !!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
	jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
	jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
	jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);for(var b=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor()+b,c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};
	jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};
	jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};
	jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};
	jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};
	jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};
	jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Export={};var Map$1=jspb.Map;var Message=jspb.Message;var BinaryReader=jspb.BinaryReader;var BinaryWriter=jspb.BinaryWriter;var ExtensionFieldInfo=jspb.ExtensionFieldInfo;var ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;var exportSymbol=goog.exportSymbol;var inherits=goog.inherits;var object={extend:goog.object.extend};var typeOf=goog.typeOf;

	var googleProtobuf = {
		Map: Map$1,
		Message: Message,
		BinaryReader: BinaryReader,
		BinaryWriter: BinaryWriter,
		ExtensionFieldInfo: ExtensionFieldInfo,
		ExtensionFieldBinaryInfo: ExtensionFieldBinaryInfo,
		exportSymbol: exportSymbol,
		inherits: inherits,
		object: object,
		typeOf: typeOf
	};

	var timestamp_pb = createCommonjsModule(function (module, exports) {
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!


	var goog = googleProtobuf;
	var global = Function('return this')();

	goog.exportSymbol('proto.google.protobuf.Timestamp', null, global);

	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.google.protobuf.Timestamp = function(opt_data) {
	  googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.google.protobuf.Timestamp, googleProtobuf.Message);


	if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.google.protobuf.Timestamp.prototype.toObject = function(opt_includeInstance) {
	  return proto.google.protobuf.Timestamp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.google.protobuf.Timestamp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.Timestamp.toObject = function(includeInstance, msg) {
	  var obj = {
	    seconds: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	    nanos: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.google.protobuf.Timestamp}
	 */
	proto.google.protobuf.Timestamp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf.BinaryReader(bytes);
	  var msg = new proto.google.protobuf.Timestamp;
	  return proto.google.protobuf.Timestamp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.google.protobuf.Timestamp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.google.protobuf.Timestamp}
	 */
	proto.google.protobuf.Timestamp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setSeconds(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setNanos(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.google.protobuf.Timestamp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf.BinaryWriter();
	  proto.google.protobuf.Timestamp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.google.protobuf.Timestamp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.Timestamp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getSeconds();
	  if (f !== 0) {
	    writer.writeInt64(
	      1,
	      f
	    );
	  }
	  f = message.getNanos();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	};


	/**
	 * optional int64 seconds = 1;
	 * @return {number}
	 */
	proto.google.protobuf.Timestamp.prototype.getSeconds = function() {
	  return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
	};


	/** @param {number} value */
	proto.google.protobuf.Timestamp.prototype.setSeconds = function(value) {
	  googleProtobuf.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int32 nanos = 2;
	 * @return {number}
	 */
	proto.google.protobuf.Timestamp.prototype.getNanos = function() {
	  return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.google.protobuf.Timestamp.prototype.setNanos = function(value) {
	  googleProtobuf.Message.setProto3IntField(this, 2, value);
	};


	goog.object.extend(exports, proto.google.protobuf);
	// Protocol Buffers - Google's data interchange format
	// Copyright 2008 Google Inc.  All rights reserved.
	// https://developers.google.com/protocol-buffers/
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are
	// met:
	//
	//     * Redistributions of source code must retain the above copyright
	// notice, this list of conditions and the following disclaimer.
	//     * Redistributions in binary form must reproduce the above
	// copyright notice, this list of conditions and the following disclaimer
	// in the documentation and/or other materials provided with the
	// distribution.
	//     * Neither the name of Google Inc. nor the names of its
	// contributors may be used to endorse or promote products derived from
	// this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	/* This code will be inserted into generated code for
	 * google/protobuf/timestamp.proto. */

	/**
	 * Returns a JavaScript 'Date' object corresponding to this Timestamp.
	 * @return {!Date}
	 */
	proto.google.protobuf.Timestamp.prototype.toDate = function() {
	  var seconds = this.getSeconds();
	  var nanos = this.getNanos();

	  return new Date((seconds * 1000) + (nanos / 1000000));
	};


	/**
	 * Sets the value of this Timestamp object to be the given Date.
	 * @param {!Date} value The value to set.
	 */
	proto.google.protobuf.Timestamp.prototype.fromDate = function(value) {
	  this.setSeconds(Math.floor(value.getTime() / 1000));
	  this.setNanos(value.getMilliseconds() * 1000000);
	};
	});

	var blockchain_pb = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.ABI', null, global);
	  goog.exportSymbol('proto.types.Block', null, global);
	  goog.exportSymbol('proto.types.BlockBody', null, global);
	  goog.exportSymbol('proto.types.BlockHeader', null, global);
	  goog.exportSymbol('proto.types.FnArgument', null, global);
	  goog.exportSymbol('proto.types.Function', null, global);
	  goog.exportSymbol('proto.types.Query', null, global);
	  goog.exportSymbol('proto.types.Receipt', null, global);
	  goog.exportSymbol('proto.types.State', null, global);
	  goog.exportSymbol('proto.types.Tx', null, global);
	  goog.exportSymbol('proto.types.TxBody', null, global);
	  goog.exportSymbol('proto.types.TxIdx', null, global);
	  goog.exportSymbol('proto.types.TxInBlock', null, global);
	  goog.exportSymbol('proto.types.TxList', null, global);
	  goog.exportSymbol('proto.types.TxType', null, global);
	  goog.exportSymbol('proto.types.Vote', null, global);
	  goog.exportSymbol('proto.types.VoteList', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Block = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Block, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Block.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Block.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Block} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Block.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        hash: msg.getHash_asB64(),
	        header: (f = msg.getHeader()) && proto.types.BlockHeader.toObject(includeInstance, f),
	        body: (f = msg.getBody()) && proto.types.BlockBody.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Block}
	   */
	  proto.types.Block.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Block();
	    return proto.types.Block.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Block} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Block}
	   */
	  proto.types.Block.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = new proto.types.BlockHeader();
	          reader.readMessage(value, proto.types.BlockHeader.deserializeBinaryFromReader);
	          msg.setHeader(value);
	          break;
	        case 3:
	          var value = new proto.types.BlockBody();
	          reader.readMessage(value, proto.types.BlockBody.deserializeBinaryFromReader);
	          msg.setBody(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Block.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Block.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Block} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Block.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getHeader();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.BlockHeader.serializeBinaryToWriter);
	    }
	    f = message.getBody();
	    if (f != null) {
	      writer.writeMessage(3, f, proto.types.BlockBody.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Block.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Block.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Block.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Block.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional BlockHeader header = 2;
	   * @return {?proto.types.BlockHeader}
	   */
	  proto.types.Block.prototype.getHeader = function () {
	    return (/** @type{?proto.types.BlockHeader} */googleProtobuf.Message.getWrapperField(this, proto.types.BlockHeader, 2)
	    );
	  };

	  /** @param {?proto.types.BlockHeader|undefined} value */
	  proto.types.Block.prototype.setHeader = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Block.prototype.clearHeader = function () {
	    this.setHeader(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Block.prototype.hasHeader = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * optional BlockBody body = 3;
	   * @return {?proto.types.BlockBody}
	   */
	  proto.types.Block.prototype.getBody = function () {
	    return (/** @type{?proto.types.BlockBody} */googleProtobuf.Message.getWrapperField(this, proto.types.BlockBody, 3)
	    );
	  };

	  /** @param {?proto.types.BlockBody|undefined} value */
	  proto.types.Block.prototype.setBody = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };

	  proto.types.Block.prototype.clearBody = function () {
	    this.setBody(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Block.prototype.hasBody = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockHeader = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.BlockHeader, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockHeader.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockHeader.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockHeader} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockHeader.toObject = function (includeInstance, msg) {
	      var obj = {
	        prevblockhash: msg.getPrevblockhash_asB64(),
	        blockno: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        timestamp: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        blocksroothash: msg.getBlocksroothash_asB64(),
	        txsroothash: msg.getTxsroothash_asB64(),
	        confirms: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
	        pubkey: msg.getPubkey_asB64(),
	        sign: msg.getSign_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockHeader}
	   */
	  proto.types.BlockHeader.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockHeader();
	    return proto.types.BlockHeader.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockHeader} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockHeader}
	   */
	  proto.types.BlockHeader.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPrevblockhash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBlockno(value);
	          break;
	        case 3:
	          var value = /** @type {number} */reader.readInt64();
	          msg.setTimestamp(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBlocksroothash(value);
	          break;
	        case 5:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setTxsroothash(value);
	          break;
	        case 6:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setConfirms(value);
	          break;
	        case 7:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPubkey(value);
	          break;
	        case 8:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setSign(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockHeader.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockHeader} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockHeader.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPrevblockhash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBlockno();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getTimestamp();
	    if (f !== 0) {
	      writer.writeInt64(3, f);
	    }
	    f = message.getBlocksroothash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	    f = message.getTxsroothash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(5, f);
	    }
	    f = message.getConfirms();
	    if (f !== 0) {
	      writer.writeUint64(6, f);
	    }
	    f = message.getPubkey_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(7, f);
	    }
	    f = message.getSign_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(8, f);
	    }
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * This is a type-conversion wrapper around `getPrevblockhash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPrevblockhash())
	    );
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPrevblockhash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPrevblockhash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setPrevblockhash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 blockNo = 2;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getBlockno = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setBlockno = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional int64 timestamp = 3;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getTimestamp = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setTimestamp = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * This is a type-conversion wrapper around `getBlocksroothash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBlocksroothash())
	    );
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBlocksroothash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBlocksroothash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setBlocksroothash = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 5, "")
	    );
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * This is a type-conversion wrapper around `getTxsroothash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getTxsroothash())
	    );
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getTxsroothash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getTxsroothash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setTxsroothash = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * optional uint64 confirms = 6;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getConfirms = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 6, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setConfirms = function (value) {
	    googleProtobuf.Message.setField(this, 6, value);
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getPubkey = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 7, "")
	    );
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * This is a type-conversion wrapper around `getPubkey()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getPubkey_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPubkey())
	    );
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPubkey()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getPubkey_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPubkey())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setPubkey = function (value) {
	    googleProtobuf.Message.setField(this, 7, value);
	  };

	  /**
	   * optional bytes sign = 8;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getSign = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };

	  /**
	   * optional bytes sign = 8;
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getSign_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getSign())
	    );
	  };

	  /**
	   * optional bytes sign = 8;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getSign_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getSign())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setSign = function (value) {
	    googleProtobuf.Message.setField(this, 8, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockBody = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.BlockBody.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.BlockBody, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.BlockBody.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockBody.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockBody.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockBody} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockBody.toObject = function (includeInstance, msg) {
	      var obj = {
	        txsList: googleProtobuf.Message.toObjectList(msg.getTxsList(), proto.types.Tx.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockBody}
	   */
	  proto.types.BlockBody.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockBody();
	    return proto.types.BlockBody.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockBody} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockBody}
	   */
	  proto.types.BlockBody.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.addTxs(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockBody.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockBody.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockBody} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockBody.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Tx txs = 1;
	   * @return {!Array.<!proto.types.Tx>}
	   */
	  proto.types.BlockBody.prototype.getTxsList = function () {
	    return (/** @type{!Array.<!proto.types.Tx>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Tx, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Tx>} value */
	  proto.types.BlockBody.prototype.setTxsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Tx=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Tx}
	   */
	  proto.types.BlockBody.prototype.addTxs = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Tx, opt_index);
	  };

	  proto.types.BlockBody.prototype.clearTxsList = function () {
	    this.setTxsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.TxList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.TxList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.TxList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxList.toObject = function (includeInstance, msg) {
	      var obj = {
	        txsList: googleProtobuf.Message.toObjectList(msg.getTxsList(), proto.types.Tx.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxList}
	   */
	  proto.types.TxList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxList();
	    return proto.types.TxList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxList}
	   */
	  proto.types.TxList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.addTxs(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Tx txs = 1;
	   * @return {!Array.<!proto.types.Tx>}
	   */
	  proto.types.TxList.prototype.getTxsList = function () {
	    return (/** @type{!Array.<!proto.types.Tx>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Tx, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Tx>} value */
	  proto.types.TxList.prototype.setTxsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Tx=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Tx}
	   */
	  proto.types.TxList.prototype.addTxs = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Tx, opt_index);
	  };

	  proto.types.TxList.prototype.clearTxsList = function () {
	    this.setTxsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Tx = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Tx, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Tx.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Tx.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Tx} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Tx.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        hash: msg.getHash_asB64(),
	        body: (f = msg.getBody()) && proto.types.TxBody.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Tx}
	   */
	  proto.types.Tx.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Tx();
	    return proto.types.Tx.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Tx} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Tx}
	   */
	  proto.types.Tx.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = new proto.types.TxBody();
	          reader.readMessage(value, proto.types.TxBody.deserializeBinaryFromReader);
	          msg.setBody(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Tx.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Tx.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Tx} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Tx.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBody();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.TxBody.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Tx.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Tx.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Tx.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Tx.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional TxBody body = 2;
	   * @return {?proto.types.TxBody}
	   */
	  proto.types.Tx.prototype.getBody = function () {
	    return (/** @type{?proto.types.TxBody} */googleProtobuf.Message.getWrapperField(this, proto.types.TxBody, 2)
	    );
	  };

	  /** @param {?proto.types.TxBody|undefined} value */
	  proto.types.Tx.prototype.setBody = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Tx.prototype.clearBody = function () {
	    this.setBody(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Tx.prototype.hasBody = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxBody = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxBody, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxBody.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxBody.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxBody} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxBody.toObject = function (includeInstance, msg) {
	      var obj = {
	        nonce: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        account: msg.getAccount_asB64(),
	        recipient: msg.getRecipient_asB64(),
	        amount: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        payload: msg.getPayload_asB64(),
	        limit: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
	        price: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 8, 0),
	        sign: msg.getSign_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxBody}
	   */
	  proto.types.TxBody.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxBody();
	    return proto.types.TxBody.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxBody} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxBody}
	   */
	  proto.types.TxBody.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setNonce(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAccount(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setRecipient(value);
	          break;
	        case 4:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setAmount(value);
	          break;
	        case 5:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPayload(value);
	          break;
	        case 6:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setLimit(value);
	          break;
	        case 7:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setPrice(value);
	          break;
	        case 8:
	          var value = /** @type {!proto.types.TxType} */reader.readEnum();
	          msg.setType(value);
	          break;
	        case 9:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setSign(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxBody.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxBody} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxBody.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getNonce();
	    if (f !== 0) {
	      writer.writeUint64(1, f);
	    }
	    f = message.getAccount_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	    f = message.getRecipient_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getAmount();
	    if (f !== 0) {
	      writer.writeUint64(4, f);
	    }
	    f = message.getPayload_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(5, f);
	    }
	    f = message.getLimit();
	    if (f !== 0) {
	      writer.writeUint64(6, f);
	    }
	    f = message.getPrice();
	    if (f !== 0) {
	      writer.writeUint64(7, f);
	    }
	    f = message.getType();
	    if (f !== 0.0) {
	      writer.writeEnum(8, f);
	    }
	    f = message.getSign_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(9, f);
	    }
	  };

	  /**
	   * optional uint64 nonce = 1;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getNonce = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setNonce = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes account = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getAccount = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes account = 2;
	   * This is a type-conversion wrapper around `getAccount()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getAccount_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAccount())
	    );
	  };

	  /**
	   * optional bytes account = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAccount()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getAccount_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAccount())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setAccount = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes recipient = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getRecipient = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes recipient = 3;
	   * This is a type-conversion wrapper around `getRecipient()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getRecipient_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getRecipient())
	    );
	  };

	  /**
	   * optional bytes recipient = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getRecipient()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getRecipient_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getRecipient())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setRecipient = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional uint64 amount = 4;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getAmount = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setAmount = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bytes payload = 5;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getPayload = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 5, "")
	    );
	  };

	  /**
	   * optional bytes payload = 5;
	   * This is a type-conversion wrapper around `getPayload()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getPayload_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPayload())
	    );
	  };

	  /**
	   * optional bytes payload = 5;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPayload()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getPayload_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPayload())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setPayload = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * optional uint64 limit = 6;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getLimit = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 6, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setLimit = function (value) {
	    googleProtobuf.Message.setField(this, 6, value);
	  };

	  /**
	   * optional uint64 price = 7;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getPrice = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setPrice = function (value) {
	    googleProtobuf.Message.setField(this, 7, value);
	  };

	  /**
	   * optional TxType type = 8;
	   * @return {!proto.types.TxType}
	   */
	  proto.types.TxBody.prototype.getType = function () {
	    return (/** @type {!proto.types.TxType} */googleProtobuf.Message.getFieldWithDefault(this, 8, 0)
	    );
	  };

	  /** @param {!proto.types.TxType} value */
	  proto.types.TxBody.prototype.setType = function (value) {
	    googleProtobuf.Message.setField(this, 8, value);
	  };

	  /**
	   * optional bytes sign = 9;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getSign = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };

	  /**
	   * optional bytes sign = 9;
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getSign_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getSign())
	    );
	  };

	  /**
	   * optional bytes sign = 9;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getSign_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getSign())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setSign = function (value) {
	    googleProtobuf.Message.setField(this, 9, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxIdx = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxIdx, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxIdx.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxIdx.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxIdx} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxIdx.toObject = function (includeInstance, msg) {
	      var obj = {
	        blockhash: msg.getBlockhash_asB64(),
	        idx: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxIdx}
	   */
	  proto.types.TxIdx.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxIdx();
	    return proto.types.TxIdx.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxIdx} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxIdx}
	   */
	  proto.types.TxIdx.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBlockhash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readInt32();
	          msg.setIdx(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxIdx.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxIdx.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxIdx} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxIdx.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBlockhash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getIdx();
	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxIdx.prototype.getBlockhash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * This is a type-conversion wrapper around `getBlockhash()`
	   * @return {string}
	   */
	  proto.types.TxIdx.prototype.getBlockhash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBlockhash())
	    );
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBlockhash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxIdx.prototype.getBlockhash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBlockhash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxIdx.prototype.setBlockhash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional int32 idx = 2;
	   * @return {number}
	   */
	  proto.types.TxIdx.prototype.getIdx = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxIdx.prototype.setIdx = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxInBlock = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxInBlock, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxInBlock.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxInBlock.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxInBlock} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxInBlock.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        txidx: (f = msg.getTxidx()) && proto.types.TxIdx.toObject(includeInstance, f),
	        tx: (f = msg.getTx()) && proto.types.Tx.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxInBlock}
	   */
	  proto.types.TxInBlock.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxInBlock();
	    return proto.types.TxInBlock.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxInBlock} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxInBlock}
	   */
	  proto.types.TxInBlock.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.TxIdx();
	          reader.readMessage(value, proto.types.TxIdx.deserializeBinaryFromReader);
	          msg.setTxidx(value);
	          break;
	        case 2:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.setTx(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxInBlock.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxInBlock.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxInBlock} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxInBlock.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxidx();
	    if (f != null) {
	      writer.writeMessage(1, f, proto.types.TxIdx.serializeBinaryToWriter);
	    }
	    f = message.getTx();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional TxIdx txIdx = 1;
	   * @return {?proto.types.TxIdx}
	   */
	  proto.types.TxInBlock.prototype.getTxidx = function () {
	    return (/** @type{?proto.types.TxIdx} */googleProtobuf.Message.getWrapperField(this, proto.types.TxIdx, 1)
	    );
	  };

	  /** @param {?proto.types.TxIdx|undefined} value */
	  proto.types.TxInBlock.prototype.setTxidx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 1, value);
	  };

	  proto.types.TxInBlock.prototype.clearTxidx = function () {
	    this.setTxidx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.TxInBlock.prototype.hasTxidx = function () {
	    return googleProtobuf.Message.getField(this, 1) != null;
	  };

	  /**
	   * optional Tx tx = 2;
	   * @return {?proto.types.Tx}
	   */
	  proto.types.TxInBlock.prototype.getTx = function () {
	    return (/** @type{?proto.types.Tx} */googleProtobuf.Message.getWrapperField(this, proto.types.Tx, 2)
	    );
	  };

	  /** @param {?proto.types.Tx|undefined} value */
	  proto.types.TxInBlock.prototype.setTx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.TxInBlock.prototype.clearTx = function () {
	    this.setTx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.TxInBlock.prototype.hasTx = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.State = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.State, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.State.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.State.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.State} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.State.toObject = function (includeInstance, msg) {
	      var obj = {
	        nonce: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        balance: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        codehash: msg.getCodehash_asB64(),
	        storageroot: msg.getStorageroot_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.State}
	   */
	  proto.types.State.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.State();
	    return proto.types.State.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.State} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.State}
	   */
	  proto.types.State.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setNonce(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBalance(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setCodehash(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setStorageroot(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.State.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.State} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.State.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getNonce();
	    if (f !== 0) {
	      writer.writeUint64(1, f);
	    }
	    f = message.getBalance();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getCodehash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getStorageroot_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional uint64 nonce = 1;
	   * @return {number}
	   */
	  proto.types.State.prototype.getNonce = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.State.prototype.setNonce = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 balance = 2;
	   * @return {number}
	   */
	  proto.types.State.prototype.getBalance = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.State.prototype.setBalance = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.State.prototype.getCodehash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * This is a type-conversion wrapper around `getCodehash()`
	   * @return {string}
	   */
	  proto.types.State.prototype.getCodehash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getCodehash())
	    );
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getCodehash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.getCodehash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getCodehash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.State.prototype.setCodehash = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.State.prototype.getStorageroot = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * This is a type-conversion wrapper around `getStorageroot()`
	   * @return {string}
	   */
	  proto.types.State.prototype.getStorageroot_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getStorageroot())
	    );
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getStorageroot()`
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.getStorageroot_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getStorageroot())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.State.prototype.setStorageroot = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Receipt = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Receipt, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Receipt.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Receipt.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Receipt} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Receipt.toObject = function (includeInstance, msg) {
	      var obj = {
	        contractaddress: msg.getContractaddress_asB64(),
	        status: googleProtobuf.Message.getFieldWithDefault(msg, 2, ""),
	        ret: googleProtobuf.Message.getFieldWithDefault(msg, 3, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Receipt}
	   */
	  proto.types.Receipt.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Receipt();
	    return proto.types.Receipt.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Receipt} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Receipt}
	   */
	  proto.types.Receipt.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setContractaddress(value);
	          break;
	        case 2:
	          var value = /** @type {string} */reader.readString();
	          msg.setStatus(value);
	          break;
	        case 3:
	          var value = /** @type {string} */reader.readString();
	          msg.setRet(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Receipt.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Receipt.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Receipt} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Receipt.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getContractaddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getStatus();
	    if (f.length > 0) {
	      writer.writeString(2, f);
	    }
	    f = message.getRet();
	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Receipt.prototype.getContractaddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getContractaddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getContractaddress())
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Receipt.prototype.getContractaddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getContractaddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Receipt.prototype.setContractaddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional string status = 2;
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getStatus = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Receipt.prototype.setStatus = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional string ret = 3;
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getRet = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Receipt.prototype.setRet = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Vote = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Vote, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Vote.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Vote.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Vote} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Vote.toObject = function (includeInstance, msg) {
	      var obj = {
	        candidate: msg.getCandidate_asB64(),
	        amount: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Vote}
	   */
	  proto.types.Vote.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Vote();
	    return proto.types.Vote.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Vote} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Vote}
	   */
	  proto.types.Vote.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setCandidate(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setAmount(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Vote.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Vote.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Vote} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Vote.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getCandidate_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getAmount();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	  };

	  /**
	   * optional bytes candidate = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Vote.prototype.getCandidate = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes candidate = 1;
	   * This is a type-conversion wrapper around `getCandidate()`
	   * @return {string}
	   */
	  proto.types.Vote.prototype.getCandidate_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getCandidate())
	    );
	  };

	  /**
	   * optional bytes candidate = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getCandidate()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Vote.prototype.getCandidate_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getCandidate())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Vote.prototype.setCandidate = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 amount = 2;
	   * @return {number}
	   */
	  proto.types.Vote.prototype.getAmount = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.Vote.prototype.setAmount = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.VoteList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.VoteList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.VoteList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.VoteList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.VoteList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.VoteList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.VoteList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.VoteList.toObject = function (includeInstance, msg) {
	      var obj = {
	        votesList: googleProtobuf.Message.toObjectList(msg.getVotesList(), proto.types.Vote.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.VoteList}
	   */
	  proto.types.VoteList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.VoteList();
	    return proto.types.VoteList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.VoteList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.VoteList}
	   */
	  proto.types.VoteList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Vote();
	          reader.readMessage(value, proto.types.Vote.deserializeBinaryFromReader);
	          msg.addVotes(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.VoteList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.VoteList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.VoteList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.VoteList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getVotesList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Vote.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Vote votes = 1;
	   * @return {!Array.<!proto.types.Vote>}
	   */
	  proto.types.VoteList.prototype.getVotesList = function () {
	    return (/** @type{!Array.<!proto.types.Vote>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Vote, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Vote>} value */
	  proto.types.VoteList.prototype.setVotesList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Vote=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Vote}
	   */
	  proto.types.VoteList.prototype.addVotes = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Vote, opt_index);
	  };

	  proto.types.VoteList.prototype.clearVotesList = function () {
	    this.setVotesList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.FnArgument = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.FnArgument, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.FnArgument.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.FnArgument.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.FnArgument} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.FnArgument.toObject = function (includeInstance, msg) {
	      var obj = {
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 1, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.FnArgument.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.FnArgument();
	    return proto.types.FnArgument.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.FnArgument} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.FnArgument.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setName(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.FnArgument.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.FnArgument.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.FnArgument} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.FnArgument.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getName();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	  };

	  /**
	   * optional string name = 1;
	   * @return {string}
	   */
	  proto.types.FnArgument.prototype.getName = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.FnArgument.prototype.setName = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Function = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.Function.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.Function, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.Function.repeatedFields_ = [2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Function.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Function.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Function} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Function.toObject = function (includeInstance, msg) {
	      var obj = {
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        argumentsList: googleProtobuf.Message.toObjectList(msg.getArgumentsList(), proto.types.FnArgument.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Function}
	   */
	  proto.types.Function.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Function();
	    return proto.types.Function.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Function} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Function}
	   */
	  proto.types.Function.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setName(value);
	          break;
	        case 2:
	          var value = new proto.types.FnArgument();
	          reader.readMessage(value, proto.types.FnArgument.deserializeBinaryFromReader);
	          msg.addArguments(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Function.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Function.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Function} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Function.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getName();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getArgumentsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(2, f, proto.types.FnArgument.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string name = 1;
	   * @return {string}
	   */
	  proto.types.Function.prototype.getName = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Function.prototype.setName = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * repeated FnArgument arguments = 2;
	   * @return {!Array.<!proto.types.FnArgument>}
	   */
	  proto.types.Function.prototype.getArgumentsList = function () {
	    return (/** @type{!Array.<!proto.types.FnArgument>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.FnArgument, 2)
	    );
	  };

	  /** @param {!Array.<!proto.types.FnArgument>} value */
	  proto.types.Function.prototype.setArgumentsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
	  };

	  /**
	   * @param {!proto.types.FnArgument=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.Function.prototype.addArguments = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.types.FnArgument, opt_index);
	  };

	  proto.types.Function.prototype.clearArgumentsList = function () {
	    this.setArgumentsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.ABI = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.ABI.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.ABI, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.ABI.repeatedFields_ = [3];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.ABI.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.ABI.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.ABI} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.ABI.toObject = function (includeInstance, msg) {
	      var obj = {
	        version: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        language: googleProtobuf.Message.getFieldWithDefault(msg, 2, ""),
	        functionsList: googleProtobuf.Message.toObjectList(msg.getFunctionsList(), proto.types.Function.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.ABI}
	   */
	  proto.types.ABI.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.ABI();
	    return proto.types.ABI.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.ABI} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.ABI}
	   */
	  proto.types.ABI.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setVersion(value);
	          break;
	        case 2:
	          var value = /** @type {string} */reader.readString();
	          msg.setLanguage(value);
	          break;
	        case 3:
	          var value = new proto.types.Function();
	          reader.readMessage(value, proto.types.Function.deserializeBinaryFromReader);
	          msg.addFunctions(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.ABI.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.ABI.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.ABI} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.ABI.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getVersion();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getLanguage();
	    if (f.length > 0) {
	      writer.writeString(2, f);
	    }
	    f = message.getFunctionsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(3, f, proto.types.Function.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string version = 1;
	   * @return {string}
	   */
	  proto.types.ABI.prototype.getVersion = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.ABI.prototype.setVersion = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional string language = 2;
	   * @return {string}
	   */
	  proto.types.ABI.prototype.getLanguage = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.ABI.prototype.setLanguage = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * repeated Function functions = 3;
	   * @return {!Array.<!proto.types.Function>}
	   */
	  proto.types.ABI.prototype.getFunctionsList = function () {
	    return (/** @type{!Array.<!proto.types.Function>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Function, 3)
	    );
	  };

	  /** @param {!Array.<!proto.types.Function>} value */
	  proto.types.ABI.prototype.setFunctionsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 3, value);
	  };

	  /**
	   * @param {!proto.types.Function=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Function}
	   */
	  proto.types.ABI.prototype.addFunctions = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.types.Function, opt_index);
	  };

	  proto.types.ABI.prototype.clearFunctionsList = function () {
	    this.setFunctionsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Query = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Query, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Query.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Query.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Query} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Query.toObject = function (includeInstance, msg) {
	      var obj = {
	        contractaddress: msg.getContractaddress_asB64(),
	        queryinfo: msg.getQueryinfo_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Query}
	   */
	  proto.types.Query.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Query();
	    return proto.types.Query.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Query} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Query}
	   */
	  proto.types.Query.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setContractaddress(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setQueryinfo(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Query.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Query} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Query.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getContractaddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getQueryinfo_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Query.prototype.getContractaddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {string}
	   */
	  proto.types.Query.prototype.getContractaddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getContractaddress())
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.getContractaddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getContractaddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Query.prototype.setContractaddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Query.prototype.getQueryinfo = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * This is a type-conversion wrapper around `getQueryinfo()`
	   * @return {string}
	   */
	  proto.types.Query.prototype.getQueryinfo_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getQueryinfo())
	    );
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getQueryinfo()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.getQueryinfo_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getQueryinfo())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Query.prototype.setQueryinfo = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.TxType = {
	    NORMAL: 0,
	    GOVERNANCE: 1
	  };

	  goog.object.extend(exports, proto.types);
	});

	var account_pb = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.Account', null, global);
	  goog.exportSymbol('proto.types.AccountList', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Account = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Account, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Account.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Account.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Account} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Account.toObject = function (includeInstance, msg) {
	      var obj = {
	        address: msg.getAddress_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Account}
	   */
	  proto.types.Account.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Account();
	    return proto.types.Account.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Account} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Account}
	   */
	  proto.types.Account.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Account.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Account.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Account} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Account.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	  };

	  /**
	   * optional bytes address = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Account.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.Account.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Account.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Account.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.AccountList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.AccountList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.AccountList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.AccountList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.AccountList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.AccountList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.AccountList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.AccountList.toObject = function (includeInstance, msg) {
	      var obj = {
	        accountsList: googleProtobuf.Message.toObjectList(msg.getAccountsList(), proto.types.Account.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.AccountList}
	   */
	  proto.types.AccountList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.AccountList();
	    return proto.types.AccountList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.AccountList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.AccountList}
	   */
	  proto.types.AccountList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Account();
	          reader.readMessage(value, proto.types.Account.deserializeBinaryFromReader);
	          msg.addAccounts(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.AccountList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.AccountList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.AccountList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.AccountList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAccountsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Account.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Account accounts = 1;
	   * @return {!Array.<!proto.types.Account>}
	   */
	  proto.types.AccountList.prototype.getAccountsList = function () {
	    return (/** @type{!Array.<!proto.types.Account>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Account, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Account>} value */
	  proto.types.AccountList.prototype.setAccountsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Account=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Account}
	   */
	  proto.types.AccountList.prototype.addAccounts = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Account, opt_index);
	  };

	  proto.types.AccountList.prototype.clearAccountsList = function () {
	    this.setAccountsList([]);
	  };

	  goog.object.extend(exports, proto.types);
	});

	var node_pb = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.PeerAddress', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.PeerAddress = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.PeerAddress, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.PeerAddress.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.PeerAddress.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.PeerAddress} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.PeerAddress.toObject = function (includeInstance, msg) {
	      var obj = {
	        address: msg.getAddress_asB64(),
	        port: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        peerid: msg.getPeerid_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerAddress.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.PeerAddress();
	    return proto.types.PeerAddress.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.PeerAddress} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerAddress.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setPort(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPeerid(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.PeerAddress.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.PeerAddress} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.PeerAddress.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getPort();
	    if (f !== 0) {
	      writer.writeUint32(2, f);
	    }
	    f = message.getPeerid_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	  };

	  /**
	   * optional bytes address = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.PeerAddress.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.PeerAddress.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.PeerAddress.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint32 port = 2;
	   * @return {number}
	   */
	  proto.types.PeerAddress.prototype.getPort = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.PeerAddress.prototype.setPort = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes peerID = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.PeerAddress.prototype.getPeerid = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes peerID = 3;
	   * This is a type-conversion wrapper around `getPeerid()`
	   * @return {string}
	   */
	  proto.types.PeerAddress.prototype.getPeerid_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPeerid())
	    );
	  };

	  /**
	   * optional bytes peerID = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPeerid()`
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.getPeerid_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPeerid())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.PeerAddress.prototype.setPeerid = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  goog.object.extend(exports, proto.types);
	});

	var rpc_pb = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.BlockHeaderList', null, global);
	  goog.exportSymbol('proto.types.BlockchainStatus', null, global);
	  goog.exportSymbol('proto.types.CommitResult', null, global);
	  goog.exportSymbol('proto.types.CommitResultList', null, global);
	  goog.exportSymbol('proto.types.CommitStatus', null, global);
	  goog.exportSymbol('proto.types.Empty', null, global);
	  goog.exportSymbol('proto.types.Input', null, global);
	  goog.exportSymbol('proto.types.ListParams', null, global);
	  goog.exportSymbol('proto.types.Output', null, global);
	  goog.exportSymbol('proto.types.PeerList', null, global);
	  goog.exportSymbol('proto.types.Personal', null, global);
	  goog.exportSymbol('proto.types.SingleBytes', null, global);
	  goog.exportSymbol('proto.types.VerifyResult', null, global);
	  goog.exportSymbol('proto.types.VerifyStatus', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockchainStatus = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.BlockchainStatus, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockchainStatus.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockchainStatus.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockchainStatus} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockchainStatus.toObject = function (includeInstance, msg) {
	      var obj = {
	        bestBlockHash: msg.getBestBlockHash_asB64(),
	        bestHeight: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockchainStatus}
	   */
	  proto.types.BlockchainStatus.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockchainStatus();
	    return proto.types.BlockchainStatus.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockchainStatus} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockchainStatus}
	   */
	  proto.types.BlockchainStatus.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBestBlockHash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBestHeight(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockchainStatus.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockchainStatus.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockchainStatus} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockchainStatus.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBestBlockHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBestHeight();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * This is a type-conversion wrapper around `getBestBlockHash()`
	   * @return {string}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBestBlockHash())
	    );
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBestBlockHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBestBlockHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockchainStatus.prototype.setBestBlockHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 best_height = 2;
	   * @return {number}
	   */
	  proto.types.BlockchainStatus.prototype.getBestHeight = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockchainStatus.prototype.setBestHeight = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Input = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.Input.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.Input, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.Input.repeatedFields_ = [2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Input.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Input.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Input} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Input.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        addressList: msg.getAddressList_asB64(),
	        value: msg.getValue_asB64(),
	        script: msg.getScript_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Input}
	   */
	  proto.types.Input.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Input();
	    return proto.types.Input.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Input} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Input}
	   */
	  proto.types.Input.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.addAddress(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setScript(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Input.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Input} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Input.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getAddressList_asU8();
	    if (f.length > 0) {
	      writer.writeRepeatedBytes(2, f);
	    }
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getScript_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * repeated bytes address = 2;
	   * @return {!(Array<!Uint8Array>|Array<string>)}
	   */
	  proto.types.Input.prototype.getAddressList = function () {
	    return (/** @type {!(Array<!Uint8Array>|Array<string>)} */googleProtobuf.Message.getRepeatedField(this, 2)
	    );
	  };

	  /**
	   * repeated bytes address = 2;
	   * This is a type-conversion wrapper around `getAddressList()`
	   * @return {!Array.<string>}
	   */
	  proto.types.Input.prototype.getAddressList_asB64 = function () {
	    return (/** @type {!Array.<string>} */googleProtobuf.Message.bytesListAsB64(this.getAddressList())
	    );
	  };

	  /**
	   * repeated bytes address = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddressList()`
	   * @return {!Array.<!Uint8Array>}
	   */
	  proto.types.Input.prototype.getAddressList_asU8 = function () {
	    return (/** @type {!Array.<!Uint8Array>} */googleProtobuf.Message.bytesListAsU8(this.getAddressList())
	    );
	  };

	  /** @param {!(Array<!Uint8Array>|Array<string>)} value */
	  proto.types.Input.prototype.setAddressList = function (value) {
	    googleProtobuf.Message.setField(this, 2, value || []);
	  };

	  /**
	   * @param {!(string|Uint8Array)} value
	   * @param {number=} opt_index
	   */
	  proto.types.Input.prototype.addAddress = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
	  };

	  proto.types.Input.prototype.clearAddressList = function () {
	    this.setAddressList([]);
	  };

	  /**
	   * optional bytes value = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes script = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getScript = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getScript_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getScript())
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getScript_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getScript())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setScript = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Output = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Output, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Output.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Output.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Output} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Output.toObject = function (includeInstance, msg) {
	      var obj = {
	        index: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        address: msg.getAddress_asB64(),
	        value: msg.getValue_asB64(),
	        script: msg.getScript_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Output}
	   */
	  proto.types.Output.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Output();
	    return proto.types.Output.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Output} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Output}
	   */
	  proto.types.Output.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setIndex(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setScript(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Output.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Output} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Output.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getIndex();
	    if (f !== 0) {
	      writer.writeUint32(1, f);
	    }
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getScript_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional uint32 index = 1;
	   * @return {number}
	   */
	  proto.types.Output.prototype.getIndex = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.Output.prototype.setIndex = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes address = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes address = 2;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes value = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes script = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getScript = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getScript_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getScript())
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getScript_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getScript())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setScript = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Empty = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Empty, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Empty.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Empty.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Empty} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Empty.toObject = function (includeInstance, msg) {
	      var obj = {};

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Empty}
	   */
	  proto.types.Empty.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Empty();
	    return proto.types.Empty.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Empty} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Empty}
	   */
	  proto.types.Empty.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Empty.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Empty.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Empty} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Empty.serializeBinaryToWriter = function (message, writer) {
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.SingleBytes = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.SingleBytes, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.SingleBytes.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.SingleBytes.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.SingleBytes} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.SingleBytes.toObject = function (includeInstance, msg) {
	      var obj = {
	        value: msg.getValue_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.SingleBytes}
	   */
	  proto.types.SingleBytes.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.SingleBytes();
	    return proto.types.SingleBytes.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.SingleBytes} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.SingleBytes}
	   */
	  proto.types.SingleBytes.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.SingleBytes.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.SingleBytes.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.SingleBytes} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.SingleBytes.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	  };

	  /**
	   * optional bytes value = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.SingleBytes.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes value = 1;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.SingleBytes.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.SingleBytes.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.SingleBytes.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Personal = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Personal, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Personal.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Personal.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Personal} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Personal.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        passphrase: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        account: (f = msg.getAccount()) && account_pb.Account.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Personal}
	   */
	  proto.types.Personal.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Personal();
	    return proto.types.Personal.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Personal} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Personal}
	   */
	  proto.types.Personal.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setPassphrase(value);
	          break;
	        case 2:
	          var value = new account_pb.Account();
	          reader.readMessage(value, account_pb.Account.deserializeBinaryFromReader);
	          msg.setAccount(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Personal.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Personal.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Personal} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Personal.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPassphrase();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getAccount();
	    if (f != null) {
	      writer.writeMessage(2, f, account_pb.Account.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string passphrase = 1;
	   * @return {string}
	   */
	  proto.types.Personal.prototype.getPassphrase = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Personal.prototype.setPassphrase = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional Account account = 2;
	   * @return {?proto.types.Account}
	   */
	  proto.types.Personal.prototype.getAccount = function () {
	    return (/** @type{?proto.types.Account} */googleProtobuf.Message.getWrapperField(this, account_pb.Account, 2)
	    );
	  };

	  /** @param {?proto.types.Account|undefined} value */
	  proto.types.Personal.prototype.setAccount = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Personal.prototype.clearAccount = function () {
	    this.setAccount(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Personal.prototype.hasAccount = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.PeerList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.PeerList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.PeerList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.PeerList.repeatedFields_ = [1, 2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.PeerList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.PeerList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.PeerList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.PeerList.toObject = function (includeInstance, msg) {
	      var obj = {
	        peersList: googleProtobuf.Message.toObjectList(msg.getPeersList(), node_pb.PeerAddress.toObject, includeInstance),
	        statesList: googleProtobuf.Message.getRepeatedField(msg, 2)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.PeerList}
	   */
	  proto.types.PeerList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.PeerList();
	    return proto.types.PeerList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.PeerList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.PeerList}
	   */
	  proto.types.PeerList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new node_pb.PeerAddress();
	          reader.readMessage(value, node_pb.PeerAddress.deserializeBinaryFromReader);
	          msg.addPeers(value);
	          break;
	        case 2:
	          var value = /** @type {!Array.<number>} */reader.readPackedInt32();
	          msg.setStatesList(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.PeerList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.PeerList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.PeerList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPeersList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, node_pb.PeerAddress.serializeBinaryToWriter);
	    }
	    f = message.getStatesList();
	    if (f.length > 0) {
	      writer.writePackedInt32(2, f);
	    }
	  };

	  /**
	   * repeated PeerAddress peers = 1;
	   * @return {!Array.<!proto.types.PeerAddress>}
	   */
	  proto.types.PeerList.prototype.getPeersList = function () {
	    return (/** @type{!Array.<!proto.types.PeerAddress>} */googleProtobuf.Message.getRepeatedWrapperField(this, node_pb.PeerAddress, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.PeerAddress>} value */
	  proto.types.PeerList.prototype.setPeersList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.PeerAddress=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerList.prototype.addPeers = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.PeerAddress, opt_index);
	  };

	  proto.types.PeerList.prototype.clearPeersList = function () {
	    this.setPeersList([]);
	  };

	  /**
	   * repeated int32 states = 2;
	   * @return {!Array.<number>}
	   */
	  proto.types.PeerList.prototype.getStatesList = function () {
	    return (/** @type {!Array.<number>} */googleProtobuf.Message.getRepeatedField(this, 2)
	    );
	  };

	  /** @param {!Array.<number>} value */
	  proto.types.PeerList.prototype.setStatesList = function (value) {
	    googleProtobuf.Message.setField(this, 2, value || []);
	  };

	  /**
	   * @param {!number} value
	   * @param {number=} opt_index
	   */
	  proto.types.PeerList.prototype.addStates = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
	  };

	  proto.types.PeerList.prototype.clearStatesList = function () {
	    this.setStatesList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.ListParams = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.ListParams, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.ListParams.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.ListParams.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.ListParams} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.ListParams.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        height: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        size: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        offset: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        asc: googleProtobuf.Message.getFieldWithDefault(msg, 5, false)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.ListParams}
	   */
	  proto.types.ListParams.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.ListParams();
	    return proto.types.ListParams.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.ListParams} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.ListParams}
	   */
	  proto.types.ListParams.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setHeight(value);
	          break;
	        case 3:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setSize(value);
	          break;
	        case 4:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setOffset(value);
	          break;
	        case 5:
	          var value = /** @type {boolean} */reader.readBool();
	          msg.setAsc(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.ListParams.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.ListParams.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.ListParams} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.ListParams.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getHeight();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getSize();
	    if (f !== 0) {
	      writer.writeUint32(3, f);
	    }
	    f = message.getOffset();
	    if (f !== 0) {
	      writer.writeUint32(4, f);
	    }
	    f = message.getAsc();
	    if (f) {
	      writer.writeBool(5, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.ListParams.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.ListParams.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.ListParams.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.ListParams.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 height = 2;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getHeight = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setHeight = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional uint32 size = 3;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getSize = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setSize = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional uint32 offset = 4;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getOffset = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setOffset = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bool asc = 5;
	   * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
	   * You should avoid comparisons like {@code val === true/false} in those cases.
	   * @return {boolean}
	   */
	  proto.types.ListParams.prototype.getAsc = function () {
	    return (/** @type {boolean} */googleProtobuf.Message.getFieldWithDefault(this, 5, false)
	    );
	  };

	  /** @param {boolean} value */
	  proto.types.ListParams.prototype.setAsc = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockHeaderList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.BlockHeaderList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.BlockHeaderList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.BlockHeaderList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockHeaderList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockHeaderList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockHeaderList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockHeaderList.toObject = function (includeInstance, msg) {
	      var obj = {
	        blocksList: googleProtobuf.Message.toObjectList(msg.getBlocksList(), blockchain_pb.Block.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockHeaderList}
	   */
	  proto.types.BlockHeaderList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockHeaderList();
	    return proto.types.BlockHeaderList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockHeaderList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockHeaderList}
	   */
	  proto.types.BlockHeaderList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new blockchain_pb.Block();
	          reader.readMessage(value, blockchain_pb.Block.deserializeBinaryFromReader);
	          msg.addBlocks(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeaderList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockHeaderList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockHeaderList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockHeaderList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBlocksList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, blockchain_pb.Block.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Block blocks = 1;
	   * @return {!Array.<!proto.types.Block>}
	   */
	  proto.types.BlockHeaderList.prototype.getBlocksList = function () {
	    return (/** @type{!Array.<!proto.types.Block>} */googleProtobuf.Message.getRepeatedWrapperField(this, blockchain_pb.Block, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Block>} value */
	  proto.types.BlockHeaderList.prototype.setBlocksList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Block=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Block}
	   */
	  proto.types.BlockHeaderList.prototype.addBlocks = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Block, opt_index);
	  };

	  proto.types.BlockHeaderList.prototype.clearBlocksList = function () {
	    this.setBlocksList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.CommitResult = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.CommitResult, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.CommitResult.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.CommitResult.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.CommitResult} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.CommitResult.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResult.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.CommitResult();
	    return proto.types.CommitResult.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.CommitResult} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResult.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {!proto.types.CommitStatus} */reader.readEnum();
	          msg.setError(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResult.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.CommitResult.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.CommitResult} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.CommitResult.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getError();
	    if (f !== 0.0) {
	      writer.writeEnum(2, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.CommitResult.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.CommitResult.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResult.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.CommitResult.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional CommitStatus error = 2;
	   * @return {!proto.types.CommitStatus}
	   */
	  proto.types.CommitResult.prototype.getError = function () {
	    return (/** @type {!proto.types.CommitStatus} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {!proto.types.CommitStatus} value */
	  proto.types.CommitResult.prototype.setError = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.CommitResultList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.CommitResultList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.CommitResultList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.CommitResultList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.CommitResultList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.CommitResultList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.CommitResultList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.CommitResultList.toObject = function (includeInstance, msg) {
	      var obj = {
	        resultsList: googleProtobuf.Message.toObjectList(msg.getResultsList(), proto.types.CommitResult.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.CommitResultList}
	   */
	  proto.types.CommitResultList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.CommitResultList();
	    return proto.types.CommitResultList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.CommitResultList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.CommitResultList}
	   */
	  proto.types.CommitResultList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.CommitResult();
	          reader.readMessage(value, proto.types.CommitResult.deserializeBinaryFromReader);
	          msg.addResults(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResultList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.CommitResultList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.CommitResultList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.CommitResultList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getResultsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.CommitResult.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated CommitResult results = 1;
	   * @return {!Array.<!proto.types.CommitResult>}
	   */
	  proto.types.CommitResultList.prototype.getResultsList = function () {
	    return (/** @type{!Array.<!proto.types.CommitResult>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.CommitResult, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.CommitResult>} value */
	  proto.types.CommitResultList.prototype.setResultsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.CommitResult=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResultList.prototype.addResults = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.CommitResult, opt_index);
	  };

	  proto.types.CommitResultList.prototype.clearResultsList = function () {
	    this.setResultsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.VerifyResult = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.VerifyResult, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.VerifyResult.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.VerifyResult.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.VerifyResult} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.VerifyResult.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        tx: (f = msg.getTx()) && blockchain_pb.Tx.toObject(includeInstance, f),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.VerifyResult}
	   */
	  proto.types.VerifyResult.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.VerifyResult();
	    return proto.types.VerifyResult.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.VerifyResult} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.VerifyResult}
	   */
	  proto.types.VerifyResult.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new blockchain_pb.Tx();
	          reader.readMessage(value, blockchain_pb.Tx.deserializeBinaryFromReader);
	          msg.setTx(value);
	          break;
	        case 2:
	          var value = /** @type {!proto.types.VerifyStatus} */reader.readEnum();
	          msg.setError(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.VerifyResult.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.VerifyResult.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.VerifyResult} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.VerifyResult.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTx();
	    if (f != null) {
	      writer.writeMessage(1, f, blockchain_pb.Tx.serializeBinaryToWriter);
	    }
	    f = message.getError();
	    if (f !== 0.0) {
	      writer.writeEnum(2, f);
	    }
	  };

	  /**
	   * optional Tx tx = 1;
	   * @return {?proto.types.Tx}
	   */
	  proto.types.VerifyResult.prototype.getTx = function () {
	    return (/** @type{?proto.types.Tx} */googleProtobuf.Message.getWrapperField(this, blockchain_pb.Tx, 1)
	    );
	  };

	  /** @param {?proto.types.Tx|undefined} value */
	  proto.types.VerifyResult.prototype.setTx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 1, value);
	  };

	  proto.types.VerifyResult.prototype.clearTx = function () {
	    this.setTx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.VerifyResult.prototype.hasTx = function () {
	    return googleProtobuf.Message.getField(this, 1) != null;
	  };

	  /**
	   * optional VerifyStatus error = 2;
	   * @return {!proto.types.VerifyStatus}
	   */
	  proto.types.VerifyResult.prototype.getError = function () {
	    return (/** @type {!proto.types.VerifyStatus} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {!proto.types.VerifyStatus} value */
	  proto.types.VerifyResult.prototype.setError = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.CommitStatus = {
	    COMMIT_STATUS_OK: 0,
	    COMMIT_STATUS_NONCE_TOO_LOW: 1,
	    COMMIT_STATUS_INVALID_ARGUMENT: 2,
	    COMMIT_STATUS_TX_ALREADY_EXISTS: 3,
	    COMMIT_STATUS_TX_INTERNAL_ERROR: 4
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.VerifyStatus = {
	    VERIFY_STATUS_OK: 0,
	    VERIFY_STATUS_SIGN_NOT_MATCH: 1,
	    VERIFY_STATUS_INVALID_HASH: 2
	  };

	  goog.object.extend(exports, proto.types);
	});
	var rpc_pb_1 = rpc_pb.Empty;
	var rpc_pb_2 = rpc_pb.Personal;
	var rpc_pb_3 = rpc_pb.Account;
	var rpc_pb_4 = rpc_pb.SingleBytes;
	var rpc_pb_5 = rpc_pb.TxList;
	var rpc_pb_6 = rpc_pb.TxBody;
	var rpc_pb_7 = rpc_pb.Tx;
	var rpc_pb_8 = rpc_pb.CommitStatus;

	var typesNode = /*#__PURE__*/Object.freeze({
		default: rpc_pb,
		__moduleExports: rpc_pb,
		Empty: rpc_pb_1,
		Personal: rpc_pb_2,
		Account: rpc_pb_3,
		SingleBytes: rpc_pb_4,
		TxList: rpc_pb_5,
		TxBody: rpc_pb_6,
		Tx: rpc_pb_7,
		CommitStatus: rpc_pb_8
	});

	var blockchain_pb$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.ABI', null, global);
	  goog.exportSymbol('proto.types.Block', null, global);
	  goog.exportSymbol('proto.types.BlockBody', null, global);
	  goog.exportSymbol('proto.types.BlockHeader', null, global);
	  goog.exportSymbol('proto.types.FnArgument', null, global);
	  goog.exportSymbol('proto.types.Function', null, global);
	  goog.exportSymbol('proto.types.Query', null, global);
	  goog.exportSymbol('proto.types.Receipt', null, global);
	  goog.exportSymbol('proto.types.State', null, global);
	  goog.exportSymbol('proto.types.Tx', null, global);
	  goog.exportSymbol('proto.types.TxBody', null, global);
	  goog.exportSymbol('proto.types.TxIdx', null, global);
	  goog.exportSymbol('proto.types.TxInBlock', null, global);
	  goog.exportSymbol('proto.types.TxList', null, global);
	  goog.exportSymbol('proto.types.TxType', null, global);
	  goog.exportSymbol('proto.types.Vote', null, global);
	  goog.exportSymbol('proto.types.VoteList', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Block = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Block, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Block.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Block.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Block} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Block.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        hash: msg.getHash_asB64(),
	        header: (f = msg.getHeader()) && proto.types.BlockHeader.toObject(includeInstance, f),
	        body: (f = msg.getBody()) && proto.types.BlockBody.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Block}
	   */
	  proto.types.Block.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Block();
	    return proto.types.Block.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Block} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Block}
	   */
	  proto.types.Block.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = new proto.types.BlockHeader();
	          reader.readMessage(value, proto.types.BlockHeader.deserializeBinaryFromReader);
	          msg.setHeader(value);
	          break;
	        case 3:
	          var value = new proto.types.BlockBody();
	          reader.readMessage(value, proto.types.BlockBody.deserializeBinaryFromReader);
	          msg.setBody(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Block.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Block.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Block} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Block.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getHeader();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.BlockHeader.serializeBinaryToWriter);
	    }
	    f = message.getBody();
	    if (f != null) {
	      writer.writeMessage(3, f, proto.types.BlockBody.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Block.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Block.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Block.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Block.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional BlockHeader header = 2;
	   * @return {?proto.types.BlockHeader}
	   */
	  proto.types.Block.prototype.getHeader = function () {
	    return (/** @type{?proto.types.BlockHeader} */googleProtobuf.Message.getWrapperField(this, proto.types.BlockHeader, 2)
	    );
	  };

	  /** @param {?proto.types.BlockHeader|undefined} value */
	  proto.types.Block.prototype.setHeader = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Block.prototype.clearHeader = function () {
	    this.setHeader(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Block.prototype.hasHeader = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * optional BlockBody body = 3;
	   * @return {?proto.types.BlockBody}
	   */
	  proto.types.Block.prototype.getBody = function () {
	    return (/** @type{?proto.types.BlockBody} */googleProtobuf.Message.getWrapperField(this, proto.types.BlockBody, 3)
	    );
	  };

	  /** @param {?proto.types.BlockBody|undefined} value */
	  proto.types.Block.prototype.setBody = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };

	  proto.types.Block.prototype.clearBody = function () {
	    this.setBody(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Block.prototype.hasBody = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockHeader = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.BlockHeader, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockHeader.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockHeader.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockHeader} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockHeader.toObject = function (includeInstance, msg) {
	      var obj = {
	        prevblockhash: msg.getPrevblockhash_asB64(),
	        blockno: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        timestamp: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        blocksroothash: msg.getBlocksroothash_asB64(),
	        txsroothash: msg.getTxsroothash_asB64(),
	        confirms: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
	        pubkey: msg.getPubkey_asB64(),
	        sign: msg.getSign_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockHeader}
	   */
	  proto.types.BlockHeader.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockHeader();
	    return proto.types.BlockHeader.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockHeader} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockHeader}
	   */
	  proto.types.BlockHeader.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPrevblockhash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBlockno(value);
	          break;
	        case 3:
	          var value = /** @type {number} */reader.readInt64();
	          msg.setTimestamp(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBlocksroothash(value);
	          break;
	        case 5:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setTxsroothash(value);
	          break;
	        case 6:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setConfirms(value);
	          break;
	        case 7:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPubkey(value);
	          break;
	        case 8:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setSign(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockHeader.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockHeader} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockHeader.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPrevblockhash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBlockno();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getTimestamp();
	    if (f !== 0) {
	      writer.writeInt64(3, f);
	    }
	    f = message.getBlocksroothash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	    f = message.getTxsroothash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(5, f);
	    }
	    f = message.getConfirms();
	    if (f !== 0) {
	      writer.writeUint64(6, f);
	    }
	    f = message.getPubkey_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(7, f);
	    }
	    f = message.getSign_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(8, f);
	    }
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * This is a type-conversion wrapper around `getPrevblockhash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPrevblockhash())
	    );
	  };

	  /**
	   * optional bytes prevBlockHash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPrevblockhash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getPrevblockhash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPrevblockhash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setPrevblockhash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 blockNo = 2;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getBlockno = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setBlockno = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional int64 timestamp = 3;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getTimestamp = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setTimestamp = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * This is a type-conversion wrapper around `getBlocksroothash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBlocksroothash())
	    );
	  };

	  /**
	   * optional bytes blocksRootHash = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBlocksroothash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getBlocksroothash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBlocksroothash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setBlocksroothash = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 5, "")
	    );
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * This is a type-conversion wrapper around `getTxsroothash()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getTxsroothash())
	    );
	  };

	  /**
	   * optional bytes txsRootHash = 5;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getTxsroothash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getTxsroothash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getTxsroothash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setTxsroothash = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * optional uint64 confirms = 6;
	   * @return {number}
	   */
	  proto.types.BlockHeader.prototype.getConfirms = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 6, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockHeader.prototype.setConfirms = function (value) {
	    googleProtobuf.Message.setField(this, 6, value);
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getPubkey = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 7, "")
	    );
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * This is a type-conversion wrapper around `getPubkey()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getPubkey_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPubkey())
	    );
	  };

	  /**
	   * optional bytes pubKey = 7;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPubkey()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getPubkey_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPubkey())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setPubkey = function (value) {
	    googleProtobuf.Message.setField(this, 7, value);
	  };

	  /**
	   * optional bytes sign = 8;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockHeader.prototype.getSign = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };

	  /**
	   * optional bytes sign = 8;
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {string}
	   */
	  proto.types.BlockHeader.prototype.getSign_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getSign())
	    );
	  };

	  /**
	   * optional bytes sign = 8;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeader.prototype.getSign_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getSign())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockHeader.prototype.setSign = function (value) {
	    googleProtobuf.Message.setField(this, 8, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockBody = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.BlockBody.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.BlockBody, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.BlockBody.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockBody.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockBody.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockBody} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockBody.toObject = function (includeInstance, msg) {
	      var obj = {
	        txsList: googleProtobuf.Message.toObjectList(msg.getTxsList(), proto.types.Tx.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockBody}
	   */
	  proto.types.BlockBody.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockBody();
	    return proto.types.BlockBody.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockBody} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockBody}
	   */
	  proto.types.BlockBody.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.addTxs(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockBody.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockBody.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockBody} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockBody.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Tx txs = 1;
	   * @return {!Array.<!proto.types.Tx>}
	   */
	  proto.types.BlockBody.prototype.getTxsList = function () {
	    return (/** @type{!Array.<!proto.types.Tx>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Tx, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Tx>} value */
	  proto.types.BlockBody.prototype.setTxsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Tx=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Tx}
	   */
	  proto.types.BlockBody.prototype.addTxs = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Tx, opt_index);
	  };

	  proto.types.BlockBody.prototype.clearTxsList = function () {
	    this.setTxsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.TxList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.TxList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.TxList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxList.toObject = function (includeInstance, msg) {
	      var obj = {
	        txsList: googleProtobuf.Message.toObjectList(msg.getTxsList(), proto.types.Tx.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxList}
	   */
	  proto.types.TxList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxList();
	    return proto.types.TxList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxList}
	   */
	  proto.types.TxList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.addTxs(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Tx txs = 1;
	   * @return {!Array.<!proto.types.Tx>}
	   */
	  proto.types.TxList.prototype.getTxsList = function () {
	    return (/** @type{!Array.<!proto.types.Tx>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Tx, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Tx>} value */
	  proto.types.TxList.prototype.setTxsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Tx=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Tx}
	   */
	  proto.types.TxList.prototype.addTxs = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Tx, opt_index);
	  };

	  proto.types.TxList.prototype.clearTxsList = function () {
	    this.setTxsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Tx = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Tx, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Tx.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Tx.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Tx} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Tx.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        hash: msg.getHash_asB64(),
	        body: (f = msg.getBody()) && proto.types.TxBody.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Tx}
	   */
	  proto.types.Tx.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Tx();
	    return proto.types.Tx.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Tx} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Tx}
	   */
	  proto.types.Tx.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = new proto.types.TxBody();
	          reader.readMessage(value, proto.types.TxBody.deserializeBinaryFromReader);
	          msg.setBody(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Tx.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Tx.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Tx} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Tx.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBody();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.TxBody.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Tx.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Tx.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Tx.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Tx.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional TxBody body = 2;
	   * @return {?proto.types.TxBody}
	   */
	  proto.types.Tx.prototype.getBody = function () {
	    return (/** @type{?proto.types.TxBody} */googleProtobuf.Message.getWrapperField(this, proto.types.TxBody, 2)
	    );
	  };

	  /** @param {?proto.types.TxBody|undefined} value */
	  proto.types.Tx.prototype.setBody = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Tx.prototype.clearBody = function () {
	    this.setBody(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Tx.prototype.hasBody = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxBody = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxBody, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxBody.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxBody.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxBody} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxBody.toObject = function (includeInstance, msg) {
	      var obj = {
	        nonce: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        account: msg.getAccount_asB64(),
	        recipient: msg.getRecipient_asB64(),
	        amount: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        payload: msg.getPayload_asB64(),
	        limit: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
	        price: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 8, 0),
	        sign: msg.getSign_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxBody}
	   */
	  proto.types.TxBody.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxBody();
	    return proto.types.TxBody.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxBody} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxBody}
	   */
	  proto.types.TxBody.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setNonce(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAccount(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setRecipient(value);
	          break;
	        case 4:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setAmount(value);
	          break;
	        case 5:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPayload(value);
	          break;
	        case 6:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setLimit(value);
	          break;
	        case 7:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setPrice(value);
	          break;
	        case 8:
	          var value = /** @type {!proto.types.TxType} */reader.readEnum();
	          msg.setType(value);
	          break;
	        case 9:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setSign(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxBody.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxBody} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxBody.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getNonce();
	    if (f !== 0) {
	      writer.writeUint64(1, f);
	    }
	    f = message.getAccount_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	    f = message.getRecipient_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getAmount();
	    if (f !== 0) {
	      writer.writeUint64(4, f);
	    }
	    f = message.getPayload_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(5, f);
	    }
	    f = message.getLimit();
	    if (f !== 0) {
	      writer.writeUint64(6, f);
	    }
	    f = message.getPrice();
	    if (f !== 0) {
	      writer.writeUint64(7, f);
	    }
	    f = message.getType();
	    if (f !== 0.0) {
	      writer.writeEnum(8, f);
	    }
	    f = message.getSign_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(9, f);
	    }
	  };

	  /**
	   * optional uint64 nonce = 1;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getNonce = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setNonce = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes account = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getAccount = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes account = 2;
	   * This is a type-conversion wrapper around `getAccount()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getAccount_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAccount())
	    );
	  };

	  /**
	   * optional bytes account = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAccount()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getAccount_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAccount())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setAccount = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes recipient = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getRecipient = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes recipient = 3;
	   * This is a type-conversion wrapper around `getRecipient()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getRecipient_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getRecipient())
	    );
	  };

	  /**
	   * optional bytes recipient = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getRecipient()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getRecipient_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getRecipient())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setRecipient = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional uint64 amount = 4;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getAmount = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setAmount = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bytes payload = 5;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getPayload = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 5, "")
	    );
	  };

	  /**
	   * optional bytes payload = 5;
	   * This is a type-conversion wrapper around `getPayload()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getPayload_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPayload())
	    );
	  };

	  /**
	   * optional bytes payload = 5;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPayload()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getPayload_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPayload())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setPayload = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * optional uint64 limit = 6;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getLimit = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 6, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setLimit = function (value) {
	    googleProtobuf.Message.setField(this, 6, value);
	  };

	  /**
	   * optional uint64 price = 7;
	   * @return {number}
	   */
	  proto.types.TxBody.prototype.getPrice = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxBody.prototype.setPrice = function (value) {
	    googleProtobuf.Message.setField(this, 7, value);
	  };

	  /**
	   * optional TxType type = 8;
	   * @return {!proto.types.TxType}
	   */
	  proto.types.TxBody.prototype.getType = function () {
	    return (/** @type {!proto.types.TxType} */googleProtobuf.Message.getFieldWithDefault(this, 8, 0)
	    );
	  };

	  /** @param {!proto.types.TxType} value */
	  proto.types.TxBody.prototype.setType = function (value) {
	    googleProtobuf.Message.setField(this, 8, value);
	  };

	  /**
	   * optional bytes sign = 9;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxBody.prototype.getSign = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };

	  /**
	   * optional bytes sign = 9;
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {string}
	   */
	  proto.types.TxBody.prototype.getSign_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getSign())
	    );
	  };

	  /**
	   * optional bytes sign = 9;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getSign()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxBody.prototype.getSign_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getSign())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxBody.prototype.setSign = function (value) {
	    googleProtobuf.Message.setField(this, 9, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxIdx = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxIdx, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxIdx.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxIdx.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxIdx} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxIdx.toObject = function (includeInstance, msg) {
	      var obj = {
	        blockhash: msg.getBlockhash_asB64(),
	        idx: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxIdx}
	   */
	  proto.types.TxIdx.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxIdx();
	    return proto.types.TxIdx.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxIdx} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxIdx}
	   */
	  proto.types.TxIdx.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBlockhash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readInt32();
	          msg.setIdx(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxIdx.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxIdx.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxIdx} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxIdx.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBlockhash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getIdx();
	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.TxIdx.prototype.getBlockhash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * This is a type-conversion wrapper around `getBlockhash()`
	   * @return {string}
	   */
	  proto.types.TxIdx.prototype.getBlockhash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBlockhash())
	    );
	  };

	  /**
	   * optional bytes blockHash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBlockhash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.TxIdx.prototype.getBlockhash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBlockhash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.TxIdx.prototype.setBlockhash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional int32 idx = 2;
	   * @return {number}
	   */
	  proto.types.TxIdx.prototype.getIdx = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.TxIdx.prototype.setIdx = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.TxInBlock = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.TxInBlock, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.TxInBlock.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.TxInBlock.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.TxInBlock} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.TxInBlock.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        txidx: (f = msg.getTxidx()) && proto.types.TxIdx.toObject(includeInstance, f),
	        tx: (f = msg.getTx()) && proto.types.Tx.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.TxInBlock}
	   */
	  proto.types.TxInBlock.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.TxInBlock();
	    return proto.types.TxInBlock.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.TxInBlock} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.TxInBlock}
	   */
	  proto.types.TxInBlock.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.TxIdx();
	          reader.readMessage(value, proto.types.TxIdx.deserializeBinaryFromReader);
	          msg.setTxidx(value);
	          break;
	        case 2:
	          var value = new proto.types.Tx();
	          reader.readMessage(value, proto.types.Tx.deserializeBinaryFromReader);
	          msg.setTx(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.TxInBlock.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.TxInBlock.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.TxInBlock} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.TxInBlock.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTxidx();
	    if (f != null) {
	      writer.writeMessage(1, f, proto.types.TxIdx.serializeBinaryToWriter);
	    }
	    f = message.getTx();
	    if (f != null) {
	      writer.writeMessage(2, f, proto.types.Tx.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional TxIdx txIdx = 1;
	   * @return {?proto.types.TxIdx}
	   */
	  proto.types.TxInBlock.prototype.getTxidx = function () {
	    return (/** @type{?proto.types.TxIdx} */googleProtobuf.Message.getWrapperField(this, proto.types.TxIdx, 1)
	    );
	  };

	  /** @param {?proto.types.TxIdx|undefined} value */
	  proto.types.TxInBlock.prototype.setTxidx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 1, value);
	  };

	  proto.types.TxInBlock.prototype.clearTxidx = function () {
	    this.setTxidx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.TxInBlock.prototype.hasTxidx = function () {
	    return googleProtobuf.Message.getField(this, 1) != null;
	  };

	  /**
	   * optional Tx tx = 2;
	   * @return {?proto.types.Tx}
	   */
	  proto.types.TxInBlock.prototype.getTx = function () {
	    return (/** @type{?proto.types.Tx} */googleProtobuf.Message.getWrapperField(this, proto.types.Tx, 2)
	    );
	  };

	  /** @param {?proto.types.Tx|undefined} value */
	  proto.types.TxInBlock.prototype.setTx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.TxInBlock.prototype.clearTx = function () {
	    this.setTx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.TxInBlock.prototype.hasTx = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.State = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.State, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.State.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.State.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.State} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.State.toObject = function (includeInstance, msg) {
	      var obj = {
	        nonce: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        balance: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        codehash: msg.getCodehash_asB64(),
	        storageroot: msg.getStorageroot_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.State}
	   */
	  proto.types.State.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.State();
	    return proto.types.State.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.State} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.State}
	   */
	  proto.types.State.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setNonce(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBalance(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setCodehash(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setStorageroot(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.State.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.State} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.State.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getNonce();
	    if (f !== 0) {
	      writer.writeUint64(1, f);
	    }
	    f = message.getBalance();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getCodehash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getStorageroot_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional uint64 nonce = 1;
	   * @return {number}
	   */
	  proto.types.State.prototype.getNonce = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.State.prototype.setNonce = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 balance = 2;
	   * @return {number}
	   */
	  proto.types.State.prototype.getBalance = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.State.prototype.setBalance = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.State.prototype.getCodehash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * This is a type-conversion wrapper around `getCodehash()`
	   * @return {string}
	   */
	  proto.types.State.prototype.getCodehash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getCodehash())
	    );
	  };

	  /**
	   * optional bytes codeHash = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getCodehash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.getCodehash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getCodehash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.State.prototype.setCodehash = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.State.prototype.getStorageroot = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * This is a type-conversion wrapper around `getStorageroot()`
	   * @return {string}
	   */
	  proto.types.State.prototype.getStorageroot_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getStorageroot())
	    );
	  };

	  /**
	   * optional bytes storageRoot = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getStorageroot()`
	   * @return {!Uint8Array}
	   */
	  proto.types.State.prototype.getStorageroot_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getStorageroot())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.State.prototype.setStorageroot = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Receipt = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Receipt, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Receipt.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Receipt.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Receipt} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Receipt.toObject = function (includeInstance, msg) {
	      var obj = {
	        contractaddress: msg.getContractaddress_asB64(),
	        status: googleProtobuf.Message.getFieldWithDefault(msg, 2, ""),
	        ret: googleProtobuf.Message.getFieldWithDefault(msg, 3, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Receipt}
	   */
	  proto.types.Receipt.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Receipt();
	    return proto.types.Receipt.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Receipt} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Receipt}
	   */
	  proto.types.Receipt.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setContractaddress(value);
	          break;
	        case 2:
	          var value = /** @type {string} */reader.readString();
	          msg.setStatus(value);
	          break;
	        case 3:
	          var value = /** @type {string} */reader.readString();
	          msg.setRet(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Receipt.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Receipt.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Receipt} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Receipt.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getContractaddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getStatus();
	    if (f.length > 0) {
	      writer.writeString(2, f);
	    }
	    f = message.getRet();
	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Receipt.prototype.getContractaddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getContractaddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getContractaddress())
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Receipt.prototype.getContractaddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getContractaddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Receipt.prototype.setContractaddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional string status = 2;
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getStatus = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Receipt.prototype.setStatus = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional string ret = 3;
	   * @return {string}
	   */
	  proto.types.Receipt.prototype.getRet = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Receipt.prototype.setRet = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Vote = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Vote, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Vote.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Vote.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Vote} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Vote.toObject = function (includeInstance, msg) {
	      var obj = {
	        candidate: msg.getCandidate_asB64(),
	        amount: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Vote}
	   */
	  proto.types.Vote.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Vote();
	    return proto.types.Vote.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Vote} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Vote}
	   */
	  proto.types.Vote.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setCandidate(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setAmount(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Vote.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Vote.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Vote} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Vote.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getCandidate_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getAmount();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	  };

	  /**
	   * optional bytes candidate = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Vote.prototype.getCandidate = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes candidate = 1;
	   * This is a type-conversion wrapper around `getCandidate()`
	   * @return {string}
	   */
	  proto.types.Vote.prototype.getCandidate_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getCandidate())
	    );
	  };

	  /**
	   * optional bytes candidate = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getCandidate()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Vote.prototype.getCandidate_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getCandidate())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Vote.prototype.setCandidate = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 amount = 2;
	   * @return {number}
	   */
	  proto.types.Vote.prototype.getAmount = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.Vote.prototype.setAmount = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.VoteList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.VoteList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.VoteList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.VoteList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.VoteList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.VoteList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.VoteList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.VoteList.toObject = function (includeInstance, msg) {
	      var obj = {
	        votesList: googleProtobuf.Message.toObjectList(msg.getVotesList(), proto.types.Vote.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.VoteList}
	   */
	  proto.types.VoteList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.VoteList();
	    return proto.types.VoteList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.VoteList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.VoteList}
	   */
	  proto.types.VoteList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Vote();
	          reader.readMessage(value, proto.types.Vote.deserializeBinaryFromReader);
	          msg.addVotes(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.VoteList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.VoteList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.VoteList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.VoteList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getVotesList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Vote.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Vote votes = 1;
	   * @return {!Array.<!proto.types.Vote>}
	   */
	  proto.types.VoteList.prototype.getVotesList = function () {
	    return (/** @type{!Array.<!proto.types.Vote>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Vote, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Vote>} value */
	  proto.types.VoteList.prototype.setVotesList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Vote=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Vote}
	   */
	  proto.types.VoteList.prototype.addVotes = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Vote, opt_index);
	  };

	  proto.types.VoteList.prototype.clearVotesList = function () {
	    this.setVotesList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.FnArgument = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.FnArgument, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.FnArgument.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.FnArgument.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.FnArgument} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.FnArgument.toObject = function (includeInstance, msg) {
	      var obj = {
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 1, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.FnArgument.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.FnArgument();
	    return proto.types.FnArgument.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.FnArgument} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.FnArgument.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setName(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.FnArgument.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.FnArgument.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.FnArgument} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.FnArgument.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getName();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	  };

	  /**
	   * optional string name = 1;
	   * @return {string}
	   */
	  proto.types.FnArgument.prototype.getName = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.FnArgument.prototype.setName = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Function = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.Function.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.Function, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.Function.repeatedFields_ = [2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Function.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Function.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Function} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Function.toObject = function (includeInstance, msg) {
	      var obj = {
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        argumentsList: googleProtobuf.Message.toObjectList(msg.getArgumentsList(), proto.types.FnArgument.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Function}
	   */
	  proto.types.Function.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Function();
	    return proto.types.Function.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Function} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Function}
	   */
	  proto.types.Function.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setName(value);
	          break;
	        case 2:
	          var value = new proto.types.FnArgument();
	          reader.readMessage(value, proto.types.FnArgument.deserializeBinaryFromReader);
	          msg.addArguments(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Function.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Function.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Function} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Function.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getName();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getArgumentsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(2, f, proto.types.FnArgument.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string name = 1;
	   * @return {string}
	   */
	  proto.types.Function.prototype.getName = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Function.prototype.setName = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * repeated FnArgument arguments = 2;
	   * @return {!Array.<!proto.types.FnArgument>}
	   */
	  proto.types.Function.prototype.getArgumentsList = function () {
	    return (/** @type{!Array.<!proto.types.FnArgument>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.FnArgument, 2)
	    );
	  };

	  /** @param {!Array.<!proto.types.FnArgument>} value */
	  proto.types.Function.prototype.setArgumentsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
	  };

	  /**
	   * @param {!proto.types.FnArgument=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.FnArgument}
	   */
	  proto.types.Function.prototype.addArguments = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.types.FnArgument, opt_index);
	  };

	  proto.types.Function.prototype.clearArgumentsList = function () {
	    this.setArgumentsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.ABI = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.ABI.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.ABI, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.ABI.repeatedFields_ = [3];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.ABI.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.ABI.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.ABI} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.ABI.toObject = function (includeInstance, msg) {
	      var obj = {
	        version: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        language: googleProtobuf.Message.getFieldWithDefault(msg, 2, ""),
	        functionsList: googleProtobuf.Message.toObjectList(msg.getFunctionsList(), proto.types.Function.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.ABI}
	   */
	  proto.types.ABI.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.ABI();
	    return proto.types.ABI.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.ABI} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.ABI}
	   */
	  proto.types.ABI.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setVersion(value);
	          break;
	        case 2:
	          var value = /** @type {string} */reader.readString();
	          msg.setLanguage(value);
	          break;
	        case 3:
	          var value = new proto.types.Function();
	          reader.readMessage(value, proto.types.Function.deserializeBinaryFromReader);
	          msg.addFunctions(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.ABI.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.ABI.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.ABI} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.ABI.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getVersion();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getLanguage();
	    if (f.length > 0) {
	      writer.writeString(2, f);
	    }
	    f = message.getFunctionsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(3, f, proto.types.Function.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string version = 1;
	   * @return {string}
	   */
	  proto.types.ABI.prototype.getVersion = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.ABI.prototype.setVersion = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional string language = 2;
	   * @return {string}
	   */
	  proto.types.ABI.prototype.getLanguage = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.ABI.prototype.setLanguage = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * repeated Function functions = 3;
	   * @return {!Array.<!proto.types.Function>}
	   */
	  proto.types.ABI.prototype.getFunctionsList = function () {
	    return (/** @type{!Array.<!proto.types.Function>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Function, 3)
	    );
	  };

	  /** @param {!Array.<!proto.types.Function>} value */
	  proto.types.ABI.prototype.setFunctionsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 3, value);
	  };

	  /**
	   * @param {!proto.types.Function=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Function}
	   */
	  proto.types.ABI.prototype.addFunctions = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.types.Function, opt_index);
	  };

	  proto.types.ABI.prototype.clearFunctionsList = function () {
	    this.setFunctionsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Query = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Query, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Query.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Query.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Query} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Query.toObject = function (includeInstance, msg) {
	      var obj = {
	        contractaddress: msg.getContractaddress_asB64(),
	        queryinfo: msg.getQueryinfo_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Query}
	   */
	  proto.types.Query.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Query();
	    return proto.types.Query.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Query} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Query}
	   */
	  proto.types.Query.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setContractaddress(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setQueryinfo(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Query.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Query} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Query.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getContractaddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getQueryinfo_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Query.prototype.getContractaddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {string}
	   */
	  proto.types.Query.prototype.getContractaddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getContractaddress())
	    );
	  };

	  /**
	   * optional bytes contractAddress = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getContractaddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.getContractaddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getContractaddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Query.prototype.setContractaddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Query.prototype.getQueryinfo = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * This is a type-conversion wrapper around `getQueryinfo()`
	   * @return {string}
	   */
	  proto.types.Query.prototype.getQueryinfo_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getQueryinfo())
	    );
	  };

	  /**
	   * optional bytes queryinfo = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getQueryinfo()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Query.prototype.getQueryinfo_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getQueryinfo())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Query.prototype.setQueryinfo = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.TxType = {
	    NORMAL: 0,
	    GOVERNANCE: 1
	  };

	  goog.object.extend(exports, proto.types);
	});

	var account_pb$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.Account', null, global);
	  goog.exportSymbol('proto.types.AccountList', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Account = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Account, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Account.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Account.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Account} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Account.toObject = function (includeInstance, msg) {
	      var obj = {
	        address: msg.getAddress_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Account}
	   */
	  proto.types.Account.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Account();
	    return proto.types.Account.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Account} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Account}
	   */
	  proto.types.Account.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Account.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Account.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Account} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Account.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	  };

	  /**
	   * optional bytes address = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Account.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.Account.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Account.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Account.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.AccountList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.AccountList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.AccountList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.AccountList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.AccountList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.AccountList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.AccountList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.AccountList.toObject = function (includeInstance, msg) {
	      var obj = {
	        accountsList: googleProtobuf.Message.toObjectList(msg.getAccountsList(), proto.types.Account.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.AccountList}
	   */
	  proto.types.AccountList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.AccountList();
	    return proto.types.AccountList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.AccountList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.AccountList}
	   */
	  proto.types.AccountList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.Account();
	          reader.readMessage(value, proto.types.Account.deserializeBinaryFromReader);
	          msg.addAccounts(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.AccountList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.AccountList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.AccountList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.AccountList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAccountsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.Account.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Account accounts = 1;
	   * @return {!Array.<!proto.types.Account>}
	   */
	  proto.types.AccountList.prototype.getAccountsList = function () {
	    return (/** @type{!Array.<!proto.types.Account>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.Account, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Account>} value */
	  proto.types.AccountList.prototype.setAccountsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Account=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Account}
	   */
	  proto.types.AccountList.prototype.addAccounts = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Account, opt_index);
	  };

	  proto.types.AccountList.prototype.clearAccountsList = function () {
	    this.setAccountsList([]);
	  };

	  goog.object.extend(exports, proto.types);
	});

	var node_pb$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.PeerAddress', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.PeerAddress = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.PeerAddress, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.PeerAddress.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.PeerAddress.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.PeerAddress} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.PeerAddress.toObject = function (includeInstance, msg) {
	      var obj = {
	        address: msg.getAddress_asB64(),
	        port: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        peerid: msg.getPeerid_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerAddress.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.PeerAddress();
	    return proto.types.PeerAddress.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.PeerAddress} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerAddress.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setPort(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setPeerid(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.PeerAddress.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.PeerAddress} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.PeerAddress.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getPort();
	    if (f !== 0) {
	      writer.writeUint32(2, f);
	    }
	    f = message.getPeerid_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	  };

	  /**
	   * optional bytes address = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.PeerAddress.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.PeerAddress.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.PeerAddress.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint32 port = 2;
	   * @return {number}
	   */
	  proto.types.PeerAddress.prototype.getPort = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.PeerAddress.prototype.setPort = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes peerID = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.PeerAddress.prototype.getPeerid = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes peerID = 3;
	   * This is a type-conversion wrapper around `getPeerid()`
	   * @return {string}
	   */
	  proto.types.PeerAddress.prototype.getPeerid_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getPeerid())
	    );
	  };

	  /**
	   * optional bytes peerID = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPeerid()`
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerAddress.prototype.getPeerid_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getPeerid())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.PeerAddress.prototype.setPeerid = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  goog.object.extend(exports, proto.types);
	});

	var rpc_pb$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!


	  var goog = googleProtobuf;
	  var global = Function('return this')();

	  goog.exportSymbol('proto.types.BlockHeaderList', null, global);
	  goog.exportSymbol('proto.types.BlockchainStatus', null, global);
	  goog.exportSymbol('proto.types.CommitResult', null, global);
	  goog.exportSymbol('proto.types.CommitResultList', null, global);
	  goog.exportSymbol('proto.types.CommitStatus', null, global);
	  goog.exportSymbol('proto.types.Empty', null, global);
	  goog.exportSymbol('proto.types.Input', null, global);
	  goog.exportSymbol('proto.types.ListParams', null, global);
	  goog.exportSymbol('proto.types.Output', null, global);
	  goog.exportSymbol('proto.types.PeerList', null, global);
	  goog.exportSymbol('proto.types.Personal', null, global);
	  goog.exportSymbol('proto.types.SingleBytes', null, global);
	  goog.exportSymbol('proto.types.VerifyResult', null, global);
	  goog.exportSymbol('proto.types.VerifyStatus', null, global);

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockchainStatus = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.BlockchainStatus, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockchainStatus.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockchainStatus.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockchainStatus} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockchainStatus.toObject = function (includeInstance, msg) {
	      var obj = {
	        bestBlockHash: msg.getBestBlockHash_asB64(),
	        bestHeight: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockchainStatus}
	   */
	  proto.types.BlockchainStatus.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockchainStatus();
	    return proto.types.BlockchainStatus.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockchainStatus} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockchainStatus}
	   */
	  proto.types.BlockchainStatus.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setBestBlockHash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setBestHeight(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockchainStatus.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockchainStatus.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockchainStatus} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockchainStatus.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBestBlockHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getBestHeight();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * This is a type-conversion wrapper around `getBestBlockHash()`
	   * @return {string}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getBestBlockHash())
	    );
	  };

	  /**
	   * optional bytes best_block_hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBestBlockHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockchainStatus.prototype.getBestBlockHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getBestBlockHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.BlockchainStatus.prototype.setBestBlockHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 best_height = 2;
	   * @return {number}
	   */
	  proto.types.BlockchainStatus.prototype.getBestHeight = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.BlockchainStatus.prototype.setBestHeight = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Input = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.Input.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.Input, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.Input.repeatedFields_ = [2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Input.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Input.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Input} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Input.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        addressList: msg.getAddressList_asB64(),
	        value: msg.getValue_asB64(),
	        script: msg.getScript_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Input}
	   */
	  proto.types.Input.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Input();
	    return proto.types.Input.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Input} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Input}
	   */
	  proto.types.Input.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.addAddress(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setScript(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Input.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Input} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Input.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getAddressList_asU8();
	    if (f.length > 0) {
	      writer.writeRepeatedBytes(2, f);
	    }
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getScript_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * repeated bytes address = 2;
	   * @return {!(Array<!Uint8Array>|Array<string>)}
	   */
	  proto.types.Input.prototype.getAddressList = function () {
	    return (/** @type {!(Array<!Uint8Array>|Array<string>)} */googleProtobuf.Message.getRepeatedField(this, 2)
	    );
	  };

	  /**
	   * repeated bytes address = 2;
	   * This is a type-conversion wrapper around `getAddressList()`
	   * @return {!Array.<string>}
	   */
	  proto.types.Input.prototype.getAddressList_asB64 = function () {
	    return (/** @type {!Array.<string>} */googleProtobuf.Message.bytesListAsB64(this.getAddressList())
	    );
	  };

	  /**
	   * repeated bytes address = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddressList()`
	   * @return {!Array.<!Uint8Array>}
	   */
	  proto.types.Input.prototype.getAddressList_asU8 = function () {
	    return (/** @type {!Array.<!Uint8Array>} */googleProtobuf.Message.bytesListAsU8(this.getAddressList())
	    );
	  };

	  /** @param {!(Array<!Uint8Array>|Array<string>)} value */
	  proto.types.Input.prototype.setAddressList = function (value) {
	    googleProtobuf.Message.setField(this, 2, value || []);
	  };

	  /**
	   * @param {!(string|Uint8Array)} value
	   * @param {number=} opt_index
	   */
	  proto.types.Input.prototype.addAddress = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
	  };

	  proto.types.Input.prototype.clearAddressList = function () {
	    this.setAddressList([]);
	  };

	  /**
	   * optional bytes value = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes script = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Input.prototype.getScript = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {string}
	   */
	  proto.types.Input.prototype.getScript_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getScript())
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Input.prototype.getScript_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getScript())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Input.prototype.setScript = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Output = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Output, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Output.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Output.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Output} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Output.toObject = function (includeInstance, msg) {
	      var obj = {
	        index: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        address: msg.getAddress_asB64(),
	        value: msg.getValue_asB64(),
	        script: msg.getScript_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Output}
	   */
	  proto.types.Output.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Output();
	    return proto.types.Output.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Output} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Output}
	   */
	  proto.types.Output.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setIndex(value);
	          break;
	        case 2:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setAddress(value);
	          break;
	        case 3:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        case 4:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setScript(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Output.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Output} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Output.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getIndex();
	    if (f !== 0) {
	      writer.writeUint32(1, f);
	    }
	    f = message.getAddress_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(2, f);
	    }
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(3, f);
	    }
	    f = message.getScript_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(4, f);
	    }
	  };

	  /**
	   * optional uint32 index = 1;
	   * @return {number}
	   */
	  proto.types.Output.prototype.getIndex = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.Output.prototype.setIndex = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional bytes address = 2;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getAddress = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 2, "")
	    );
	  };

	  /**
	   * optional bytes address = 2;
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getAddress_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getAddress())
	    );
	  };

	  /**
	   * optional bytes address = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getAddress()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getAddress_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getAddress())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setAddress = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional bytes value = 3;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 3;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional bytes script = 4;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.Output.prototype.getScript = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 4, "")
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {string}
	   */
	  proto.types.Output.prototype.getScript_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getScript())
	    );
	  };

	  /**
	   * optional bytes script = 4;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getScript()`
	   * @return {!Uint8Array}
	   */
	  proto.types.Output.prototype.getScript_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getScript())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.Output.prototype.setScript = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Empty = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Empty, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Empty.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Empty.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Empty} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Empty.toObject = function (includeInstance, msg) {
	      var obj = {};

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Empty}
	   */
	  proto.types.Empty.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Empty();
	    return proto.types.Empty.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Empty} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Empty}
	   */
	  proto.types.Empty.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Empty.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Empty.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Empty} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Empty.serializeBinaryToWriter = function (message, writer) {
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.SingleBytes = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.SingleBytes, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.SingleBytes.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.SingleBytes.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.SingleBytes} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.SingleBytes.toObject = function (includeInstance, msg) {
	      var obj = {
	        value: msg.getValue_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.SingleBytes}
	   */
	  proto.types.SingleBytes.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.SingleBytes();
	    return proto.types.SingleBytes.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.SingleBytes} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.SingleBytes}
	   */
	  proto.types.SingleBytes.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setValue(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.SingleBytes.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.SingleBytes.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.SingleBytes} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.SingleBytes.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getValue_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	  };

	  /**
	   * optional bytes value = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.SingleBytes.prototype.getValue = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes value = 1;
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {string}
	   */
	  proto.types.SingleBytes.prototype.getValue_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getValue())
	    );
	  };

	  /**
	   * optional bytes value = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getValue()`
	   * @return {!Uint8Array}
	   */
	  proto.types.SingleBytes.prototype.getValue_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getValue())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.SingleBytes.prototype.setValue = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.Personal = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.Personal, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.Personal.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.Personal.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.Personal} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.Personal.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        passphrase: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        account: (f = msg.getAccount()) && account_pb$1.Account.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.Personal}
	   */
	  proto.types.Personal.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.Personal();
	    return proto.types.Personal.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.Personal} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.Personal}
	   */
	  proto.types.Personal.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {string} */reader.readString();
	          msg.setPassphrase(value);
	          break;
	        case 2:
	          var value = new account_pb$1.Account();
	          reader.readMessage(value, account_pb$1.Account.deserializeBinaryFromReader);
	          msg.setAccount(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.Personal.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.Personal.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.Personal} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.Personal.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPassphrase();
	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }
	    f = message.getAccount();
	    if (f != null) {
	      writer.writeMessage(2, f, account_pb$1.Account.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * optional string passphrase = 1;
	   * @return {string}
	   */
	  proto.types.Personal.prototype.getPassphrase = function () {
	    return (/** @type {string} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /** @param {string} value */
	  proto.types.Personal.prototype.setPassphrase = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional Account account = 2;
	   * @return {?proto.types.Account}
	   */
	  proto.types.Personal.prototype.getAccount = function () {
	    return (/** @type{?proto.types.Account} */googleProtobuf.Message.getWrapperField(this, account_pb$1.Account, 2)
	    );
	  };

	  /** @param {?proto.types.Account|undefined} value */
	  proto.types.Personal.prototype.setAccount = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };

	  proto.types.Personal.prototype.clearAccount = function () {
	    this.setAccount(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.Personal.prototype.hasAccount = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.PeerList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.PeerList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.PeerList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.PeerList.repeatedFields_ = [1, 2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.PeerList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.PeerList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.PeerList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.PeerList.toObject = function (includeInstance, msg) {
	      var obj = {
	        peersList: googleProtobuf.Message.toObjectList(msg.getPeersList(), node_pb$1.PeerAddress.toObject, includeInstance),
	        statesList: googleProtobuf.Message.getRepeatedField(msg, 2)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.PeerList}
	   */
	  proto.types.PeerList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.PeerList();
	    return proto.types.PeerList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.PeerList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.PeerList}
	   */
	  proto.types.PeerList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new node_pb$1.PeerAddress();
	          reader.readMessage(value, node_pb$1.PeerAddress.deserializeBinaryFromReader);
	          msg.addPeers(value);
	          break;
	        case 2:
	          var value = /** @type {!Array.<number>} */reader.readPackedInt32();
	          msg.setStatesList(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.PeerList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.PeerList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.PeerList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.PeerList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getPeersList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, node_pb$1.PeerAddress.serializeBinaryToWriter);
	    }
	    f = message.getStatesList();
	    if (f.length > 0) {
	      writer.writePackedInt32(2, f);
	    }
	  };

	  /**
	   * repeated PeerAddress peers = 1;
	   * @return {!Array.<!proto.types.PeerAddress>}
	   */
	  proto.types.PeerList.prototype.getPeersList = function () {
	    return (/** @type{!Array.<!proto.types.PeerAddress>} */googleProtobuf.Message.getRepeatedWrapperField(this, node_pb$1.PeerAddress, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.PeerAddress>} value */
	  proto.types.PeerList.prototype.setPeersList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.PeerAddress=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.PeerAddress}
	   */
	  proto.types.PeerList.prototype.addPeers = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.PeerAddress, opt_index);
	  };

	  proto.types.PeerList.prototype.clearPeersList = function () {
	    this.setPeersList([]);
	  };

	  /**
	   * repeated int32 states = 2;
	   * @return {!Array.<number>}
	   */
	  proto.types.PeerList.prototype.getStatesList = function () {
	    return (/** @type {!Array.<number>} */googleProtobuf.Message.getRepeatedField(this, 2)
	    );
	  };

	  /** @param {!Array.<number>} value */
	  proto.types.PeerList.prototype.setStatesList = function (value) {
	    googleProtobuf.Message.setField(this, 2, value || []);
	  };

	  /**
	   * @param {!number} value
	   * @param {number=} opt_index
	   */
	  proto.types.PeerList.prototype.addStates = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
	  };

	  proto.types.PeerList.prototype.clearStatesList = function () {
	    this.setStatesList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.ListParams = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.ListParams, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.ListParams.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.ListParams.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.ListParams} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.ListParams.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        height: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        size: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        offset: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        asc: googleProtobuf.Message.getFieldWithDefault(msg, 5, false)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.ListParams}
	   */
	  proto.types.ListParams.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.ListParams();
	    return proto.types.ListParams.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.ListParams} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.ListParams}
	   */
	  proto.types.ListParams.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {number} */reader.readUint64();
	          msg.setHeight(value);
	          break;
	        case 3:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setSize(value);
	          break;
	        case 4:
	          var value = /** @type {number} */reader.readUint32();
	          msg.setOffset(value);
	          break;
	        case 5:
	          var value = /** @type {boolean} */reader.readBool();
	          msg.setAsc(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.ListParams.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.ListParams.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.ListParams} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.ListParams.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getHeight();
	    if (f !== 0) {
	      writer.writeUint64(2, f);
	    }
	    f = message.getSize();
	    if (f !== 0) {
	      writer.writeUint32(3, f);
	    }
	    f = message.getOffset();
	    if (f !== 0) {
	      writer.writeUint32(4, f);
	    }
	    f = message.getAsc();
	    if (f) {
	      writer.writeBool(5, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.ListParams.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.ListParams.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.ListParams.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.ListParams.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional uint64 height = 2;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getHeight = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setHeight = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * optional uint32 size = 3;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getSize = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setSize = function (value) {
	    googleProtobuf.Message.setField(this, 3, value);
	  };

	  /**
	   * optional uint32 offset = 4;
	   * @return {number}
	   */
	  proto.types.ListParams.prototype.getOffset = function () {
	    return (/** @type {number} */googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };

	  /** @param {number} value */
	  proto.types.ListParams.prototype.setOffset = function (value) {
	    googleProtobuf.Message.setField(this, 4, value);
	  };

	  /**
	   * optional bool asc = 5;
	   * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
	   * You should avoid comparisons like {@code val === true/false} in those cases.
	   * @return {boolean}
	   */
	  proto.types.ListParams.prototype.getAsc = function () {
	    return (/** @type {boolean} */googleProtobuf.Message.getFieldWithDefault(this, 5, false)
	    );
	  };

	  /** @param {boolean} value */
	  proto.types.ListParams.prototype.setAsc = function (value) {
	    googleProtobuf.Message.setField(this, 5, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.BlockHeaderList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.BlockHeaderList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.BlockHeaderList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.BlockHeaderList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.BlockHeaderList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.BlockHeaderList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.BlockHeaderList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.BlockHeaderList.toObject = function (includeInstance, msg) {
	      var obj = {
	        blocksList: googleProtobuf.Message.toObjectList(msg.getBlocksList(), blockchain_pb$1.Block.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.BlockHeaderList}
	   */
	  proto.types.BlockHeaderList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.BlockHeaderList();
	    return proto.types.BlockHeaderList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.BlockHeaderList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.BlockHeaderList}
	   */
	  proto.types.BlockHeaderList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new blockchain_pb$1.Block();
	          reader.readMessage(value, blockchain_pb$1.Block.deserializeBinaryFromReader);
	          msg.addBlocks(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.BlockHeaderList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.BlockHeaderList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.BlockHeaderList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.BlockHeaderList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getBlocksList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, blockchain_pb$1.Block.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated Block blocks = 1;
	   * @return {!Array.<!proto.types.Block>}
	   */
	  proto.types.BlockHeaderList.prototype.getBlocksList = function () {
	    return (/** @type{!Array.<!proto.types.Block>} */googleProtobuf.Message.getRepeatedWrapperField(this, blockchain_pb$1.Block, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.Block>} value */
	  proto.types.BlockHeaderList.prototype.setBlocksList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.Block=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.Block}
	   */
	  proto.types.BlockHeaderList.prototype.addBlocks = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.Block, opt_index);
	  };

	  proto.types.BlockHeaderList.prototype.clearBlocksList = function () {
	    this.setBlocksList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.CommitResult = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.CommitResult, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.CommitResult.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.CommitResult.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.CommitResult} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.CommitResult.toObject = function (includeInstance, msg) {
	      var obj = {
	        hash: msg.getHash_asB64(),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResult.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.CommitResult();
	    return proto.types.CommitResult.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.CommitResult} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResult.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = /** @type {!Uint8Array} */reader.readBytes();
	          msg.setHash(value);
	          break;
	        case 2:
	          var value = /** @type {!proto.types.CommitStatus} */reader.readEnum();
	          msg.setError(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResult.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.CommitResult.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.CommitResult} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.CommitResult.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getHash_asU8();
	    if (f.length > 0) {
	      writer.writeBytes(1, f);
	    }
	    f = message.getError();
	    if (f !== 0.0) {
	      writer.writeEnum(2, f);
	    }
	  };

	  /**
	   * optional bytes hash = 1;
	   * @return {!(string|Uint8Array)}
	   */
	  proto.types.CommitResult.prototype.getHash = function () {
	    return (/** @type {!(string|Uint8Array)} */googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {string}
	   */
	  proto.types.CommitResult.prototype.getHash_asB64 = function () {
	    return (/** @type {string} */googleProtobuf.Message.bytesAsB64(this.getHash())
	    );
	  };

	  /**
	   * optional bytes hash = 1;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getHash()`
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResult.prototype.getHash_asU8 = function () {
	    return (/** @type {!Uint8Array} */googleProtobuf.Message.bytesAsU8(this.getHash())
	    );
	  };

	  /** @param {!(string|Uint8Array)} value */
	  proto.types.CommitResult.prototype.setHash = function (value) {
	    googleProtobuf.Message.setField(this, 1, value);
	  };

	  /**
	   * optional CommitStatus error = 2;
	   * @return {!proto.types.CommitStatus}
	   */
	  proto.types.CommitResult.prototype.getError = function () {
	    return (/** @type {!proto.types.CommitStatus} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {!proto.types.CommitStatus} value */
	  proto.types.CommitResult.prototype.setError = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.CommitResultList = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.types.CommitResultList.repeatedFields_, null);
	  };
	  goog.inherits(proto.types.CommitResultList, googleProtobuf.Message);
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */
	  proto.types.CommitResultList.repeatedFields_ = [1];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.CommitResultList.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.CommitResultList.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.CommitResultList} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.CommitResultList.toObject = function (includeInstance, msg) {
	      var obj = {
	        resultsList: googleProtobuf.Message.toObjectList(msg.getResultsList(), proto.types.CommitResult.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.CommitResultList}
	   */
	  proto.types.CommitResultList.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.CommitResultList();
	    return proto.types.CommitResultList.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.CommitResultList} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.CommitResultList}
	   */
	  proto.types.CommitResultList.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new proto.types.CommitResult();
	          reader.readMessage(value, proto.types.CommitResult.deserializeBinaryFromReader);
	          msg.addResults(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.CommitResultList.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.CommitResultList.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.CommitResultList} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.CommitResultList.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getResultsList();
	    if (f.length > 0) {
	      writer.writeRepeatedMessage(1, f, proto.types.CommitResult.serializeBinaryToWriter);
	    }
	  };

	  /**
	   * repeated CommitResult results = 1;
	   * @return {!Array.<!proto.types.CommitResult>}
	   */
	  proto.types.CommitResultList.prototype.getResultsList = function () {
	    return (/** @type{!Array.<!proto.types.CommitResult>} */googleProtobuf.Message.getRepeatedWrapperField(this, proto.types.CommitResult, 1)
	    );
	  };

	  /** @param {!Array.<!proto.types.CommitResult>} value */
	  proto.types.CommitResultList.prototype.setResultsList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
	  };

	  /**
	   * @param {!proto.types.CommitResult=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.types.CommitResult}
	   */
	  proto.types.CommitResultList.prototype.addResults = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.types.CommitResult, opt_index);
	  };

	  proto.types.CommitResultList.prototype.clearResultsList = function () {
	    this.setResultsList([]);
	  };

	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */
	  proto.types.VerifyResult = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };
	  goog.inherits(proto.types.VerifyResult, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.types.VerifyResult.prototype.toObject = function (opt_includeInstance) {
	      return proto.types.VerifyResult.toObject(opt_includeInstance, this);
	    };

	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.types.VerifyResult} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */
	    proto.types.VerifyResult.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        tx: (f = msg.getTx()) && blockchain_pb$1.Tx.toObject(includeInstance, f),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }
	      return obj;
	    };
	  }

	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.types.VerifyResult}
	   */
	  proto.types.VerifyResult.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.types.VerifyResult();
	    return proto.types.VerifyResult.deserializeBinaryFromReader(msg, reader);
	  };

	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.types.VerifyResult} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.types.VerifyResult}
	   */
	  proto.types.VerifyResult.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }
	      var field = reader.getFieldNumber();
	      switch (field) {
	        case 1:
	          var value = new blockchain_pb$1.Tx();
	          reader.readMessage(value, blockchain_pb$1.Tx.deserializeBinaryFromReader);
	          msg.setTx(value);
	          break;
	        case 2:
	          var value = /** @type {!proto.types.VerifyStatus} */reader.readEnum();
	          msg.setError(value);
	          break;
	        default:
	          reader.skipField();
	          break;
	      }
	    }
	    return msg;
	  };

	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */
	  proto.types.VerifyResult.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.types.VerifyResult.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };

	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.types.VerifyResult} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */
	  proto.types.VerifyResult.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getTx();
	    if (f != null) {
	      writer.writeMessage(1, f, blockchain_pb$1.Tx.serializeBinaryToWriter);
	    }
	    f = message.getError();
	    if (f !== 0.0) {
	      writer.writeEnum(2, f);
	    }
	  };

	  /**
	   * optional Tx tx = 1;
	   * @return {?proto.types.Tx}
	   */
	  proto.types.VerifyResult.prototype.getTx = function () {
	    return (/** @type{?proto.types.Tx} */googleProtobuf.Message.getWrapperField(this, blockchain_pb$1.Tx, 1)
	    );
	  };

	  /** @param {?proto.types.Tx|undefined} value */
	  proto.types.VerifyResult.prototype.setTx = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 1, value);
	  };

	  proto.types.VerifyResult.prototype.clearTx = function () {
	    this.setTx(undefined);
	  };

	  /**
	   * Returns whether this field is set.
	   * @return {!boolean}
	   */
	  proto.types.VerifyResult.prototype.hasTx = function () {
	    return googleProtobuf.Message.getField(this, 1) != null;
	  };

	  /**
	   * optional VerifyStatus error = 2;
	   * @return {!proto.types.VerifyStatus}
	   */
	  proto.types.VerifyResult.prototype.getError = function () {
	    return (/** @type {!proto.types.VerifyStatus} */googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };

	  /** @param {!proto.types.VerifyStatus} value */
	  proto.types.VerifyResult.prototype.setError = function (value) {
	    googleProtobuf.Message.setField(this, 2, value);
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.CommitStatus = {
	    COMMIT_STATUS_OK: 0,
	    COMMIT_STATUS_NONCE_TOO_LOW: 1,
	    COMMIT_STATUS_INVALID_ARGUMENT: 2,
	    COMMIT_STATUS_TX_ALREADY_EXISTS: 3,
	    COMMIT_STATUS_TX_INTERNAL_ERROR: 4
	  };

	  /**
	   * @enum {number}
	   */
	  proto.types.VerifyStatus = {
	    VERIFY_STATUS_OK: 0,
	    VERIFY_STATUS_SIGN_NOT_MATCH: 1,
	    VERIFY_STATUS_INVALID_HASH: 2
	  };

	  goog.object.extend(exports, proto.types);
	});

	var typesWeb = /*#__PURE__*/Object.freeze({
		default: rpc_pb$1,
		__moduleExports: rpc_pb$1
	});

	var platformWeb = typeof process === 'undefined' || process.env.TARGET == 'web';
	var rpcTypes = platformWeb ? typesWeb : typesNode;

	var ADDRESS_PREFIXES = {
	    ACCOUNT: '17' // 0x17
	};

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString = {}.toString;

	var isArray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	var _kMaxLength = kMaxLength();

	function kMaxLength () {
	  return Buffer$1.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$1(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$1 (arg, encodingOrOffset, length) {
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
	    return new Buffer$1(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$1.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$1._augment = function (arr) {
	  arr.__proto__ = Buffer$1.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$1.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$1.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$1.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$1.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$1.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$1.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0;
	  }
	  return Buffer$1.alloc(+length)
	}
	Buffer$1.isBuffer = isBuffer;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$1.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$1.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$1.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$1.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$1.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$1.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$1.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$1.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$1.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$1.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$1.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$1.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$1.compare(this, b) === 0
	};

	Buffer$1.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$1.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read$$1 (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read$$1(arr, i + j) !== read$$1(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$1.prototype.write = function write$$1 (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$1.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$1.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$1.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$1(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$1(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var require$$0 = /*#__PURE__*/Object.freeze({
		INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
		kMaxLength: _kMaxLength,
		Buffer: Buffer$1,
		SlowBuffer: SlowBuffer,
		isBuffer: isBuffer
	});

	var safeBuffer = createCommonjsModule(function (module, exports) {
	/* eslint-disable node/no-deprecated-api */

	var Buffer = require$$0.Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = require$$0;
	} else {
	  // Copy properties from require('buffer')
	  copyProps(require$$0, exports);
	  exports.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return require$$0.SlowBuffer(size)
	};
	});
	var safeBuffer_1 = safeBuffer.Buffer;

	var browser = createCommonjsModule(function (module) {

	function oldBrowser () {
	  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
	}

	var Buffer = safeBuffer.Buffer;
	var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

	if (crypto && crypto.getRandomValues) {
	  module.exports = randomBytes;
	} else {
	  module.exports = oldBrowser;
	}

	function randomBytes (size, cb) {
	  // phantomjs needs to throw
	  if (size > 65536) throw new Error('requested too many random bytes')
	  // in case browserify  isn't using the Uint8Array version
	  var rawBytes = new commonjsGlobal.Uint8Array(size);

	  // This will not work in older browsers.
	  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	  if (size > 0) {  // getRandomValues fails on IE if size == 0
	    crypto.getRandomValues(rawBytes);
	  }

	  // XXX: phantomjs doesn't like a buffer being passed here
	  var bytes = Buffer.from(rawBytes.buffer);

	  if (typeof cb === 'function') {
	    return process.nextTick(function () {
	      cb(null, bytes);
	    })
	  }

	  return bytes
	}
	});

	var inherits_browser = createCommonjsModule(function (module) {
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	});

	var domain;

	// This constructor is used to store event handlers. Instantiating this is
	// faster than explicitly calling `Object.create(null)` to get a "clean" empty
	// object (tested with v8 v4.9).
	function EventHandlers() {}
	EventHandlers.prototype = Object.create(null);

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}

	// nodejs oddity
	// require('events') === require('events').EventEmitter
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.usingDomains = false;

	EventEmitter.prototype.domain = undefined;
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	EventEmitter.init = function() {
	  this.domain = null;
	  if (EventEmitter.usingDomains) {
	    // if there is an active domain, then attach to it.
	    if (domain.active && !(this instanceof domain.Domain)) ;
	  }

	  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || isNaN(n))
	    throw new TypeError('"n" argument must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
	  if (isFn)
	    handler.call(self);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self);
	  }
	}
	function emitOne(handler, isFn, self, arg1) {
	  if (isFn)
	    handler.call(self, arg1);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1);
	  }
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
	  if (isFn)
	    handler.call(self, arg1, arg2);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2);
	  }
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
	  if (isFn)
	    handler.call(self, arg1, arg2, arg3);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].call(self, arg1, arg2, arg3);
	  }
	}

	function emitMany(handler, isFn, self, args) {
	  if (isFn)
	    handler.apply(self, args);
	  else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      listeners[i].apply(self, args);
	  }
	}

	EventEmitter.prototype.emit = function emit(type) {
	  var er, handler, len, args, i, events, domain;
	  var doError = (type === 'error');

	  events = this._events;
	  if (events)
	    doError = (doError && events.error == null);
	  else if (!doError)
	    return false;

	  domain = this.domain;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    er = arguments[1];
	    if (domain) {
	      if (!er)
	        er = new Error('Uncaught, unspecified "error" event');
	      er.domainEmitter = this;
	      er.domain = domain;
	      er.domainThrown = false;
	      domain.emit('error', er);
	    } else if (er instanceof Error) {
	      throw er; // Unhandled 'error' event
	    } else {
	      // At least give some kind of context to the user
	      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	      err.context = er;
	      throw err;
	    }
	    return false;
	  }

	  handler = events[type];

	  if (!handler)
	    return false;

	  var isFn = typeof handler === 'function';
	  len = arguments.length;
	  switch (len) {
	    // fast cases
	    case 1:
	      emitNone(handler, isFn, this);
	      break;
	    case 2:
	      emitOne(handler, isFn, this, arguments[1]);
	      break;
	    case 3:
	      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
	      break;
	    case 4:
	      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
	      break;
	    // slower
	    default:
	      args = new Array(len - 1);
	      for (i = 1; i < len; i++)
	        args[i - 1] = arguments[i];
	      emitMany(handler, isFn, this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');

	  events = target._events;
	  if (!events) {
	    events = target._events = new EventHandlers();
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (!existing) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] :
	                                          [existing, listener];
	    } else {
	      // If we've already got an array, just append.
	      if (prepend) {
	        existing.unshift(listener);
	      } else {
	        existing.push(listener);
	      }
	    }

	    // Check for listener leak
	    if (!existing.warned) {
	      m = $getMaxListeners(target);
	      if (m && m > 0 && existing.length > m) {
	        existing.warned = true;
	        var w = new Error('Possible EventEmitter memory leak detected. ' +
	                            existing.length + ' ' + type + ' listeners added. ' +
	                            'Use emitter.setMaxListeners() to increase limit');
	        w.name = 'MaxListenersExceededWarning';
	        w.emitter = target;
	        w.type = type;
	        w.count = existing.length;
	        emitWarning(w);
	      }
	    }
	  }

	  return target;
	}
	function emitWarning(e) {
	  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function _onceWrap(target, type, listener) {
	  var fired = false;
	  function g() {
	    target.removeListener(type, g);
	    if (!fired) {
	      fired = true;
	      listener.apply(target, arguments);
	    }
	  }
	  g.listener = listener;
	  return g;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function')
	    throw new TypeError('"listener" argument must be a function');
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      if (typeof listener !== 'function')
	        throw new TypeError('"listener" argument must be a function');

	      events = this._events;
	      if (!events)
	        return this;

	      list = events[type];
	      if (!list)
	        return this;

	      if (list === listener || (list.listener && list.listener === listener)) {
	        if (--this._eventsCount === 0)
	          this._events = new EventHandlers();
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length; i-- > 0;) {
	          if (list[i] === listener ||
	              (list[i].listener && list[i].listener === listener)) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (list.length === 1) {
	          list[0] = undefined;
	          if (--this._eventsCount === 0) {
	            this._events = new EventHandlers();
	            return this;
	          } else {
	            delete events[type];
	          }
	        } else {
	          spliceOne(list, position);
	        }

	        if (events.removeListener)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events;

	      events = this._events;
	      if (!events)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (!events.removeListener) {
	        if (arguments.length === 0) {
	          this._events = new EventHandlers();
	          this._eventsCount = 0;
	        } else if (events[type]) {
	          if (--this._eventsCount === 0)
	            this._events = new EventHandlers();
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        for (var i = 0, key; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = new EventHandlers();
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners) {
	        // LIFO order
	        do {
	          this.removeListener(type, listeners[listeners.length - 1]);
	        } while (listeners[0]);
	      }

	      return this;
	    };

	EventEmitter.prototype.listeners = function listeners(type) {
	  var evlistener;
	  var ret;
	  var events = this._events;

	  if (!events)
	    ret = [];
	  else {
	    evlistener = events[type];
	    if (!evlistener)
	      ret = [];
	    else if (typeof evlistener === 'function')
	      ret = [evlistener.listener || evlistener];
	    else
	      ret = unwrapListeners(evlistener);
	  }

	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};

	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
	    list[i] = list[k];
	  list.pop();
	}

	function arrayClone(arr, i) {
	  var copy = new Array(i);
	  while (i--)
	    copy[i] = arr[i];
	  return copy;
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser$1 = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser$1,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var inherits$1;
	if (typeof Object.create === 'function'){
	  inherits$1 = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits$1 = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$2 = inherits$1;

	// Copyright Joyent, Inc. and other Node contributors.
	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$1(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$1(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}

	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};

	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};

	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};

	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};

	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};

	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return Buffer$1.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = Buffer$1.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

	// Copyright Joyent, Inc. and other Node contributors.
	var isBufferEncoding = Buffer$1.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     };


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	function StringDecoder(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer$1(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	}

	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}

	var stringDecoder = /*#__PURE__*/Object.freeze({
		StringDecoder: StringDecoder
	});

	Readable.ReadableState = ReadableState;

	var debug = debuglog('stream');
	inherits$2(Readable, EventEmitter);

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event])
	      emitter.on(event, fn);
	    else if (Array.isArray(emitter._events[event]))
	      emitter._events[event].unshift(fn);
	    else
	      emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	function listenerCount$1 (emitter, type) {
	  return emitter.listeners(type).length;
	}
	function ReadableState(options, stream) {

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  EventEmitter.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = Buffer.from(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false);

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (listenerCount$1(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && src.listeners('data').length) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = EventEmitter.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	// A bit simpler than readable streams.
	Writable.WritableState = WritableState;
	inherits$2(Writable, EventEmitter);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  Object.defineProperty(this, 'buffer', {
	    get: deprecate(function () {
	      return this.getBuffer();
	    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	  });
	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	function Writable(options) {

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  EventEmitter.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  nextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer$1.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) nextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	        nextTick(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}

	inherits$2(Duplex, Readable);

	var keys = Object.keys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	// a transform stream is a readable/writable stream where you do
	inherits$2(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}

	inherits$2(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	inherits$2(Stream, EventEmitter);
	Stream.Readable = Readable;
	Stream.Writable = Writable;
	Stream.Duplex = Duplex;
	Stream.Transform = Transform;
	Stream.PassThrough = PassThrough;

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;

	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EventEmitter.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EventEmitter.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

	var stream = /*#__PURE__*/Object.freeze({
		default: Stream,
		Readable: Readable,
		Writable: Writable,
		Duplex: Duplex,
		Transform: Transform,
		PassThrough: PassThrough,
		Stream: Stream
	});

	var require$$1 = ( stream && Stream ) || stream;

	var Buffer$2 = safeBuffer.Buffer;
	var Transform$1 = require$$1.Transform;


	function throwIfNotStringOrBuffer (val, prefix) {
	  if (!Buffer$2.isBuffer(val) && typeof val !== 'string') {
	    throw new TypeError(prefix + ' must be a string or a buffer')
	  }
	}

	function HashBase (blockSize) {
	  Transform$1.call(this);

	  this._block = Buffer$2.allocUnsafe(blockSize);
	  this._blockSize = blockSize;
	  this._blockOffset = 0;
	  this._length = [0, 0, 0, 0];

	  this._finalized = false;
	}

	inherits_browser(HashBase, Transform$1);

	HashBase.prototype._transform = function (chunk, encoding, callback) {
	  var error = null;
	  try {
	    this.update(chunk, encoding);
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase.prototype._flush = function (callback) {
	  var error = null;
	  try {
	    this.push(this.digest());
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase.prototype.update = function (data, encoding) {
	  throwIfNotStringOrBuffer(data, 'Data');
	  if (this._finalized) throw new Error('Digest already called')
	  if (!Buffer$2.isBuffer(data)) data = Buffer$2.from(data, encoding);

	  // consume data
	  var block = this._block;
	  var offset = 0;
	  while (this._blockOffset + data.length - offset >= this._blockSize) {
	    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
	    this._update();
	    this._blockOffset = 0;
	  }
	  while (offset < data.length) block[this._blockOffset++] = data[offset++];

	  // update length
	  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
	    this._length[j] += carry;
	    carry = (this._length[j] / 0x0100000000) | 0;
	    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
	  }

	  return this
	};

	HashBase.prototype._update = function () {
	  throw new Error('_update is not implemented')
	};

	HashBase.prototype.digest = function (encoding) {
	  if (this._finalized) throw new Error('Digest already called')
	  this._finalized = true;

	  var digest = this._digest();
	  if (encoding !== undefined) digest = digest.toString(encoding);

	  // reset state
	  this._block.fill(0);
	  this._blockOffset = 0;
	  for (var i = 0; i < 4; ++i) this._length[i] = 0;

	  return digest
	};

	HashBase.prototype._digest = function () {
	  throw new Error('_digest is not implemented')
	};

	var hashBase = HashBase;

	var ARRAY16 = new Array(16);

	function MD5 () {
	  hashBase.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	}

	inherits_browser(MD5, hashBase);

	MD5.prototype._update = function () {
	  var M = ARRAY16;
	  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

	  var a = this._a;
	  var b = this._b;
	  var c = this._c;
	  var d = this._d;

	  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
	  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
	  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
	  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
	  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
	  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
	  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
	  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
	  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
	  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
	  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
	  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
	  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
	  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
	  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
	  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

	  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
	  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
	  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
	  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
	  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
	  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
	  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
	  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
	  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
	  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
	  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
	  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
	  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
	  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
	  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
	  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

	  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
	  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
	  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
	  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
	  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
	  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
	  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
	  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
	  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
	  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
	  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
	  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
	  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
	  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
	  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
	  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

	  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
	  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
	  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
	  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
	  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
	  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
	  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
	  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
	  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
	  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
	  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
	  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
	  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
	  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
	  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
	  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

	  this._a = (this._a + a) | 0;
	  this._b = (this._b + b) | 0;
	  this._c = (this._c + c) | 0;
	  this._d = (this._d + d) | 0;
	};

	MD5.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = new Buffer(16);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  return buffer
	};

	function rotl (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fnF (a, b, c, d, m, k, s) {
	  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
	}

	function fnG (a, b, c, d, m, k, s) {
	  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
	}

	function fnH (a, b, c, d, m, k, s) {
	  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
	}

	function fnI (a, b, c, d, m, k, s) {
	  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
	}

	var md5_js = MD5;

	var Buffer$3 = require$$0.Buffer;



	var ARRAY16$1 = new Array(16);

	var zl = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var zr = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var sl = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sr = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
	var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

	function RIPEMD160 () {
	  hashBase.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;
	}

	inherits_browser(RIPEMD160, hashBase);

	RIPEMD160.prototype._update = function () {
	  var words = ARRAY16$1;
	  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

	  var al = this._a | 0;
	  var bl = this._b | 0;
	  var cl = this._c | 0;
	  var dl = this._d | 0;
	  var el = this._e | 0;

	  var ar = this._a | 0;
	  var br = this._b | 0;
	  var cr = this._c | 0;
	  var dr = this._d | 0;
	  var er = this._e | 0;

	  // computation
	  for (var i = 0; i < 80; i += 1) {
	    var tl;
	    var tr;
	    if (i < 16) {
	      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
	      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
	    } else if (i < 32) {
	      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
	      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
	    } else if (i < 48) {
	      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
	      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
	    } else if (i < 64) {
	      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
	      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
	    } else { // if (i<80) {
	      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
	      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
	    }

	    al = el;
	    el = dl;
	    dl = rotl$1(cl, 10);
	    cl = bl;
	    bl = tl;

	    ar = er;
	    er = dr;
	    dr = rotl$1(cr, 10);
	    cr = br;
	    br = tr;
	  }

	  // update state
	  var t = (this._b + cl + dr) | 0;
	  this._b = (this._c + dl + er) | 0;
	  this._c = (this._d + el + ar) | 0;
	  this._d = (this._e + al + br) | 0;
	  this._e = (this._a + bl + cr) | 0;
	  this._a = t;
	};

	RIPEMD160.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = Buffer$3.alloc ? Buffer$3.alloc(20) : new Buffer$3(20);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  buffer.writeInt32LE(this._e, 16);
	  return buffer
	};

	function rotl$1 (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fn1 (a, b, c, d, e, m, k, s) {
	  return (rotl$1((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn2 (a, b, c, d, e, m, k, s) {
	  return (rotl$1((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
	}

	function fn3 (a, b, c, d, e, m, k, s) {
	  return (rotl$1((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn4 (a, b, c, d, e, m, k, s) {
	  return (rotl$1((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
	}

	function fn5 (a, b, c, d, e, m, k, s) {
	  return (rotl$1((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
	}

	var ripemd160 = RIPEMD160;

	var Buffer$4 = safeBuffer.Buffer;

	// prototype class for hash functions
	function Hash (blockSize, finalSize) {
	  this._block = Buffer$4.alloc(blockSize);
	  this._finalSize = finalSize;
	  this._blockSize = blockSize;
	  this._len = 0;
	}

	Hash.prototype.update = function (data, enc) {
	  if (typeof data === 'string') {
	    enc = enc || 'utf8';
	    data = Buffer$4.from(data, enc);
	  }

	  var block = this._block;
	  var blockSize = this._blockSize;
	  var length = data.length;
	  var accum = this._len;

	  for (var offset = 0; offset < length;) {
	    var assigned = accum % blockSize;
	    var remainder = Math.min(length - offset, blockSize - assigned);

	    for (var i = 0; i < remainder; i++) {
	      block[assigned + i] = data[offset + i];
	    }

	    accum += remainder;
	    offset += remainder;

	    if ((accum % blockSize) === 0) {
	      this._update(block);
	    }
	  }

	  this._len += length;
	  return this
	};

	Hash.prototype.digest = function (enc) {
	  var rem = this._len % this._blockSize;

	  this._block[rem] = 0x80;

	  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	  this._block.fill(0, rem + 1);

	  if (rem >= this._finalSize) {
	    this._update(this._block);
	    this._block.fill(0);
	  }

	  var bits = this._len * 8;

	  // uint32
	  if (bits <= 0xffffffff) {
	    this._block.writeUInt32BE(bits, this._blockSize - 4);

	  // uint64
	  } else {
	    var lowBits = (bits & 0xffffffff) >>> 0;
	    var highBits = (bits - lowBits) / 0x100000000;

	    this._block.writeUInt32BE(highBits, this._blockSize - 8);
	    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
	  }

	  this._update(this._block);
	  var hash = this._hash();

	  return enc ? hash.toString(enc) : hash
	};

	Hash.prototype._update = function () {
	  throw new Error('_update must be implemented by subclass')
	};

	var hash = Hash;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
	 * in FIPS PUB 180-1
	 * This source code is derived from sha1.js of the same repository.
	 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
	 * operation was added.
	 */



	var Buffer$5 = safeBuffer.Buffer;

	var K = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha () {
	  this.init();
	  this._w = W;

	  hash.call(this, 64, 56);
	}

	inherits_browser(Sha, hash);

	Sha.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha.prototype._hash = function () {
	  var H = Buffer$5.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	var sha = Sha;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */



	var Buffer$6 = safeBuffer.Buffer;

	var K$1 = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W$1 = new Array(80);

	function Sha1 () {
	  this.init();
	  this._w = W$1;

	  hash.call(this, 64, 56);
	}

	inherits_browser(Sha1, hash);

	Sha1.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl1 (num) {
	  return (num << 1) | (num >>> 31)
	}

	function rotl5$1 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30$1 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft$1 (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha1.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$1[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30$1(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha1.prototype._hash = function () {
	  var H = Buffer$6.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	var sha1 = Sha1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */



	var Buffer$7 = safeBuffer.Buffer;

	var K$2 = [
	  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	];

	var W$2 = new Array(64);

	function Sha256 () {
	  this.init();

	  this._w = W$2; // new Array(64)

	  hash.call(this, 64, 56);
	}

	inherits_browser(Sha256, hash);

	Sha256.prototype.init = function () {
	  this._a = 0x6a09e667;
	  this._b = 0xbb67ae85;
	  this._c = 0x3c6ef372;
	  this._d = 0xa54ff53a;
	  this._e = 0x510e527f;
	  this._f = 0x9b05688c;
	  this._g = 0x1f83d9ab;
	  this._h = 0x5be0cd19;

	  return this
	};

	function ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
	}

	function sigma1 (x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
	}

	function gamma0 (x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
	}

	function gamma1 (x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
	}

	Sha256.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;
	  var f = this._f | 0;
	  var g = this._g | 0;
	  var h = this._h | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

	  for (var j = 0; j < 64; ++j) {
	    var T1 = (h + sigma1(e) + ch(e, f, g) + K$2[j] + W[j]) | 0;
	    var T2 = (sigma0(a) + maj(a, b, c)) | 0;

	    h = g;
	    g = f;
	    f = e;
	    e = (d + T1) | 0;
	    d = c;
	    c = b;
	    b = a;
	    a = (T1 + T2) | 0;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	  this._f = (f + this._f) | 0;
	  this._g = (g + this._g) | 0;
	  this._h = (h + this._h) | 0;
	};

	Sha256.prototype._hash = function () {
	  var H = Buffer$7.allocUnsafe(32);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);
	  H.writeInt32BE(this._h, 28);

	  return H
	};

	var sha256 = Sha256;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */




	var Buffer$8 = safeBuffer.Buffer;

	var W$3 = new Array(64);

	function Sha224 () {
	  this.init();

	  this._w = W$3; // new Array(64)

	  hash.call(this, 64, 56);
	}

	inherits_browser(Sha224, sha256);

	Sha224.prototype.init = function () {
	  this._a = 0xc1059ed8;
	  this._b = 0x367cd507;
	  this._c = 0x3070dd17;
	  this._d = 0xf70e5939;
	  this._e = 0xffc00b31;
	  this._f = 0x68581511;
	  this._g = 0x64f98fa7;
	  this._h = 0xbefa4fa4;

	  return this
	};

	Sha224.prototype._hash = function () {
	  var H = Buffer$8.allocUnsafe(28);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);

	  return H
	};

	var sha224 = Sha224;

	var Buffer$9 = safeBuffer.Buffer;

	var K$3 = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	var W$4 = new Array(160);

	function Sha512 () {
	  this.init();
	  this._w = W$4;

	  hash.call(this, 128, 112);
	}

	inherits_browser(Sha512, hash);

	Sha512.prototype.init = function () {
	  this._ah = 0x6a09e667;
	  this._bh = 0xbb67ae85;
	  this._ch = 0x3c6ef372;
	  this._dh = 0xa54ff53a;
	  this._eh = 0x510e527f;
	  this._fh = 0x9b05688c;
	  this._gh = 0x1f83d9ab;
	  this._hh = 0x5be0cd19;

	  this._al = 0xf3bcc908;
	  this._bl = 0x84caa73b;
	  this._cl = 0xfe94f82b;
	  this._dl = 0x5f1d36f1;
	  this._el = 0xade682d1;
	  this._fl = 0x2b3e6c1f;
	  this._gl = 0xfb41bd6b;
	  this._hl = 0x137e2179;

	  return this
	};

	function Ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj$1 (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0$1 (x, xl) {
	  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
	}

	function sigma1$1 (x, xl) {
	  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
	}

	function Gamma0 (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
	}

	function Gamma0l (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
	}

	function Gamma1 (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
	}

	function Gamma1l (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
	}

	function getCarry (a, b) {
	  return (a >>> 0) < (b >>> 0) ? 1 : 0
	}

	Sha512.prototype._update = function (M) {
	  var W = this._w;

	  var ah = this._ah | 0;
	  var bh = this._bh | 0;
	  var ch = this._ch | 0;
	  var dh = this._dh | 0;
	  var eh = this._eh | 0;
	  var fh = this._fh | 0;
	  var gh = this._gh | 0;
	  var hh = this._hh | 0;

	  var al = this._al | 0;
	  var bl = this._bl | 0;
	  var cl = this._cl | 0;
	  var dl = this._dl | 0;
	  var el = this._el | 0;
	  var fl = this._fl | 0;
	  var gl = this._gl | 0;
	  var hl = this._hl | 0;

	  for (var i = 0; i < 32; i += 2) {
	    W[i] = M.readInt32BE(i * 4);
	    W[i + 1] = M.readInt32BE(i * 4 + 4);
	  }
	  for (; i < 160; i += 2) {
	    var xh = W[i - 15 * 2];
	    var xl = W[i - 15 * 2 + 1];
	    var gamma0 = Gamma0(xh, xl);
	    var gamma0l = Gamma0l(xl, xh);

	    xh = W[i - 2 * 2];
	    xl = W[i - 2 * 2 + 1];
	    var gamma1 = Gamma1(xh, xl);
	    var gamma1l = Gamma1l(xl, xh);

	    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	    var Wi7h = W[i - 7 * 2];
	    var Wi7l = W[i - 7 * 2 + 1];

	    var Wi16h = W[i - 16 * 2];
	    var Wi16l = W[i - 16 * 2 + 1];

	    var Wil = (gamma0l + Wi7l) | 0;
	    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
	    Wil = (Wil + gamma1l) | 0;
	    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
	    Wil = (Wil + Wi16l) | 0;
	    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

	    W[i] = Wih;
	    W[i + 1] = Wil;
	  }

	  for (var j = 0; j < 160; j += 2) {
	    Wih = W[j];
	    Wil = W[j + 1];

	    var majh = maj$1(ah, bh, ch);
	    var majl = maj$1(al, bl, cl);

	    var sigma0h = sigma0$1(ah, al);
	    var sigma0l = sigma0$1(al, ah);
	    var sigma1h = sigma1$1(eh, el);
	    var sigma1l = sigma1$1(el, eh);

	    // t1 = h + sigma1 + ch + K[j] + W[j]
	    var Kih = K$3[j];
	    var Kil = K$3[j + 1];

	    var chh = Ch(eh, fh, gh);
	    var chl = Ch(el, fl, gl);

	    var t1l = (hl + sigma1l) | 0;
	    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
	    t1l = (t1l + chl) | 0;
	    t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
	    t1l = (t1l + Kil) | 0;
	    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
	    t1l = (t1l + Wil) | 0;
	    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

	    // t2 = sigma0 + maj
	    var t2l = (sigma0l + majl) | 0;
	    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

	    hh = gh;
	    hl = gl;
	    gh = fh;
	    gl = fl;
	    fh = eh;
	    fl = el;
	    el = (dl + t1l) | 0;
	    eh = (dh + t1h + getCarry(el, dl)) | 0;
	    dh = ch;
	    dl = cl;
	    ch = bh;
	    cl = bl;
	    bh = ah;
	    bl = al;
	    al = (t1l + t2l) | 0;
	    ah = (t1h + t2h + getCarry(al, t1l)) | 0;
	  }

	  this._al = (this._al + al) | 0;
	  this._bl = (this._bl + bl) | 0;
	  this._cl = (this._cl + cl) | 0;
	  this._dl = (this._dl + dl) | 0;
	  this._el = (this._el + el) | 0;
	  this._fl = (this._fl + fl) | 0;
	  this._gl = (this._gl + gl) | 0;
	  this._hl = (this._hl + hl) | 0;

	  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
	  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
	  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
	  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
	  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
	  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
	  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
	  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
	};

	Sha512.prototype._hash = function () {
	  var H = Buffer$9.allocUnsafe(64);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);
	  writeInt64BE(this._gh, this._gl, 48);
	  writeInt64BE(this._hh, this._hl, 56);

	  return H
	};

	var sha512 = Sha512;

	var Buffer$a = safeBuffer.Buffer;

	var W$5 = new Array(160);

	function Sha384 () {
	  this.init();
	  this._w = W$5;

	  hash.call(this, 128, 112);
	}

	inherits_browser(Sha384, sha512);

	Sha384.prototype.init = function () {
	  this._ah = 0xcbbb9d5d;
	  this._bh = 0x629a292a;
	  this._ch = 0x9159015a;
	  this._dh = 0x152fecd8;
	  this._eh = 0x67332667;
	  this._fh = 0x8eb44a87;
	  this._gh = 0xdb0c2e0d;
	  this._hh = 0x47b5481d;

	  this._al = 0xc1059ed8;
	  this._bl = 0x367cd507;
	  this._cl = 0x3070dd17;
	  this._dl = 0xf70e5939;
	  this._el = 0xffc00b31;
	  this._fl = 0x68581511;
	  this._gl = 0x64f98fa7;
	  this._hl = 0xbefa4fa4;

	  return this
	};

	Sha384.prototype._hash = function () {
	  var H = Buffer$a.allocUnsafe(48);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);

	  return H
	};

	var sha384 = Sha384;

	var sha_js = createCommonjsModule(function (module) {
	var exports = module.exports = function SHA (algorithm) {
	  algorithm = algorithm.toLowerCase();

	  var Algorithm = exports[algorithm];
	  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

	  return new Algorithm()
	};

	exports.sha = sha;
	exports.sha1 = sha1;
	exports.sha224 = sha224;
	exports.sha256 = sha256;
	exports.sha384 = sha384;
	exports.sha512 = sha512;
	});

	var Buffer$b = safeBuffer.Buffer;
	var Transform$2 = require$$1.Transform;
	var StringDecoder$1 = stringDecoder.StringDecoder;


	function CipherBase (hashMode) {
	  Transform$2.call(this);
	  this.hashMode = typeof hashMode === 'string';
	  if (this.hashMode) {
	    this[hashMode] = this._finalOrDigest;
	  } else {
	    this.final = this._finalOrDigest;
	  }
	  if (this._final) {
	    this.__final = this._final;
	    this._final = null;
	  }
	  this._decoder = null;
	  this._encoding = null;
	}
	inherits_browser(CipherBase, Transform$2);

	CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	  if (typeof data === 'string') {
	    data = Buffer$b.from(data, inputEnc);
	  }

	  var outData = this._update(data);
	  if (this.hashMode) return this

	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc);
	  }

	  return outData
	};

	CipherBase.prototype.setAutoPadding = function () {};
	CipherBase.prototype.getAuthTag = function () {
	  throw new Error('trying to get auth tag in unsupported state')
	};

	CipherBase.prototype.setAuthTag = function () {
	  throw new Error('trying to set auth tag in unsupported state')
	};

	CipherBase.prototype.setAAD = function () {
	  throw new Error('trying to set aad in unsupported state')
	};

	CipherBase.prototype._transform = function (data, _, next) {
	  var err;
	  try {
	    if (this.hashMode) {
	      this._update(data);
	    } else {
	      this.push(this._update(data));
	    }
	  } catch (e) {
	    err = e;
	  } finally {
	    next(err);
	  }
	};
	CipherBase.prototype._flush = function (done) {
	  var err;
	  try {
	    this.push(this.__final());
	  } catch (e) {
	    err = e;
	  }

	  done(err);
	};
	CipherBase.prototype._finalOrDigest = function (outputEnc) {
	  var outData = this.__final() || Buffer$b.alloc(0);
	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc, true);
	  }
	  return outData
	};

	CipherBase.prototype._toString = function (value, enc, fin) {
	  if (!this._decoder) {
	    this._decoder = new StringDecoder$1(enc);
	    this._encoding = enc;
	  }

	  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

	  var out = this._decoder.write(value);
	  if (fin) {
	    out += this._decoder.end();
	  }

	  return out
	};

	var cipherBase = CipherBase;

	function Hash$1 (hash) {
	  cipherBase.call(this, 'digest');

	  this._hash = hash;
	}

	inherits_browser(Hash$1, cipherBase);

	Hash$1.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hash$1.prototype._final = function () {
	  return this._hash.digest()
	};

	var browser$2 = function createHash (alg) {
	  alg = alg.toLowerCase();
	  if (alg === 'md5') return new md5_js()
	  if (alg === 'rmd160' || alg === 'ripemd160') return new ripemd160()

	  return new Hash$1(sha_js(alg))
	};

	var Buffer$c = safeBuffer.Buffer;



	var ZEROS = Buffer$c.alloc(128);
	var blocksize = 64;

	function Hmac (alg, key) {
	  cipherBase.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer$c.from(key);
	  }

	  this._alg = alg;
	  this._key = key;

	  if (key.length > blocksize) {
	    key = alg(key);
	  } else if (key.length < blocksize) {
	    key = Buffer$c.concat([key, ZEROS], blocksize);
	  }

	  var ipad = this._ipad = Buffer$c.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer$c.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  this._hash = [ipad];
	}

	inherits_browser(Hmac, cipherBase);

	Hmac.prototype._update = function (data) {
	  this._hash.push(data);
	};

	Hmac.prototype._final = function () {
	  var h = this._alg(Buffer$c.concat(this._hash));
	  return this._alg(Buffer$c.concat([this._opad, h]))
	};
	var legacy = Hmac;

	var md5 = function (buffer) {
	  return new md5_js().update(buffer).digest()
	};

	var Buffer$d = safeBuffer.Buffer;





	var ZEROS$1 = Buffer$d.alloc(128);

	function Hmac$1 (alg, key) {
	  cipherBase.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer$d.from(key);
	  }

	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  this._alg = alg;
	  this._key = key;
	  if (key.length > blocksize) {
	    var hash = alg === 'rmd160' ? new ripemd160() : sha_js(alg);
	    key = hash.update(key).digest();
	  } else if (key.length < blocksize) {
	    key = Buffer$d.concat([key, ZEROS$1], blocksize);
	  }

	  var ipad = this._ipad = Buffer$d.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer$d.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }
	  this._hash = alg === 'rmd160' ? new ripemd160() : sha_js(alg);
	  this._hash.update(ipad);
	}

	inherits_browser(Hmac$1, cipherBase);

	Hmac$1.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hmac$1.prototype._final = function () {
	  var h = this._hash.digest();
	  var hash = this._alg === 'rmd160' ? new ripemd160() : sha_js(this._alg);
	  return hash.update(this._opad).update(h).digest()
	};

	var browser$3 = function createHmac (alg, key) {
	  alg = alg.toLowerCase();
	  if (alg === 'rmd160' || alg === 'ripemd160') {
	    return new Hmac$1('rmd160', key)
	  }
	  if (alg === 'md5') {
	    return new legacy(md5, key)
	  }
	  return new Hmac$1(alg, key)
	};

	var sha224WithRSAEncryption = {
		sign: "rsa",
		hash: "sha224",
		id: "302d300d06096086480165030402040500041c"
	};
	var sha256WithRSAEncryption = {
		sign: "rsa",
		hash: "sha256",
		id: "3031300d060960864801650304020105000420"
	};
	var sha384WithRSAEncryption = {
		sign: "rsa",
		hash: "sha384",
		id: "3041300d060960864801650304020205000430"
	};
	var sha512WithRSAEncryption = {
		sign: "rsa",
		hash: "sha512",
		id: "3051300d060960864801650304020305000440"
	};
	var sha256$1 = {
		sign: "ecdsa",
		hash: "sha256",
		id: ""
	};
	var sha224$1 = {
		sign: "ecdsa",
		hash: "sha224",
		id: ""
	};
	var sha384$1 = {
		sign: "ecdsa",
		hash: "sha384",
		id: ""
	};
	var sha512$1 = {
		sign: "ecdsa",
		hash: "sha512",
		id: ""
	};
	var DSA = {
		sign: "dsa",
		hash: "sha1",
		id: ""
	};
	var ripemd160WithRSA = {
		sign: "rsa",
		hash: "rmd160",
		id: "3021300906052b2403020105000414"
	};
	var md5WithRSAEncryption = {
		sign: "rsa",
		hash: "md5",
		id: "3020300c06082a864886f70d020505000410"
	};
	var algorithms = {
		sha224WithRSAEncryption: sha224WithRSAEncryption,
		"RSA-SHA224": {
		sign: "ecdsa/rsa",
		hash: "sha224",
		id: "302d300d06096086480165030402040500041c"
	},
		sha256WithRSAEncryption: sha256WithRSAEncryption,
		"RSA-SHA256": {
		sign: "ecdsa/rsa",
		hash: "sha256",
		id: "3031300d060960864801650304020105000420"
	},
		sha384WithRSAEncryption: sha384WithRSAEncryption,
		"RSA-SHA384": {
		sign: "ecdsa/rsa",
		hash: "sha384",
		id: "3041300d060960864801650304020205000430"
	},
		sha512WithRSAEncryption: sha512WithRSAEncryption,
		"RSA-SHA512": {
		sign: "ecdsa/rsa",
		hash: "sha512",
		id: "3051300d060960864801650304020305000440"
	},
		"RSA-SHA1": {
		sign: "rsa",
		hash: "sha1",
		id: "3021300906052b0e03021a05000414"
	},
		"ecdsa-with-SHA1": {
		sign: "ecdsa",
		hash: "sha1",
		id: ""
	},
		sha256: sha256$1,
		sha224: sha224$1,
		sha384: sha384$1,
		sha512: sha512$1,
		"DSA-SHA": {
		sign: "dsa",
		hash: "sha1",
		id: ""
	},
		"DSA-SHA1": {
		sign: "dsa",
		hash: "sha1",
		id: ""
	},
		DSA: DSA,
		"DSA-WITH-SHA224": {
		sign: "dsa",
		hash: "sha224",
		id: ""
	},
		"DSA-SHA224": {
		sign: "dsa",
		hash: "sha224",
		id: ""
	},
		"DSA-WITH-SHA256": {
		sign: "dsa",
		hash: "sha256",
		id: ""
	},
		"DSA-SHA256": {
		sign: "dsa",
		hash: "sha256",
		id: ""
	},
		"DSA-WITH-SHA384": {
		sign: "dsa",
		hash: "sha384",
		id: ""
	},
		"DSA-SHA384": {
		sign: "dsa",
		hash: "sha384",
		id: ""
	},
		"DSA-WITH-SHA512": {
		sign: "dsa",
		hash: "sha512",
		id: ""
	},
		"DSA-SHA512": {
		sign: "dsa",
		hash: "sha512",
		id: ""
	},
		"DSA-RIPEMD160": {
		sign: "dsa",
		hash: "rmd160",
		id: ""
	},
		ripemd160WithRSA: ripemd160WithRSA,
		"RSA-RIPEMD160": {
		sign: "rsa",
		hash: "rmd160",
		id: "3021300906052b2403020105000414"
	},
		md5WithRSAEncryption: md5WithRSAEncryption,
		"RSA-MD5": {
		sign: "rsa",
		hash: "md5",
		id: "3020300c06082a864886f70d020505000410"
	}
	};

	var algorithms$1 = /*#__PURE__*/Object.freeze({
		sha224WithRSAEncryption: sha224WithRSAEncryption,
		sha256WithRSAEncryption: sha256WithRSAEncryption,
		sha384WithRSAEncryption: sha384WithRSAEncryption,
		sha512WithRSAEncryption: sha512WithRSAEncryption,
		sha256: sha256$1,
		sha224: sha224$1,
		sha384: sha384$1,
		sha512: sha512$1,
		DSA: DSA,
		ripemd160WithRSA: ripemd160WithRSA,
		md5WithRSAEncryption: md5WithRSAEncryption,
		default: algorithms
	});

	var algorithms$2 = ( algorithms$1 && algorithms ) || algorithms$1;

	var algos = algorithms$2;

	var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

	function checkBuffer (buf, name) {
	  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
	    throw new TypeError(name + ' must be a buffer or string')
	  }
	}

	var precondition = function (password, salt, iterations, keylen) {
	  checkBuffer(password, 'Password');
	  checkBuffer(salt, 'Salt');

	  if (typeof iterations !== 'number') {
	    throw new TypeError('Iterations not a number')
	  }

	  if (iterations < 0) {
	    throw new TypeError('Bad iterations')
	  }

	  if (typeof keylen !== 'number') {
	    throw new TypeError('Key length not a number')
	  }

	  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
	    throw new TypeError('Bad key length')
	  }
	};

	var defaultEncoding;
	/* istanbul ignore next */
	if (process.browser) {
	  defaultEncoding = 'utf-8';
	} else {
	  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

	  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
	}
	var defaultEncoding_1 = defaultEncoding;

	var Buffer$e = safeBuffer.Buffer;

	var Buffer$f = safeBuffer.Buffer;
	var ZEROS$2 = Buffer$f.alloc(128);
	var sizes$1 = {
	  md5: 16,
	  sha1: 20,
	  sha224: 28,
	  sha256: 32,
	  sha384: 48,
	  sha512: 64,
	  rmd160: 20,
	  ripemd160: 20
	};

	function Hmac$2 (alg, key, saltLen) {
	  var hash = getDigest(alg);
	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  if (key.length > blocksize) {
	    key = hash(key);
	  } else if (key.length < blocksize) {
	    key = Buffer$f.concat([key, ZEROS$2], blocksize);
	  }

	  var ipad = Buffer$f.allocUnsafe(blocksize + sizes$1[alg]);
	  var opad = Buffer$f.allocUnsafe(blocksize + sizes$1[alg]);
	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  var ipad1 = Buffer$f.allocUnsafe(blocksize + saltLen + 4);
	  ipad.copy(ipad1, 0, 0, blocksize);
	  this.ipad1 = ipad1;
	  this.ipad2 = ipad;
	  this.opad = opad;
	  this.alg = alg;
	  this.blocksize = blocksize;
	  this.hash = hash;
	  this.size = sizes$1[alg];
	}

	Hmac$2.prototype.run = function (data, ipad) {
	  data.copy(ipad, this.blocksize);
	  var h = this.hash(ipad);
	  h.copy(this.opad, this.blocksize);
	  return this.hash(this.opad)
	};

	function getDigest (alg) {
	  function shaFunc (data) {
	    return sha_js(alg).update(data).digest()
	  }

	  if (alg === 'rmd160' || alg === 'ripemd160') return ripemd160
	  if (alg === 'md5') return md5
	  return shaFunc
	}

	function pbkdf2$1 (password, salt, iterations, keylen, digest) {
	  precondition(password, salt, iterations, keylen);

	  if (!Buffer$f.isBuffer(password)) password = Buffer$f.from(password, defaultEncoding_1);
	  if (!Buffer$f.isBuffer(salt)) salt = Buffer$f.from(salt, defaultEncoding_1);

	  digest = digest || 'sha1';

	  var hmac = new Hmac$2(digest, password, salt.length);

	  var DK = Buffer$f.allocUnsafe(keylen);
	  var block1 = Buffer$f.allocUnsafe(salt.length + 4);
	  salt.copy(block1, 0, 0, salt.length);

	  var destPos = 0;
	  var hLen = sizes$1[digest];
	  var l = Math.ceil(keylen / hLen);

	  for (var i = 1; i <= l; i++) {
	    block1.writeUInt32BE(i, salt.length);

	    var T = hmac.run(block1, hmac.ipad1);
	    var U = T;

	    for (var j = 1; j < iterations; j++) {
	      U = hmac.run(U, hmac.ipad2);
	      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
	    }

	    T.copy(DK, destPos);
	    destPos += hLen;
	  }

	  return DK
	}

	var syncBrowser = pbkdf2$1;

	var Buffer$g = safeBuffer.Buffer;

	var ZERO_BUF;
	var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
	var toBrowser = {
	  'sha': 'SHA-1',
	  'sha-1': 'SHA-1',
	  'sha1': 'SHA-1',
	  'sha256': 'SHA-256',
	  'sha-256': 'SHA-256',
	  'sha384': 'SHA-384',
	  'sha-384': 'SHA-384',
	  'sha-512': 'SHA-512',
	  'sha512': 'SHA-512'
	};
	var checks = [];
	function checkNative (algo) {
	  if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
	    return Promise.resolve(false)
	  }
	  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
	    return Promise.resolve(false)
	  }
	  if (checks[algo] !== undefined) {
	    return checks[algo]
	  }
	  ZERO_BUF = ZERO_BUF || Buffer$g.alloc(8);
	  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
	    .then(function () {
	      return true
	    }).catch(function () {
	      return false
	    });
	  checks[algo] = prom;
	  return prom
	}

	function browserPbkdf2 (password, salt, iterations, length, algo) {
	  return subtle.importKey(
	    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
	  ).then(function (key) {
	    return subtle.deriveBits({
	      name: 'PBKDF2',
	      salt: salt,
	      iterations: iterations,
	      hash: {
	        name: algo
	      }
	    }, key, length << 3)
	  }).then(function (res) {
	    return Buffer$g.from(res)
	  })
	}

	function resolvePromise (promise, callback) {
	  promise.then(function (out) {
	    process.nextTick(function () {
	      callback(null, out);
	    });
	  }, function (e) {
	    process.nextTick(function () {
	      callback(e);
	    });
	  });
	}
	var async = function (password, salt, iterations, keylen, digest, callback) {
	  if (typeof digest === 'function') {
	    callback = digest;
	    digest = undefined;
	  }

	  digest = digest || 'sha1';
	  var algo = toBrowser[digest.toLowerCase()];

	  if (!algo || typeof commonjsGlobal.Promise !== 'function') {
	    return process.nextTick(function () {
	      var out;
	      try {
	        out = syncBrowser(password, salt, iterations, keylen, digest);
	      } catch (e) {
	        return callback(e)
	      }
	      callback(null, out);
	    })
	  }

	  precondition(password, salt, iterations, keylen);
	  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
	  if (!Buffer$g.isBuffer(password)) password = Buffer$g.from(password, defaultEncoding_1);
	  if (!Buffer$g.isBuffer(salt)) salt = Buffer$g.from(salt, defaultEncoding_1);

	  resolvePromise(checkNative(algo).then(function (resp) {
	    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

	    return syncBrowser(password, salt, iterations, keylen, digest)
	  }), callback);
	};

	var pbkdf2$2 = async;
	var pbkdf2Sync = syncBrowser;

	var browser$4 = {
		pbkdf2: pbkdf2$2,
		pbkdf2Sync: pbkdf2Sync
	};

	var readUInt32BE = function readUInt32BE(bytes, off) {
	  var res =  (bytes[0 + off] << 24) |
	             (bytes[1 + off] << 16) |
	             (bytes[2 + off] << 8) |
	             bytes[3 + off];
	  return res >>> 0;
	};

	var writeUInt32BE = function writeUInt32BE(bytes, value, off) {
	  bytes[0 + off] = value >>> 24;
	  bytes[1 + off] = (value >>> 16) & 0xff;
	  bytes[2 + off] = (value >>> 8) & 0xff;
	  bytes[3 + off] = value & 0xff;
	};

	var ip = function ip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var rip = function rip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 0; i < 4; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }
	  for (var i = 4; i < 8; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var pc1 = function pc1(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  // 7, 15, 23, 31, 39, 47, 55, 63
	  // 6, 14, 22, 30, 39, 47, 55, 63
	  // 5, 13, 21, 29, 39, 47, 55, 63
	  // 4, 12, 20, 28
	  for (var i = 7; i >= 5; i--) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outL <<= 1;
	    outL |= (inR >> (j + i)) & 1;
	  }

	  // 1, 9, 17, 25, 33, 41, 49, 57
	  // 2, 10, 18, 26, 34, 42, 50, 58
	  // 3, 11, 19, 27, 35, 43, 51, 59
	  // 36, 44, 52, 60
	  for (var i = 1; i <= 3; i++) {
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outR <<= 1;
	    outR |= (inL >> (j + i)) & 1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var r28shl = function r28shl(num, shift) {
	  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
	};

	var pc2table = [
	  // inL => outL
	  14, 11, 17, 4, 27, 23, 25, 0,
	  13, 22, 7, 18, 5, 9, 16, 24,
	  2, 20, 12, 21, 1, 8, 15, 26,

	  // inR => outR
	  15, 4, 25, 19, 9, 1, 26, 16,
	  5, 11, 23, 8, 12, 7, 17, 0,
	  22, 3, 10, 14, 6, 20, 27, 24
	];

	var pc2 = function pc2(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  var len = pc2table.length >>> 1;
	  for (var i = 0; i < len; i++) {
	    outL <<= 1;
	    outL |= (inL >>> pc2table[i]) & 0x1;
	  }
	  for (var i = len; i < pc2table.length; i++) {
	    outR <<= 1;
	    outR |= (inR >>> pc2table[i]) & 0x1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var expand = function expand(r, out, off) {
	  var outL = 0;
	  var outR = 0;

	  outL = ((r & 1) << 5) | (r >>> 27);
	  for (var i = 23; i >= 15; i -= 4) {
	    outL <<= 6;
	    outL |= (r >>> i) & 0x3f;
	  }
	  for (var i = 11; i >= 3; i -= 4) {
	    outR |= (r >>> i) & 0x3f;
	    outR <<= 6;
	  }
	  outR |= ((r & 0x1f) << 1) | (r >>> 31);

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var sTable = [
	  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
	  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
	  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
	  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

	  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
	  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
	  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
	  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

	  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
	  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
	  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
	  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

	  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
	  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
	  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
	  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

	  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
	  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
	  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
	  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

	  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
	  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
	  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
	  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

	  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
	  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
	  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
	  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

	  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
	  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
	  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
	  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
	];

	var substitute = function substitute(inL, inR) {
	  var out = 0;
	  for (var i = 0; i < 4; i++) {
	    var b = (inL >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  for (var i = 0; i < 4; i++) {
	    var b = (inR >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[4 * 0x40 + i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  return out >>> 0;
	};

	var permuteTable = [
	  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
	  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
	];

	var permute = function permute(num) {
	  var out = 0;
	  for (var i = 0; i < permuteTable.length; i++) {
	    out <<= 1;
	    out |= (num >>> permuteTable[i]) & 0x1;
	  }
	  return out >>> 0;
	};

	var padSplit = function padSplit(num, size, group) {
	  var str = num.toString(2);
	  while (str.length < size)
	    str = '0' + str;

	  var out = [];
	  for (var i = 0; i < size; i += group)
	    out.push(str.slice(i, i + group));
	  return out.join(' ');
	};

	var utils = {
		readUInt32BE: readUInt32BE,
		writeUInt32BE: writeUInt32BE,
		ip: ip,
		rip: rip,
		pc1: pc1,
		r28shl: r28shl,
		pc2: pc2,
		expand: expand,
		substitute: substitute,
		permute: permute,
		padSplit: padSplit
	};

	var minimalisticAssert = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};

	function Cipher(options) {
	  this.options = options;

	  this.type = this.options.type;
	  this.blockSize = 8;
	  this._init();

	  this.buffer = new Array(this.blockSize);
	  this.bufferOff = 0;
	}
	var cipher = Cipher;

	Cipher.prototype._init = function _init() {
	  // Might be overrided
	};

	Cipher.prototype.update = function update(data) {
	  if (data.length === 0)
	    return [];

	  if (this.type === 'decrypt')
	    return this._updateDecrypt(data);
	  else
	    return this._updateEncrypt(data);
	};

	Cipher.prototype._buffer = function _buffer(data, off) {
	  // Append data to buffer
	  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
	  for (var i = 0; i < min; i++)
	    this.buffer[this.bufferOff + i] = data[off + i];
	  this.bufferOff += min;

	  // Shift next
	  return min;
	};

	Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
	  this._update(this.buffer, 0, out, off);
	  this.bufferOff = 0;
	  return this.blockSize;
	};

	Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
	  var out = new Array(count * this.blockSize);

	  if (this.bufferOff !== 0) {
	    inputOff += this._buffer(data, inputOff);

	    if (this.bufferOff === this.buffer.length)
	      outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Write blocks
	  var max = data.length - ((data.length - inputOff) % this.blockSize);
	  for (; inputOff < max; inputOff += this.blockSize) {
	    this._update(data, inputOff, out, outputOff);
	    outputOff += this.blockSize;
	  }

	  // Queue rest
	  for (; inputOff < data.length; inputOff++, this.bufferOff++)
	    this.buffer[this.bufferOff] = data[inputOff];

	  return out;
	};

	Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
	  var out = new Array(count * this.blockSize);

	  // TODO(indutny): optimize it, this is far from optimal
	  for (; count > 0; count--) {
	    inputOff += this._buffer(data, inputOff);
	    outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Buffer rest of the input
	  inputOff += this._buffer(data, inputOff);

	  return out;
	};

	Cipher.prototype.final = function final(buffer) {
	  var first;
	  if (buffer)
	    first = this.update(buffer);

	  var last;
	  if (this.type === 'encrypt')
	    last = this._finalEncrypt();
	  else
	    last = this._finalDecrypt();

	  if (first)
	    return first.concat(last);
	  else
	    return last;
	};

	Cipher.prototype._pad = function _pad(buffer, off) {
	  if (off === 0)
	    return false;

	  while (off < buffer.length)
	    buffer[off++] = 0;

	  return true;
	};

	Cipher.prototype._finalEncrypt = function _finalEncrypt() {
	  if (!this._pad(this.buffer, this.bufferOff))
	    return [];

	  var out = new Array(this.blockSize);
	  this._update(this.buffer, 0, out, 0);
	  return out;
	};

	Cipher.prototype._unpad = function _unpad(buffer) {
	  return buffer;
	};

	Cipher.prototype._finalDecrypt = function _finalDecrypt() {
	  minimalisticAssert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
	  var out = new Array(this.blockSize);
	  this._flushBuffer(out, 0);

	  return this._unpad(out);
	};

	var utils$1 = des.utils;
	var Cipher$1 = des.Cipher;

	function DESState() {
	  this.tmp = new Array(2);
	  this.keys = null;
	}

	function DES(options) {
	  Cipher$1.call(this, options);

	  var state = new DESState();
	  this._desState = state;

	  this.deriveKeys(state, options.key);
	}
	inherits_browser(DES, Cipher$1);
	var des_1 = DES;

	DES.create = function create(options) {
	  return new DES(options);
	};

	var shiftTable = [
	  1, 1, 2, 2, 2, 2, 2, 2,
	  1, 2, 2, 2, 2, 2, 2, 1
	];

	DES.prototype.deriveKeys = function deriveKeys(state, key) {
	  state.keys = new Array(16 * 2);

	  minimalisticAssert.equal(key.length, this.blockSize, 'Invalid key length');

	  var kL = utils$1.readUInt32BE(key, 0);
	  var kR = utils$1.readUInt32BE(key, 4);

	  utils$1.pc1(kL, kR, state.tmp, 0);
	  kL = state.tmp[0];
	  kR = state.tmp[1];
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var shift = shiftTable[i >>> 1];
	    kL = utils$1.r28shl(kL, shift);
	    kR = utils$1.r28shl(kR, shift);
	    utils$1.pc2(kL, kR, state.keys, i);
	  }
	};

	DES.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._desState;

	  var l = utils$1.readUInt32BE(inp, inOff);
	  var r = utils$1.readUInt32BE(inp, inOff + 4);

	  // Initial Permutation
	  utils$1.ip(l, r, state.tmp, 0);
	  l = state.tmp[0];
	  r = state.tmp[1];

	  if (this.type === 'encrypt')
	    this._encrypt(state, l, r, state.tmp, 0);
	  else
	    this._decrypt(state, l, r, state.tmp, 0);

	  l = state.tmp[0];
	  r = state.tmp[1];

	  utils$1.writeUInt32BE(out, l, outOff);
	  utils$1.writeUInt32BE(out, r, outOff + 4);
	};

	DES.prototype._pad = function _pad(buffer, off) {
	  var value = buffer.length - off;
	  for (var i = off; i < buffer.length; i++)
	    buffer[i] = value;

	  return true;
	};

	DES.prototype._unpad = function _unpad(buffer) {
	  var pad = buffer[buffer.length - 1];
	  for (var i = buffer.length - pad; i < buffer.length; i++)
	    minimalisticAssert.equal(buffer[i], pad);

	  return buffer.slice(0, buffer.length - pad);
	};

	DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
	  var l = lStart;
	  var r = rStart;

	  // Apply f() x16 times
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils$1.expand(r, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils$1.substitute(keyL, keyR);
	    var f = utils$1.permute(s);

	    var t = r;
	    r = (l ^ f) >>> 0;
	    l = t;
	  }

	  // Reverse Initial Permutation
	  utils$1.rip(r, l, out, off);
	};

	DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
	  var l = rStart;
	  var r = lStart;

	  // Apply f() x16 times
	  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils$1.expand(l, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils$1.substitute(keyL, keyR);
	    var f = utils$1.permute(s);

	    var t = l;
	    l = (r ^ f) >>> 0;
	    r = t;
	  }

	  // Reverse Initial Permutation
	  utils$1.rip(l, r, out, off);
	};

	var proto$1 = {};

	function CBCState(iv) {
	  minimalisticAssert.equal(iv.length, 8, 'Invalid IV length');

	  this.iv = new Array(8);
	  for (var i = 0; i < this.iv.length; i++)
	    this.iv[i] = iv[i];
	}

	function instantiate(Base) {
	  function CBC(options) {
	    Base.call(this, options);
	    this._cbcInit();
	  }
	  inherits_browser(CBC, Base);

	  var keys = Object.keys(proto$1);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    CBC.prototype[key] = proto$1[key];
	  }

	  CBC.create = function create(options) {
	    return new CBC(options);
	  };

	  return CBC;
	}

	var instantiate_1 = instantiate;

	proto$1._cbcInit = function _cbcInit() {
	  var state = new CBCState(this.options.iv);
	  this._cbcState = state;
	};

	proto$1._update = function _update(inp, inOff, out, outOff) {
	  var state = this._cbcState;
	  var superProto = this.constructor.super_.prototype;

	  var iv = state.iv;
	  if (this.type === 'encrypt') {
	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] ^= inp[inOff + i];

	    superProto._update.call(this, iv, 0, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = out[outOff + i];
	  } else {
	    superProto._update.call(this, inp, inOff, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      out[outOff + i] ^= iv[i];

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = inp[inOff + i];
	  }
	};

	var cbc = {
		instantiate: instantiate_1
	};

	var Cipher$2 = des.Cipher;
	var DES$1 = des.DES;

	function EDEState(type, key) {
	  minimalisticAssert.equal(key.length, 24, 'Invalid key length');

	  var k1 = key.slice(0, 8);
	  var k2 = key.slice(8, 16);
	  var k3 = key.slice(16, 24);

	  if (type === 'encrypt') {
	    this.ciphers = [
	      DES$1.create({ type: 'encrypt', key: k1 }),
	      DES$1.create({ type: 'decrypt', key: k2 }),
	      DES$1.create({ type: 'encrypt', key: k3 })
	    ];
	  } else {
	    this.ciphers = [
	      DES$1.create({ type: 'decrypt', key: k3 }),
	      DES$1.create({ type: 'encrypt', key: k2 }),
	      DES$1.create({ type: 'decrypt', key: k1 })
	    ];
	  }
	}

	function EDE(options) {
	  Cipher$2.call(this, options);

	  var state = new EDEState(this.type, this.options.key);
	  this._edeState = state;
	}
	inherits_browser(EDE, Cipher$2);

	var ede = EDE;

	EDE.create = function create(options) {
	  return new EDE(options);
	};

	EDE.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._edeState;

	  state.ciphers[0]._update(inp, inOff, out, outOff);
	  state.ciphers[1]._update(out, outOff, out, outOff);
	  state.ciphers[2]._update(out, outOff, out, outOff);
	};

	EDE.prototype._pad = DES$1.prototype._pad;
	EDE.prototype._unpad = DES$1.prototype._unpad;

	var utils$2 = utils;
	var Cipher$3 = cipher;
	var DES$2 = des_1;
	var CBC = cbc;
	var EDE$1 = ede;

	var des = {
		utils: utils$2,
		Cipher: Cipher$3,
		DES: DES$2,
		CBC: CBC,
		EDE: EDE$1
	};

	var Buffer$h = safeBuffer.Buffer;

	var modes = {
	  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede3': des.EDE,
	  'des-ede-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede': des.EDE,
	  'des-cbc': des.CBC.instantiate(des.DES),
	  'des-ecb': des.DES
	};
	modes.des = modes['des-cbc'];
	modes.des3 = modes['des-ede3-cbc'];
	var browserifyDes = DES$3;
	inherits_browser(DES$3, cipherBase);
	function DES$3 (opts) {
	  cipherBase.call(this);
	  var modeName = opts.mode.toLowerCase();
	  var mode = modes[modeName];
	  var type;
	  if (opts.decrypt) {
	    type = 'decrypt';
	  } else {
	    type = 'encrypt';
	  }
	  var key = opts.key;
	  if (!Buffer$h.isBuffer(key)) {
	    key = Buffer$h.from(key);
	  }
	  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
	    key = Buffer$h.concat([key, key.slice(0, 8)]);
	  }
	  var iv = opts.iv;
	  if (!Buffer$h.isBuffer(iv)) {
	    iv = Buffer$h.from(iv);
	  }
	  this._des = mode.create({
	    key: key,
	    iv: iv,
	    type: type
	  });
	}
	DES$3.prototype._update = function (data) {
	  return Buffer$h.from(this._des.update(data))
	};
	DES$3.prototype._final = function () {
	  return Buffer$h.from(this._des.final())
	};

	var encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block)
	};

	var decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block)
	};

	var ecb = {
		encrypt: encrypt,
		decrypt: decrypt
	};

	var bufferXor = function xor (a, b) {
	  var length = Math.min(a.length, b.length);
	  var buffer = new Buffer(length);

	  for (var i = 0; i < length; ++i) {
	    buffer[i] = a[i] ^ b[i];
	  }

	  return buffer
	};

	var encrypt$1 = function (self, block) {
	  var data = bufferXor(block, self._prev);

	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev
	};

	var decrypt$1 = function (self, block) {
	  var pad = self._prev;

	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);

	  return bufferXor(out, pad)
	};

	var cbc$1 = {
		encrypt: encrypt$1,
		decrypt: decrypt$1
	};

	var Buffer$i = safeBuffer.Buffer;


	function encryptStart (self, data, decrypt) {
	  var len = data.length;
	  var out = bufferXor(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer$i.concat([self._prev, decrypt ? data : out]);
	  return out
	}

	var encrypt$2 = function (self, data, decrypt) {
	  var out = Buffer$i.allocUnsafe(0);
	  var len;

	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = Buffer$i.allocUnsafe(0);
	    }

	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer$i.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer$i.concat([out, encryptStart(self, data, decrypt)]);
	      break
	    }
	  }

	  return out
	};

	var cfb = {
		encrypt: encrypt$2
	};

	var Buffer$j = safeBuffer.Buffer;

	function encryptByte (self, byteParam, decrypt) {
	  var pad = self._cipher.encryptBlock(self._prev);
	  var out = pad[0] ^ byteParam;

	  self._prev = Buffer$j.concat([
	    self._prev.slice(1),
	    Buffer$j.from([decrypt ? byteParam : out])
	  ]);

	  return out
	}

	var encrypt$3 = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer$j.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt);
	  }

	  return out
	};

	var cfb8 = {
		encrypt: encrypt$3
	};

	var Buffer$k = safeBuffer.Buffer;

	function encryptByte$1 (self, byteParam, decrypt) {
	  var pad;
	  var i = -1;
	  var len = 8;
	  var out = 0;
	  var bit, value;
	  while (++i < len) {
	    pad = self._cipher.encryptBlock(self._prev);
	    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
	    value = pad[0] ^ bit;
	    out += ((value & 0x80) >> (i % 8));
	    self._prev = shiftIn(self._prev, decrypt ? bit : value);
	  }
	  return out
	}

	function shiftIn (buffer, value) {
	  var len = buffer.length;
	  var i = -1;
	  var out = Buffer$k.allocUnsafe(buffer.length);
	  buffer = Buffer$k.concat([buffer, Buffer$k.from([value])]);

	  while (++i < len) {
	    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
	  }

	  return out
	}

	var encrypt$4 = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer$k.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte$1(self, chunk[i], decrypt);
	  }

	  return out
	};

	var cfb1 = {
		encrypt: encrypt$4
	};

	function getBlock (self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev
	}

	var encrypt$5 = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }

	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return bufferXor(chunk, pad)
	};

	var ofb = {
		encrypt: encrypt$5
	};

	function incr32 (iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break
	    }
	  }
	}
	var incr32_1 = incr32;

	var Buffer$l = safeBuffer.Buffer;


	function getBlock$1 (self) {
	  var out = self._cipher.encryptBlockRaw(self._prev);
	  incr32_1(self._prev);
	  return out
	}

	var blockSize = 16;
	var encrypt$6 = function (self, chunk) {
	  var chunkNum = Math.ceil(chunk.length / blockSize);
	  var start = self._cache.length;
	  self._cache = Buffer$l.concat([
	    self._cache,
	    Buffer$l.allocUnsafe(chunkNum * blockSize)
	  ]);
	  for (var i = 0; i < chunkNum; i++) {
	    var out = getBlock$1(self);
	    var offset = start + i * blockSize;
	    self._cache.writeUInt32BE(out[0], offset + 0);
	    self._cache.writeUInt32BE(out[1], offset + 4);
	    self._cache.writeUInt32BE(out[2], offset + 8);
	    self._cache.writeUInt32BE(out[3], offset + 12);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return bufferXor(chunk, pad)
	};

	var ctr = {
		encrypt: encrypt$6
	};

	var aes128 = {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var aes192 = {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var aes256 = {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var list = {
		"aes-128-ecb": {
		cipher: "AES",
		key: 128,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-192-ecb": {
		cipher: "AES",
		key: 192,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-256-ecb": {
		cipher: "AES",
		key: 256,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-128-cbc": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		"aes-192-cbc": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		"aes-256-cbc": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		aes128: aes128,
		aes192: aes192,
		aes256: aes256,
		"aes-128-cfb": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-192-cfb": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-256-cfb": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-128-cfb8": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-192-cfb8": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-256-cfb8": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-128-cfb1": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-192-cfb1": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-256-cfb1": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-128-ofb": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-192-ofb": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-256-ofb": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-128-ctr": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-192-ctr": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-256-ctr": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-128-gcm": {
		cipher: "AES",
		key: 128,
		iv: 12,
		mode: "GCM",
		type: "auth"
	},
		"aes-192-gcm": {
		cipher: "AES",
		key: 192,
		iv: 12,
		mode: "GCM",
		type: "auth"
	},
		"aes-256-gcm": {
		cipher: "AES",
		key: 256,
		iv: 12,
		mode: "GCM",
		type: "auth"
	}
	};

	var list$1 = /*#__PURE__*/Object.freeze({
		aes128: aes128,
		aes192: aes192,
		aes256: aes256,
		default: list
	});

	var modes$1 = ( list$1 && list ) || list$1;

	var modeModules = {
	  ECB: ecb,
	  CBC: cbc$1,
	  CFB: cfb,
	  CFB8: cfb8,
	  CFB1: cfb1,
	  OFB: ofb,
	  CTR: ctr,
	  GCM: ctr
	};



	for (var key in modes$1) {
	  modes$1[key].module = modeModules[modes$1[key].mode];
	}

	var modes_1 = modes$1;

	// based on the aes implimentation in triple sec
	// https://github.com/keybase/triplesec
	// which is in turn based on the one from crypto-js
	// https://code.google.com/p/crypto-js/

	var Buffer$m = safeBuffer.Buffer;

	function asUInt32Array (buf) {
	  if (!Buffer$m.isBuffer(buf)) buf = Buffer$m.from(buf);

	  var len = (buf.length / 4) | 0;
	  var out = new Array(len);

	  for (var i = 0; i < len; i++) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }

	  return out
	}

	function scrubVec (v) {
	  for (var i = 0; i < v.length; v++) {
	    v[i] = 0;
	  }
	}

	function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
	  var SUB_MIX0 = SUB_MIX[0];
	  var SUB_MIX1 = SUB_MIX[1];
	  var SUB_MIX2 = SUB_MIX[2];
	  var SUB_MIX3 = SUB_MIX[3];

	  var s0 = M[0] ^ keySchedule[0];
	  var s1 = M[1] ^ keySchedule[1];
	  var s2 = M[2] ^ keySchedule[2];
	  var s3 = M[3] ^ keySchedule[3];
	  var t0, t1, t2, t3;
	  var ksRow = 4;

	  for (var round = 1; round < nRounds; round++) {
	    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }

	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  t0 = t0 >>> 0;
	  t1 = t1 >>> 0;
	  t2 = t2 >>> 0;
	  t3 = t3 >>> 0;

	  return [t0, t1, t2, t3]
	}

	// AES constants
	var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	var G = (function () {
	  // Compute double table
	  var d = new Array(256);
	  for (var j = 0; j < 256; j++) {
	    if (j < 128) {
	      d[j] = j << 1;
	    } else {
	      d[j] = (j << 1) ^ 0x11b;
	    }
	  }

	  var SBOX = [];
	  var INV_SBOX = [];
	  var SUB_MIX = [[], [], [], []];
	  var INV_SUB_MIX = [[], [], [], []];

	  // Walk GF(2^8)
	  var x = 0;
	  var xi = 0;
	  for (var i = 0; i < 256; ++i) {
	    // Compute sbox
	    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    SBOX[x] = sx;
	    INV_SBOX[sx] = x;

	    // Compute multiplication
	    var x2 = d[x];
	    var x4 = d[x2];
	    var x8 = d[x4];

	    // Compute sub bytes, mix columns tables
	    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    SUB_MIX[3][x] = t;

	    // Compute inv sub bytes, inv mix columns tables
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    INV_SUB_MIX[3][sx] = t;

	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }

	  return {
	    SBOX: SBOX,
	    INV_SBOX: INV_SBOX,
	    SUB_MIX: SUB_MIX,
	    INV_SUB_MIX: INV_SUB_MIX
	  }
	})();

	function AES (key) {
	  this._key = asUInt32Array(key);
	  this._reset();
	}

	AES.blockSize = 4 * 4;
	AES.keySize = 256 / 8;
	AES.prototype.blockSize = AES.blockSize;
	AES.prototype.keySize = AES.keySize;
	AES.prototype._reset = function () {
	  var keyWords = this._key;
	  var keySize = keyWords.length;
	  var nRounds = keySize + 6;
	  var ksRows = (nRounds + 1) * 4;

	  var keySchedule = [];
	  for (var k = 0; k < keySize; k++) {
	    keySchedule[k] = keyWords[k];
	  }

	  for (k = keySize; k < ksRows; k++) {
	    var t = keySchedule[k - 1];

	    if (k % keySize === 0) {
	      t = (t << 8) | (t >>> 24);
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);

	      t ^= RCON[(k / keySize) | 0] << 24;
	    } else if (keySize > 6 && k % keySize === 4) {
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);
	    }

	    keySchedule[k] = keySchedule[k - keySize] ^ t;
	  }

	  var invKeySchedule = [];
	  for (var ik = 0; ik < ksRows; ik++) {
	    var ksR = ksRows - ik;
	    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

	    if (ik < 4 || ksR <= 4) {
	      invKeySchedule[ik] = tt;
	    } else {
	      invKeySchedule[ik] =
	        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
	        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
	        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
	        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
	    }
	  }

	  this._nRounds = nRounds;
	  this._keySchedule = keySchedule;
	  this._invKeySchedule = invKeySchedule;
	};

	AES.prototype.encryptBlockRaw = function (M) {
	  M = asUInt32Array(M);
	  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
	};

	AES.prototype.encryptBlock = function (M) {
	  var out = this.encryptBlockRaw(M);
	  var buf = Buffer$m.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf
	};

	AES.prototype.decryptBlock = function (M) {
	  M = asUInt32Array(M);

	  // swap
	  var m1 = M[1];
	  M[1] = M[3];
	  M[3] = m1;

	  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
	  var buf = Buffer$m.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf
	};

	AES.prototype.scrub = function () {
	  scrubVec(this._keySchedule);
	  scrubVec(this._invKeySchedule);
	  scrubVec(this._key);
	};

	var AES_1 = AES;

	var aes = {
		AES: AES_1
	};

	var Buffer$n = safeBuffer.Buffer;
	var ZEROES = Buffer$n.alloc(16, 0);

	function toArray (buf) {
	  return [
	    buf.readUInt32BE(0),
	    buf.readUInt32BE(4),
	    buf.readUInt32BE(8),
	    buf.readUInt32BE(12)
	  ]
	}

	function fromArray (out) {
	  var buf = Buffer$n.allocUnsafe(16);
	  buf.writeUInt32BE(out[0] >>> 0, 0);
	  buf.writeUInt32BE(out[1] >>> 0, 4);
	  buf.writeUInt32BE(out[2] >>> 0, 8);
	  buf.writeUInt32BE(out[3] >>> 0, 12);
	  return buf
	}

	function GHASH (key) {
	  this.h = key;
	  this.state = Buffer$n.alloc(16, 0);
	  this.cache = Buffer$n.allocUnsafe(0);
	}

	// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
	// by Juho Vähä-Herttua
	GHASH.prototype.ghash = function (block) {
	  var i = -1;
	  while (++i < block.length) {
	    this.state[i] ^= block[i];
	  }
	  this._multiply();
	};

	GHASH.prototype._multiply = function () {
	  var Vi = toArray(this.h);
	  var Zi = [0, 0, 0, 0];
	  var j, xi, lsbVi;
	  var i = -1;
	  while (++i < 128) {
	    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0;
	    if (xi) {
	      // Z_i+1 = Z_i ^ V_i
	      Zi[0] ^= Vi[0];
	      Zi[1] ^= Vi[1];
	      Zi[2] ^= Vi[2];
	      Zi[3] ^= Vi[3];
	    }

	    // Store the value of LSB(V_i)
	    lsbVi = (Vi[3] & 1) !== 0;

	    // V_i+1 = V_i >> 1
	    for (j = 3; j > 0; j--) {
	      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
	    }
	    Vi[0] = Vi[0] >>> 1;

	    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
	    if (lsbVi) {
	      Vi[0] = Vi[0] ^ (0xe1 << 24);
	    }
	  }
	  this.state = fromArray(Zi);
	};

	GHASH.prototype.update = function (buf) {
	  this.cache = Buffer$n.concat([this.cache, buf]);
	  var chunk;
	  while (this.cache.length >= 16) {
	    chunk = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    this.ghash(chunk);
	  }
	};

	GHASH.prototype.final = function (abl, bl) {
	  if (this.cache.length) {
	    this.ghash(Buffer$n.concat([this.cache, ZEROES], 16));
	  }

	  this.ghash(fromArray([0, abl, 0, bl]));
	  return this.state
	};

	var ghash = GHASH;

	var Buffer$o = safeBuffer.Buffer;






	function xorTest (a, b) {
	  var out = 0;
	  if (a.length !== b.length) out++;

	  var len = Math.min(a.length, b.length);
	  for (var i = 0; i < len; ++i) {
	    out += (a[i] ^ b[i]);
	  }

	  return out
	}

	function calcIv (self, iv, ck) {
	  if (iv.length === 12) {
	    self._finID = Buffer$o.concat([iv, Buffer$o.from([0, 0, 0, 1])]);
	    return Buffer$o.concat([iv, Buffer$o.from([0, 0, 0, 2])])
	  }
	  var ghash$$1 = new ghash(ck);
	  var len = iv.length;
	  var toPad = len % 16;
	  ghash$$1.update(iv);
	  if (toPad) {
	    toPad = 16 - toPad;
	    ghash$$1.update(Buffer$o.alloc(toPad, 0));
	  }
	  ghash$$1.update(Buffer$o.alloc(8, 0));
	  var ivBits = len * 8;
	  var tail = Buffer$o.alloc(8);
	  tail.writeUIntBE(ivBits, 0, 8);
	  ghash$$1.update(tail);
	  self._finID = ghash$$1.state;
	  var out = Buffer$o.from(self._finID);
	  incr32_1(out);
	  return out
	}
	function StreamCipher (mode, key, iv, decrypt) {
	  cipherBase.call(this);

	  var h = Buffer$o.alloc(4, 0);

	  this._cipher = new aes.AES(key);
	  var ck = this._cipher.encryptBlock(h);
	  this._ghash = new ghash(ck);
	  iv = calcIv(this, iv, ck);

	  this._prev = Buffer$o.from(iv);
	  this._cache = Buffer$o.allocUnsafe(0);
	  this._secCache = Buffer$o.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._alen = 0;
	  this._len = 0;
	  this._mode = mode;

	  this._authTag = null;
	  this._called = false;
	}

	inherits_browser(StreamCipher, cipherBase);

	StreamCipher.prototype._update = function (chunk) {
	  if (!this._called && this._alen) {
	    var rump = 16 - (this._alen % 16);
	    if (rump < 16) {
	      rump = Buffer$o.alloc(rump, 0);
	      this._ghash.update(rump);
	    }
	  }

	  this._called = true;
	  var out = this._mode.encrypt(this, chunk);
	  if (this._decrypt) {
	    this._ghash.update(chunk);
	  } else {
	    this._ghash.update(out);
	  }
	  this._len += chunk.length;
	  return out
	};

	StreamCipher.prototype._final = function () {
	  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

	  var tag = bufferXor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
	  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

	  this._authTag = tag;
	  this._cipher.scrub();
	};

	StreamCipher.prototype.getAuthTag = function getAuthTag () {
	  if (this._decrypt || !Buffer$o.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

	  return this._authTag
	};

	StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
	  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

	  this._authTag = tag;
	};

	StreamCipher.prototype.setAAD = function setAAD (buf) {
	  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

	  this._ghash.update(buf);
	  this._alen += buf.length;
	};

	var authCipher = StreamCipher;

	var Buffer$p = safeBuffer.Buffer;



	function StreamCipher$1 (mode, key, iv, decrypt) {
	  cipherBase.call(this);

	  this._cipher = new aes.AES(key);
	  this._prev = Buffer$p.from(iv);
	  this._cache = Buffer$p.allocUnsafe(0);
	  this._secCache = Buffer$p.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._mode = mode;
	}

	inherits_browser(StreamCipher$1, cipherBase);

	StreamCipher$1.prototype._update = function (chunk) {
	  return this._mode.encrypt(this, chunk, this._decrypt)
	};

	StreamCipher$1.prototype._final = function () {
	  this._cipher.scrub();
	};

	var streamCipher = StreamCipher$1;

	var Buffer$q = safeBuffer.Buffer;


	/* eslint-disable camelcase */
	function EVP_BytesToKey (password, salt, keyBits, ivLen) {
	  if (!Buffer$q.isBuffer(password)) password = Buffer$q.from(password, 'binary');
	  if (salt) {
	    if (!Buffer$q.isBuffer(salt)) salt = Buffer$q.from(salt, 'binary');
	    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
	  }

	  var keyLen = keyBits / 8;
	  var key = Buffer$q.alloc(keyLen);
	  var iv = Buffer$q.alloc(ivLen || 0);
	  var tmp = Buffer$q.alloc(0);

	  while (keyLen > 0 || ivLen > 0) {
	    var hash = new md5_js();
	    hash.update(tmp);
	    hash.update(password);
	    if (salt) hash.update(salt);
	    tmp = hash.digest();

	    var used = 0;

	    if (keyLen > 0) {
	      var keyStart = key.length - keyLen;
	      used = Math.min(keyLen, tmp.length);
	      tmp.copy(key, keyStart, 0, used);
	      keyLen -= used;
	    }

	    if (used < tmp.length && ivLen > 0) {
	      var ivStart = iv.length - ivLen;
	      var length = Math.min(ivLen, tmp.length - used);
	      tmp.copy(iv, ivStart, used, used + length);
	      ivLen -= length;
	    }
	  }

	  tmp.fill(0);
	  return { key: key, iv: iv }
	}

	var evp_bytestokey = EVP_BytesToKey;

	var Buffer$r = safeBuffer.Buffer;






	function Cipher$4 (mode, key, iv) {
	  cipherBase.call(this);

	  this._cache = new Splitter();
	  this._cipher = new aes.AES(key);
	  this._prev = Buffer$r.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits_browser(Cipher$4, cipherBase);

	Cipher$4.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];

	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    out.push(thing);
	  }

	  return Buffer$r.concat(out)
	};

	var PADDING = Buffer$r.alloc(16, 0x10);

	Cipher$4.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    chunk = this._mode.encrypt(this, chunk);
	    this._cipher.scrub();
	    return chunk
	  }

	  if (!chunk.equals(PADDING)) {
	    this._cipher.scrub();
	    throw new Error('data not multiple of block length')
	  }
	};

	Cipher$4.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter () {
	  this.cache = Buffer$r.allocUnsafe(0);
	}

	Splitter.prototype.add = function (data) {
	  this.cache = Buffer$r.concat([this.cache, data]);
	};

	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out
	  }
	  return null
	};

	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = Buffer$r.allocUnsafe(len);

	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }

	  return Buffer$r.concat([this.cache, padBuff])
	};

	function createCipheriv (suite, password, iv) {
	  var config = modes_1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof password === 'string') password = Buffer$r.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (typeof iv === 'string') iv = Buffer$r.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (config.type === 'stream') {
	    return new streamCipher(config.module, password, iv)
	  } else if (config.type === 'auth') {
	    return new authCipher(config.module, password, iv)
	  }

	  return new Cipher$4(config.module, password, iv)
	}

	function createCipher (suite, password) {
	  var config = modes_1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = evp_bytestokey(password, false, config.key, config.iv);
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	var createCipheriv_1 = createCipheriv;
	var createCipher_1 = createCipher;

	var encrypter = {
		createCipheriv: createCipheriv_1,
		createCipher: createCipher_1
	};

	var Buffer$s = safeBuffer.Buffer;







	function Decipher (mode, key, iv) {
	  cipherBase.call(this);

	  this._cache = new Splitter$1();
	  this._last = void 0;
	  this._cipher = new aes.AES(key);
	  this._prev = Buffer$s.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits_browser(Decipher, cipherBase);

	Decipher.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];
	  while ((chunk = this._cache.get(this._autopadding))) {
	    thing = this._mode.decrypt(this, chunk);
	    out.push(thing);
	  }
	  return Buffer$s.concat(out)
	};

	Decipher.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    return unpad(this._mode.decrypt(this, chunk))
	  } else if (chunk) {
	    throw new Error('data not multiple of block length')
	  }
	};

	Decipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter$1 () {
	  this.cache = Buffer$s.allocUnsafe(0);
	}

	Splitter$1.prototype.add = function (data) {
	  this.cache = Buffer$s.concat([this.cache, data]);
	};

	Splitter$1.prototype.get = function (autoPadding) {
	  var out;
	  if (autoPadding) {
	    if (this.cache.length > 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  } else {
	    if (this.cache.length >= 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  }

	  return null
	};

	Splitter$1.prototype.flush = function () {
	  if (this.cache.length) return this.cache
	};

	function unpad (last) {
	  var padded = last[15];
	  if (padded < 1 || padded > 16) {
	    throw new Error('unable to decrypt data')
	  }
	  var i = -1;
	  while (++i < padded) {
	    if (last[(i + (16 - padded))] !== padded) {
	      throw new Error('unable to decrypt data')
	    }
	  }
	  if (padded === 16) return

	  return last.slice(0, 16 - padded)
	}

	function createDecipheriv (suite, password, iv) {
	  var config = modes_1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof iv === 'string') iv = Buffer$s.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (typeof password === 'string') password = Buffer$s.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (config.type === 'stream') {
	    return new streamCipher(config.module, password, iv, true)
	  } else if (config.type === 'auth') {
	    return new authCipher(config.module, password, iv, true)
	  }

	  return new Decipher(config.module, password, iv)
	}

	function createDecipher (suite, password) {
	  var config = modes_1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = evp_bytestokey(password, false, config.key, config.iv);
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	var createDecipher_1 = createDecipher;
	var createDecipheriv_1 = createDecipheriv;

	var decrypter = {
		createDecipher: createDecipher_1,
		createDecipheriv: createDecipheriv_1
	};

	var browser$5 = createCommonjsModule(function (module, exports) {
	function getCiphers () {
	  return Object.keys(modes$1)
	}

	exports.createCipher = exports.Cipher = encrypter.createCipher;
	exports.createCipheriv = exports.Cipheriv = encrypter.createCipheriv;
	exports.createDecipher = exports.Decipher = decrypter.createDecipher;
	exports.createDecipheriv = exports.Decipheriv = decrypter.createDecipheriv;
	exports.listCiphers = exports.getCiphers = getCiphers;
	});
	var browser_1 = browser$5.createCipher;
	var browser_2 = browser$5.Cipher;
	var browser_3 = browser$5.createCipheriv;
	var browser_4 = browser$5.Cipheriv;
	var browser_5 = browser$5.createDecipher;
	var browser_6 = browser$5.Decipher;
	var browser_7 = browser$5.createDecipheriv;
	var browser_8 = browser$5.Decipheriv;
	var browser_9 = browser$5.listCiphers;
	var browser_10 = browser$5.getCiphers;

	var modes$2 = createCommonjsModule(function (module, exports) {
	exports['des-ecb'] = {
	  key: 8,
	  iv: 0
	};
	exports['des-cbc'] = exports.des = {
	  key: 8,
	  iv: 8
	};
	exports['des-ede3-cbc'] = exports.des3 = {
	  key: 24,
	  iv: 8
	};
	exports['des-ede3'] = {
	  key: 24,
	  iv: 0
	};
	exports['des-ede-cbc'] = {
	  key: 16,
	  iv: 8
	};
	exports['des-ede'] = {
	  key: 16,
	  iv: 0
	};
	});
	var modes_1$1 = modes$2.des;
	var modes_2 = modes$2.des3;

	var browser$6 = createCommonjsModule(function (module, exports) {
	function createCipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (modes_1[suite]) {
	    keyLen = modes_1[suite].key;
	    ivLen = modes_1[suite].iv;
	  } else if (modes$2[suite]) {
	    keyLen = modes$2[suite].key * 8;
	    ivLen = modes$2[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = evp_bytestokey(password, false, keyLen, ivLen);
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	function createDecipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (modes_1[suite]) {
	    keyLen = modes_1[suite].key;
	    ivLen = modes_1[suite].iv;
	  } else if (modes$2[suite]) {
	    keyLen = modes$2[suite].key * 8;
	    ivLen = modes$2[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = evp_bytestokey(password, false, keyLen, ivLen);
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	function createCipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (modes_1[suite]) return browser$5.createCipheriv(suite, key, iv)
	  if (modes$2[suite]) return new browserifyDes({ key: key, iv: iv, mode: suite })

	  throw new TypeError('invalid suite type')
	}

	function createDecipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (modes_1[suite]) return browser$5.createDecipheriv(suite, key, iv)
	  if (modes$2[suite]) return new browserifyDes({ key: key, iv: iv, mode: suite, decrypt: true })

	  throw new TypeError('invalid suite type')
	}

	function getCiphers () {
	  return Object.keys(modes$2).concat(browser$5.getCiphers())
	}

	exports.createCipher = exports.Cipher = createCipher;
	exports.createCipheriv = exports.Cipheriv = createCipheriv;
	exports.createDecipher = exports.Decipher = createDecipher;
	exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
	exports.listCiphers = exports.getCiphers = getCiphers;
	});
	var browser_1$1 = browser$6.createCipher;
	var browser_2$1 = browser$6.Cipher;
	var browser_3$1 = browser$6.createCipheriv;
	var browser_4$1 = browser$6.Cipheriv;
	var browser_5$1 = browser$6.createDecipher;
	var browser_6$1 = browser$6.Decipher;
	var browser_7$1 = browser$6.createDecipheriv;
	var browser_8$1 = browser$6.Decipheriv;
	var browser_9$1 = browser$6.listCiphers;
	var browser_10$1 = browser$6.getCiphers;

	var bn = createCommonjsModule(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    Buffer = require$$0.Buffer;
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	    }

	    if (base === 16) {
	      this._parseHex(number, start);
	    } else {
	      this._parseBase(number, base, start);
	    }

	    if (number[0] === '-') {
	      this.negative = 1;
	    }

	    this.strip();

	    if (endian !== 'le') return;

	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex (str, start, end) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r <<= 4;

	      // 'a' - 'f'
	      if (c >= 49 && c <= 54) {
	        r |= c - 49 + 0xa;

	      // 'A' - 'F'
	      } else if (c >= 17 && c <= 22) {
	        r |= c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r |= c & 0xf;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    // Scan 24-bit chunks and add them to the number
	    var off = 0;
	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
	      w = parseHex(number, i, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	    if (i + 6 !== start) {
	      w = parseHex(number, start, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    }
	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      r.strip();
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal);
	});

	var r;

	var brorand = function rand(len) {
	  if (!r)
	    r = new Rand(null);

	  return r.generate(len);
	};

	function Rand(rand) {
	  this.rand = rand;
	}
	var Rand_1 = Rand;

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	// Emulate crypto API using randy
	Rand.prototype._rand = function _rand(n) {
	  if (this.rand.getBytes)
	    return this.rand.getBytes(n);

	  var res = new Uint8Array(n);
	  for (var i = 0; i < res.length; i++)
	    res[i] = this.rand.getByte();
	  return res;
	};

	if (typeof self === 'object') {
	  if (self.crypto && self.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.msCrypto.getRandomValues(arr);
	      return arr;
	    };

	  // Safari's WebWorkers do not have `crypto`
	  } else if (typeof window === 'object') {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js or Web worker with no crypto support
	  try {
	    var crypto = cryptoBrowserify;
	    if (typeof crypto.randomBytes !== 'function')
	      throw new Error('Not supported');

	    Rand.prototype._rand = function _rand(n) {
	      return crypto.randomBytes(n);
	    };
	  } catch (e) {
	  }
	}
	brorand.Rand = Rand_1;

	function MillerRabin(rand) {
	  this.rand = rand || new brorand.Rand();
	}
	var mr = MillerRabin;

	MillerRabin.create = function create(rand) {
	  return new MillerRabin(rand);
	};

	MillerRabin.prototype._randbelow = function _randbelow(n) {
	  var len = n.bitLength();
	  var min_bytes = Math.ceil(len / 8);

	  // Generage random bytes until a number less than n is found.
	  // This ensures that 0..n-1 have an equal probability of being selected.
	  do
	    var a = new bn(this.rand.generate(min_bytes));
	  while (a.cmp(n) >= 0);

	  return a;
	};

	MillerRabin.prototype._randrange = function _randrange(start, stop) {
	  // Generate a random number greater than or equal to start and less than stop.
	  var size = stop.sub(start);
	  return start.add(this._randbelow(size));
	};

	MillerRabin.prototype.test = function test(n, k, cb) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  var prime = true;
	  for (; k > 0; k--) {
	    var a = this._randrange(new bn(2), n1);
	    if (cb)
	      cb(a);

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return false;
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s)
	      return false;
	  }

	  return prime;
	};

	MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  for (; k > 0; k--) {
	    var a = this._randrange(new bn(2), n1);

	    var g = n.gcd(a);
	    if (g.cmpn(1) !== 0)
	      return g;

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return x.fromRed().subn(1).gcd(n);
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s) {
	      x = x.redSqr();
	      return x.fromRed().subn(1).gcd(n);
	    }
	  }

	  return false;
	};

	var generatePrime = findPrime;
	findPrime.simpleSieve = simpleSieve;
	findPrime.fermatTest = fermatTest;

	var TWENTYFOUR = new bn(24);

	var millerRabin = new mr();
	var ONE = new bn(1);
	var TWO = new bn(2);
	var FIVE = new bn(5);
	var SIXTEEN = new bn(16);
	var EIGHT = new bn(8);
	var TEN = new bn(10);
	var THREE = new bn(3);
	var SEVEN = new bn(7);
	var ELEVEN = new bn(11);
	var FOUR = new bn(4);
	var TWELVE = new bn(12);
	var primes = null;

	function _getPrimes() {
	  if (primes !== null)
	    return primes;

	  var limit = 0x100000;
	  var res = [];
	  res[0] = 2;
	  for (var i = 1, k = 3; k < limit; k += 2) {
	    var sqrt = Math.ceil(Math.sqrt(k));
	    for (var j = 0; j < i && res[j] <= sqrt; j++)
	      if (k % res[j] === 0)
	        break;

	    if (i !== j && res[j] <= sqrt)
	      continue;

	    res[i++] = k;
	  }
	  primes = res;
	  return res;
	}

	function simpleSieve(p) {
	  var primes = _getPrimes();

	  for (var i = 0; i < primes.length; i++)
	    if (p.modn(primes[i]) === 0) {
	      if (p.cmpn(primes[i]) === 0) {
	        return true;
	      } else {
	        return false;
	      }
	    }

	  return true;
	}

	function fermatTest(p) {
	  var red = bn.mont(p);
	  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
	}

	function findPrime(bits, gen) {
	  if (bits < 16) {
	    // this is what openssl does
	    if (gen === 2 || gen === 5) {
	      return new bn([0x8c, 0x7b]);
	    } else {
	      return new bn([0x8c, 0x27]);
	    }
	  }
	  gen = new bn(gen);

	  var num, n2;

	  while (true) {
	    num = new bn(browser(Math.ceil(bits / 8)));
	    while (num.bitLength() > bits) {
	      num.ishrn(1);
	    }
	    if (num.isEven()) {
	      num.iadd(ONE);
	    }
	    if (!num.testn(1)) {
	      num.iadd(TWO);
	    }
	    if (!gen.cmp(TWO)) {
	      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
	        num.iadd(FOUR);
	      }
	    } else if (!gen.cmp(FIVE)) {
	      while (num.mod(TEN).cmp(THREE)) {
	        num.iadd(FOUR);
	      }
	    }
	    n2 = num.shrn(1);
	    if (simpleSieve(n2) && simpleSieve(num) &&
	      fermatTest(n2) && fermatTest(num) &&
	      millerRabin.test(n2) && millerRabin.test(num)) {
	      return num;
	    }
	  }

	}

	var modp1 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
	};
	var modp2 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
	};
	var modp5 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
	};
	var modp14 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
	};
	var modp15 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
	};
	var modp16 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
	};
	var modp17 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
	};
	var modp18 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
	};
	var primes$1 = {
		modp1: modp1,
		modp2: modp2,
		modp5: modp5,
		modp14: modp14,
		modp15: modp15,
		modp16: modp16,
		modp17: modp17,
		modp18: modp18
	};

	var primes$2 = /*#__PURE__*/Object.freeze({
		modp1: modp1,
		modp2: modp2,
		modp5: modp5,
		modp14: modp14,
		modp15: modp15,
		modp16: modp16,
		modp17: modp17,
		modp18: modp18,
		default: primes$1
	});

	var millerRabin$1 = new mr();
	var TWENTYFOUR$1 = new bn(24);
	var ELEVEN$1 = new bn(11);
	var TEN$1 = new bn(10);
	var THREE$1 = new bn(3);
	var SEVEN$1 = new bn(7);


	var dh = DH;

	function setPublicKey(pub, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(pub)) {
	    pub = new Buffer(pub, enc);
	  }
	  this._pub = new bn(pub);
	  return this;
	}

	function setPrivateKey(priv, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(priv)) {
	    priv = new Buffer(priv, enc);
	  }
	  this._priv = new bn(priv);
	  return this;
	}

	var primeCache = {};
	function checkPrime(prime, generator) {
	  var gen = generator.toString('hex');
	  var hex = [gen, prime.toString(16)].join('_');
	  if (hex in primeCache) {
	    return primeCache[hex];
	  }
	  var error = 0;

	  if (prime.isEven() ||
	    !generatePrime.simpleSieve ||
	    !generatePrime.fermatTest(prime) ||
	    !millerRabin$1.test(prime)) {
	    //not a prime so +1
	    error += 1;

	    if (gen === '02' || gen === '05') {
	      // we'd be able to check the generator
	      // it would fail so +8
	      error += 8;
	    } else {
	      //we wouldn't be able to test the generator
	      // so +4
	      error += 4;
	    }
	    primeCache[hex] = error;
	    return error;
	  }
	  if (!millerRabin$1.test(prime.shrn(1))) {
	    //not a safe prime
	    error += 2;
	  }
	  var rem;
	  switch (gen) {
	    case '02':
	      if (prime.mod(TWENTYFOUR$1).cmp(ELEVEN$1)) {
	        // unsuidable generator
	        error += 8;
	      }
	      break;
	    case '05':
	      rem = prime.mod(TEN$1);
	      if (rem.cmp(THREE$1) && rem.cmp(SEVEN$1)) {
	        // prime mod 10 needs to equal 3 or 7
	        error += 8;
	      }
	      break;
	    default:
	      error += 4;
	  }
	  primeCache[hex] = error;
	  return error;
	}

	function DH(prime, generator, malleable) {
	  this.setGenerator(generator);
	  this.__prime = new bn(prime);
	  this._prime = bn.mont(this.__prime);
	  this._primeLen = prime.length;
	  this._pub = undefined;
	  this._priv = undefined;
	  this._primeCode = undefined;
	  if (malleable) {
	    this.setPublicKey = setPublicKey;
	    this.setPrivateKey = setPrivateKey;
	  } else {
	    this._primeCode = 8;
	  }
	}
	Object.defineProperty(DH.prototype, 'verifyError', {
	  enumerable: true,
	  get: function () {
	    if (typeof this._primeCode !== 'number') {
	      this._primeCode = checkPrime(this.__prime, this.__gen);
	    }
	    return this._primeCode;
	  }
	});
	DH.prototype.generateKeys = function () {
	  if (!this._priv) {
	    this._priv = new bn(browser(this._primeLen));
	  }
	  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
	  return this.getPublicKey();
	};

	DH.prototype.computeSecret = function (other) {
	  other = new bn(other);
	  other = other.toRed(this._prime);
	  var secret = other.redPow(this._priv).fromRed();
	  var out = new Buffer(secret.toArray());
	  var prime = this.getPrime();
	  if (out.length < prime.length) {
	    var front = new Buffer(prime.length - out.length);
	    front.fill(0);
	    out = Buffer.concat([front, out]);
	  }
	  return out;
	};

	DH.prototype.getPublicKey = function getPublicKey(enc) {
	  return formatReturnValue(this._pub, enc);
	};

	DH.prototype.getPrivateKey = function getPrivateKey(enc) {
	  return formatReturnValue(this._priv, enc);
	};

	DH.prototype.getPrime = function (enc) {
	  return formatReturnValue(this.__prime, enc);
	};

	DH.prototype.getGenerator = function (enc) {
	  return formatReturnValue(this._gen, enc);
	};

	DH.prototype.setGenerator = function (gen, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(gen)) {
	    gen = new Buffer(gen, enc);
	  }
	  this.__gen = gen;
	  this._gen = new bn(gen);
	  return this;
	};

	function formatReturnValue(bn$$1, enc) {
	  var buf = new Buffer(bn$$1.toArray());
	  if (!enc) {
	    return buf;
	  } else {
	    return buf.toString(enc);
	  }
	}

	var primes$3 = ( primes$2 && primes$1 ) || primes$2;

	var browser$7 = createCommonjsModule(function (module, exports) {
	function getDiffieHellman (mod) {
	  var prime = new Buffer(primes$3[mod].prime, 'hex');
	  var gen = new Buffer(primes$3[mod].gen, 'hex');

	  return new dh(prime, gen)
	}

	var ENCODINGS = {
	  'binary': true, 'hex': true, 'base64': true
	};

	function createDiffieHellman (prime, enc, generator, genc) {
	  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
	    return createDiffieHellman(prime, 'binary', enc, generator)
	  }

	  enc = enc || 'binary';
	  genc = genc || 'binary';
	  generator = generator || new Buffer([2]);

	  if (!Buffer.isBuffer(generator)) {
	    generator = new Buffer(generator, genc);
	  }

	  if (typeof prime === 'number') {
	    return new dh(generatePrime(prime, generator), generator, true)
	  }

	  if (!Buffer.isBuffer(prime)) {
	    prime = new Buffer(prime, enc);
	  }

	  return new dh(prime, generator, true)
	}

	exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
	exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
	});
	var browser_1$2 = browser$7.DiffieHellmanGroup;
	var browser_2$2 = browser$7.createDiffieHellmanGroup;
	var browser_3$2 = browser$7.getDiffieHellman;
	var browser_4$2 = browser$7.createDiffieHellman;
	var browser_5$2 = browser$7.DiffieHellman;

	var browserifyRsa = crt;
	function blind(priv) {
	  var r = getr(priv);
	  var blinder = r.toRed(bn.mont(priv.modulus))
	  .redPow(new bn(priv.publicExponent)).fromRed();
	  return {
	    blinder: blinder,
	    unblinder:r.invm(priv.modulus)
	  };
	}
	function crt(msg, priv) {
	  var blinds = blind(priv);
	  var len = priv.modulus.byteLength();
	  var mod = bn.mont(priv.modulus);
	  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
	  var c1 = blinded.toRed(bn.mont(priv.prime1));
	  var c2 = blinded.toRed(bn.mont(priv.prime2));
	  var qinv = priv.coefficient;
	  var p = priv.prime1;
	  var q = priv.prime2;
	  var m1 = c1.redPow(priv.exponent1);
	  var m2 = c2.redPow(priv.exponent2);
	  m1 = m1.fromRed();
	  m2 = m2.fromRed();
	  var h = m1.isub(m2).imul(qinv).umod(p);
	  h.imul(q);
	  m2.iadd(h);
	  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
	}
	crt.getr = getr;
	function getr(priv) {
	  var len = priv.modulus.byteLength();
	  var r = new bn(browser(len));
	  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
	    r = new bn(browser(len));
	  }
	  return r;
	}

	var _args = [
		[
			"elliptic@6.4.0",
			"/Users/paulgrau/projects/aergo/herajs"
		]
	];
	var _development = true;
	var _from = "elliptic@6.4.0";
	var _id = "elliptic@6.4.0";
	var _inBundle = false;
	var _integrity = "sha1-ysmvh2LIWDYYcAPI3+GT5eLq5d8=";
	var _location = "/elliptic";
	var _phantomChildren = {
	};
	var _requested = {
		type: "version",
		registry: true,
		raw: "elliptic@6.4.0",
		name: "elliptic",
		escapedName: "elliptic",
		rawSpec: "6.4.0",
		saveSpec: null,
		fetchSpec: "6.4.0"
	};
	var _requiredBy = [
		"/browserify-sign",
		"/create-ecdh"
	];
	var _resolved = "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz";
	var _spec = "6.4.0";
	var _where = "/Users/paulgrau/projects/aergo/herajs";
	var author = {
		name: "Fedor Indutny",
		email: "fedor@indutny.com"
	};
	var bugs = {
		url: "https://github.com/indutny/elliptic/issues"
	};
	var dependencies = {
		"bn.js": "^4.4.0",
		brorand: "^1.0.1",
		"hash.js": "^1.0.0",
		"hmac-drbg": "^1.0.0",
		inherits: "^2.0.1",
		"minimalistic-assert": "^1.0.0",
		"minimalistic-crypto-utils": "^1.0.0"
	};
	var description = "EC cryptography";
	var devDependencies = {
		brfs: "^1.4.3",
		coveralls: "^2.11.3",
		grunt: "^0.4.5",
		"grunt-browserify": "^5.0.0",
		"grunt-cli": "^1.2.0",
		"grunt-contrib-connect": "^1.0.0",
		"grunt-contrib-copy": "^1.0.0",
		"grunt-contrib-uglify": "^1.0.1",
		"grunt-mocha-istanbul": "^3.0.1",
		"grunt-saucelabs": "^8.6.2",
		istanbul: "^0.4.2",
		jscs: "^2.9.0",
		jshint: "^2.6.0",
		mocha: "^2.1.0"
	};
	var files = [
		"lib"
	];
	var homepage = "https://github.com/indutny/elliptic";
	var keywords = [
		"EC",
		"Elliptic",
		"curve",
		"Cryptography"
	];
	var license = "MIT";
	var main = "lib/elliptic.js";
	var name = "elliptic";
	var repository = {
		type: "git",
		url: "git+ssh://git@github.com/indutny/elliptic.git"
	};
	var scripts = {
		jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		lint: "npm run jscs && npm run jshint",
		test: "npm run lint && npm run unit",
		unit: "istanbul test _mocha --reporter=spec test/index.js",
		version: "grunt dist && git add dist/"
	};
	var version$1 = "6.4.0";
	var _package = {
		_args: _args,
		_development: _development,
		_from: _from,
		_id: _id,
		_inBundle: _inBundle,
		_integrity: _integrity,
		_location: _location,
		_phantomChildren: _phantomChildren,
		_requested: _requested,
		_requiredBy: _requiredBy,
		_resolved: _resolved,
		_spec: _spec,
		_where: _where,
		author: author,
		bugs: bugs,
		dependencies: dependencies,
		description: description,
		devDependencies: devDependencies,
		files: files,
		homepage: homepage,
		keywords: keywords,
		license: license,
		main: main,
		name: name,
		repository: repository,
		scripts: scripts,
		version: version$1
	};

	var _package$1 = /*#__PURE__*/Object.freeze({
		_args: _args,
		_development: _development,
		_from: _from,
		_id: _id,
		_inBundle: _inBundle,
		_integrity: _integrity,
		_location: _location,
		_phantomChildren: _phantomChildren,
		_requested: _requested,
		_requiredBy: _requiredBy,
		_resolved: _resolved,
		_spec: _spec,
		_where: _where,
		author: author,
		bugs: bugs,
		dependencies: dependencies,
		description: description,
		devDependencies: devDependencies,
		files: files,
		homepage: homepage,
		keywords: keywords,
		license: license,
		main: main,
		name: name,
		repository: repository,
		scripts: scripts,
		version: version$1,
		default: _package
	});

	var utils_1 = createCommonjsModule(function (module, exports) {

	var utils = exports;

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg !== 'string') {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	    return res;
	  }
	  if (enc === 'hex') {
	    msg = msg.replace(/[^a-z0-9]+/ig, '');
	    if (msg.length % 2 !== 0)
	      msg = '0' + msg;
	    for (var i = 0; i < msg.length; i += 2)
	      res.push(parseInt(msg[i] + msg[i + 1], 16));
	  } else {
	    for (var i = 0; i < msg.length; i++) {
	      var c = msg.charCodeAt(i);
	      var hi = c >> 8;
	      var lo = c & 0xff;
	      if (hi)
	        res.push(hi, lo);
	      else
	        res.push(lo);
	    }
	  }
	  return res;
	}
	utils.toArray = toArray;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	};
	});

	var utils_1$1 = createCommonjsModule(function (module, exports) {

	var utils = exports;




	utils.assert = minimalisticAssert;
	utils.toArray = utils_1.toArray;
	utils.zero2 = utils_1.zero2;
	utils.toHex = utils_1.toHex;
	utils.encode = utils_1.encode;

	// Represent num in a w-NAF form
	function getNAF(num, w) {
	  var naf = [];
	  var ws = 1 << (w + 1);
	  var k = num.clone();
	  while (k.cmpn(1) >= 0) {
	    var z;
	    if (k.isOdd()) {
	      var mod = k.andln(ws - 1);
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }
	    naf.push(z);

	    // Optimization, shift by word if possible
	    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
	    for (var i = 1; i < shift; i++)
	      naf.push(0);
	    k.iushrn(shift);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    []
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      var m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      var m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.iushrn(1);
	    k2.iushrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;

	function cachedProperty(obj, name, computer) {
	  var key = '_' + name;
	  obj.prototype[name] = function cachedProperty() {
	    return this[key] !== undefined ? this[key] :
	           this[key] = computer.call(this);
	  };
	}
	utils.cachedProperty = cachedProperty;

	function parseBytes(bytes) {
	  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
	                                     bytes;
	}
	utils.parseBytes = parseBytes;

	function intFromLE(bytes) {
	  return new bn(bytes, 'hex', 'le');
	}
	utils.intFromLE = intFromLE;
	});

	var utils$3 = elliptic_1.utils;
	var getNAF = utils$3.getNAF;
	var getJSF = utils$3.getJSF;
	var assert$1 = utils$3.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new bn(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

	  // Useful for many curves
	  this.zero = new bn(0).toRed(this.red);
	  this.one = new bn(1).toRed(this.red);
	  this.two = new bn(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new bn(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	var base = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert$1(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  for (var j = 0; j < naf.length; j += doubles.step) {
	    var nafW = 0;
	    for (var k = j + doubles.step - 1; k >= j; k--)
	      nafW = (nafW << 1) + naf[k];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (var j = 0; j < repr.length; j++) {
	      var nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var k = 0; i >= 0 && naf[i] === 0; i--)
	      k++;
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert$1(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	                                                       points,
	                                                       coeffs,
	                                                       len,
	                                                       jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  for (var i = 0; i < len; i++) {
	    var p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (var i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a]);
	      naf[b] = getNAF(coeffs[b], wndWidth[b]);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b] /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (var j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (var i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (var j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (var j = 0; j < len; j++) {
	      var z = tmp[j];
	      var p;
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (var i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils$3.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert$1(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert$1(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	                          bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils$3.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};

	var Base = curve_1.base;

	var assert$2 = elliptic_1.utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits_browser(ShortCurve, Base);
	var short_1 = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new bn(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new bn(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new bn(vec.a, 16),
	        b: new bn(vec.b, 16)
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : bn.mont(num);
	  var tinv = new bn(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new bn(1);
	  var y1 = new bn(0);
	  var x2 = new bn(0);
	  var y2 = new bn(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 }
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	  var npoints = this._endoWnafT1;
	  var ncoeffs = this._endoWnafT2;
	  for (var i = 0; i < points.length; i++) {
	    var split = this._endoSplit(coeffs[i]);
	    var p = points[i];
	    var beta = p._getBeta();

	    if (split.k1.negative) {
	      split.k1.ineg();
	      p = p.neg(true);
	    }
	    if (split.k2.negative) {
	      split.k2.ineg();
	      beta = beta.neg(true);
	    }

	    npoints[i * 2] = p;
	    npoints[i * 2 + 1] = beta;
	    ncoeffs[i * 2] = split.k1;
	    ncoeffs[i * 2 + 1] = split.k2;
	  }
	  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	  // Clean-up references to points and coefficients
	  for (var j = 0; j < i * 2; j++) {
	    npoints[j] = null;
	    ncoeffs[j] = null;
	  }
	  return res;
	};

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits_browser(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul)
	      }
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1)
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1)
	    }
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point))
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point))
	    }
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new bn(k, 16);

	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate)
	      }
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new bn(0);
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = new bn(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits_browser(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (var i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (var i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new bn(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	  return false;
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	var Base$1 = curve_1.base;


	var utils$4 = elliptic_1.utils;

	function MontCurve(conf) {
	  Base$1.call(this, 'mont', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.i4 = new bn(4).toRed(this.red).redInvm();
	  this.two = new bn(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits_browser(MontCurve, Base$1);
	var mont = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point$1(curve, x, z) {
	  Base$1.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new bn(x, 16);
	    this.z = new bn(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits_browser(Point$1, Base$1.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils$4.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point$1(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point$1.fromJSON(this, obj);
	};

	Point$1.prototype.precompute = function precompute() {
	  // No-op
	};

	Point$1.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point$1.fromJSON = function fromJSON(curve, obj) {
	  return new Point$1(curve, obj[0], obj[1] || curve.one);
	};

	Point$1.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point$1.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point$1.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point$1.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point$1.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point$1.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point$1.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point$1.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};

	var Base$2 = curve_1.base;

	var assert$3 = elliptic_1.utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base$2.call(this, 'edwards', conf);

	  this.a = new bn(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new bn(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new bn(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert$3(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits_browser(EdwardsCurve, Base$2);
	var edwards = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new bn(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - 1) / (d y^2 + 1)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.one);
	  var rhs = y2.redMul(this.d).redAdd(this.one);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point$2(curve, x, y, z, t) {
	  Base$2.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = z ? new bn(z, 16) : this.curve.one;
	    this.t = t && new bn(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits_browser(Point$2, Base$2.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point$2.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point$2(this, x, y, z, t);
	};

	Point$2.fromJSON = function fromJSON(curve, obj) {
	  return new Point$2(curve, obj[0], obj[1], obj[2]);
	};

	Point$2.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point$2.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	         this.y.cmp(this.z) === 0;
	};

	Point$2.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point$2.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // E = a * C
	    var e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      var h = this.z.redSqr();
	      // J = F - 2 * H
	      var j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    var e = c.redAdd(d);
	    // H = (c * Z1)^2
	    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
	    // J = E - 2 * H
	    var j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point$2.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point$2.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point$2.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point$2.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point$2.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point$2.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point$2.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point$2.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point$2.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	                          this.y,
	                          this.z,
	                          this.t && this.t.redNeg());
	};

	Point$2.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point$2.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point$2.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point$2.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	  return false;
	};

	// Compatibility with BaseCurve
	Point$2.prototype.toP = Point$2.prototype.normalize;
	Point$2.prototype.mixedAdd = Point$2.prototype.add;

	var curve_1 = createCommonjsModule(function (module, exports) {

	var curve = exports;

	curve.base = base;
	curve.short = short_1;
	curve.mont = mont;
	curve.edwards = edwards;
	});

	var inherits_1 = inherits_browser;

	function toArray$1(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        var hi = c >> 8;
	        var lo = c & 0xff;
	        if (hi)
	          res.push(hi, lo);
	        else
	          res.push(lo);
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	var toArray_1 = toArray$1;

	function toHex$1(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	var toHex_1 = toHex$1;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	var htonl_1 = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	var toHex32_1 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	var zero2_1 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	var zero8_1 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  minimalisticAssert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	var join32_1 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	var split32_1 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	var rotr32_1 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	var rotl32_1 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	var sum32_1 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	var sum32_3_1 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	var sum32_4_1 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	var sum32_5_1 = sum32_5;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	var sum64_1 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	}
	var sum64_hi_1 = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	}
	var sum64_lo_1 = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	var sum64_4_hi_1 = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	var sum64_4_lo_1 = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	var sum64_5_hi_1 = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	}
	var sum64_5_lo_1 = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}
	var rotr64_hi_1 = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	var rotr64_lo_1 = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}
	var shr64_hi_1 = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	var shr64_lo_1 = shr64_lo;

	var utils$5 = {
		inherits: inherits_1,
		toArray: toArray_1,
		toHex: toHex_1,
		htonl: htonl_1,
		toHex32: toHex32_1,
		zero2: zero2_1,
		zero8: zero8_1,
		join32: join32_1,
		split32: split32_1,
		rotr32: rotr32_1,
		rotl32: rotl32_1,
		sum32: sum32_1,
		sum32_3: sum32_3_1,
		sum32_4: sum32_4_1,
		sum32_5: sum32_5_1,
		sum64: sum64_1,
		sum64_hi: sum64_hi_1,
		sum64_lo: sum64_lo_1,
		sum64_4_hi: sum64_4_hi_1,
		sum64_4_lo: sum64_4_lo_1,
		sum64_5_hi: sum64_5_hi_1,
		sum64_5_lo: sum64_5_lo_1,
		rotr64_hi: rotr64_hi_1,
		rotr64_lo: rotr64_lo_1,
		shr64_hi: shr64_hi_1,
		shr64_lo: shr64_lo_1
	};

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	var BlockHash_1 = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils$5.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils$5.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  minimalisticAssert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};

	var common = {
		BlockHash: BlockHash_1
	};

	var rotr32$1 = utils$5.rotr32;

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}
	var ft_1_1 = ft_1;

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}
	var ch32_1 = ch32;

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}
	var maj32_1 = maj32;

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	var p32_1 = p32;

	function s0_256(x) {
	  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);
	}
	var s0_256_1 = s0_256;

	function s1_256(x) {
	  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);
	}
	var s1_256_1 = s1_256;

	function g0_256(x) {
	  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);
	}
	var g0_256_1 = g0_256;

	function g1_256(x) {
	  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);
	}
	var g1_256_1 = g1_256;

	var common$1 = {
		ft_1: ft_1_1,
		ch32: ch32_1,
		maj32: maj32_1,
		p32: p32_1,
		s0_256: s0_256_1,
		s1_256: s1_256_1,
		g0_256: g0_256_1,
		g1_256: g1_256_1
	};

	var rotl32$1 = utils$5.rotl32;
	var sum32$1 = utils$5.sum32;
	var sum32_5$1 = utils$5.sum32_5;
	var ft_1$1 = common$1.ft_1;
	var BlockHash$1 = common.BlockHash;

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash$1.call(this);
	  this.h = [
	    0x67452301, 0xefcdab89, 0x98badcfe,
	    0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils$5.inherits(SHA1, BlockHash$1);
	var _1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32$1(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32$1(this.h[0], a);
	  this.h[1] = sum32$1(this.h[1], b);
	  this.h[2] = sum32$1(this.h[2], c);
	  this.h[3] = sum32$1(this.h[3], d);
	  this.h[4] = sum32$1(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h, 'big');
	  else
	    return utils$5.split32(this.h, 'big');
	};

	var sum32$2 = utils$5.sum32;
	var sum32_4$1 = utils$5.sum32_4;
	var sum32_5$2 = utils$5.sum32_5;
	var ch32$1 = common$1.ch32;
	var maj32$1 = common$1.maj32;
	var s0_256$1 = common$1.s0_256;
	var s1_256$1 = common$1.s1_256;
	var g0_256$1 = common$1.g0_256;
	var g1_256$1 = common$1.g1_256;

	var BlockHash$2 = common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash$2.call(this);
	  this.h = [
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	  ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils$5.inherits(SHA256, BlockHash$2);
	var _256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  minimalisticAssert(this.k.length === W.length);
	  for (i = 0; i < W.length; i++) {
	    var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);
	    var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32$2(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32$2(T1, T2);
	  }

	  this.h[0] = sum32$2(this.h[0], a);
	  this.h[1] = sum32$2(this.h[1], b);
	  this.h[2] = sum32$2(this.h[2], c);
	  this.h[3] = sum32$2(this.h[3], d);
	  this.h[4] = sum32$2(this.h[4], e);
	  this.h[5] = sum32$2(this.h[5], f);
	  this.h[6] = sum32$2(this.h[6], g);
	  this.h[7] = sum32$2(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h, 'big');
	  else
	    return utils$5.split32(this.h, 'big');
	};

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  _256.call(this);
	  this.h = [
	    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils$5.inherits(SHA224, _256);
	var _224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils$5.split32(this.h.slice(0, 7), 'big');
	};

	var rotr64_hi$1 = utils$5.rotr64_hi;
	var rotr64_lo$1 = utils$5.rotr64_lo;
	var shr64_hi$1 = utils$5.shr64_hi;
	var shr64_lo$1 = utils$5.shr64_lo;
	var sum64$1 = utils$5.sum64;
	var sum64_hi$1 = utils$5.sum64_hi;
	var sum64_lo$1 = utils$5.sum64_lo;
	var sum64_4_hi$1 = utils$5.sum64_4_hi;
	var sum64_4_lo$1 = utils$5.sum64_4_lo;
	var sum64_5_hi$1 = utils$5.sum64_5_hi;
	var sum64_5_lo$1 = utils$5.sum64_5_lo;

	var BlockHash$3 = common.BlockHash;

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash$3.call(this);
	  this.h = [
	    0x6a09e667, 0xf3bcc908,
	    0xbb67ae85, 0x84caa73b,
	    0x3c6ef372, 0xfe94f82b,
	    0xa54ff53a, 0x5f1d36f1,
	    0x510e527f, 0xade682d1,
	    0x9b05688c, 0x2b3e6c1f,
	    0x1f83d9ab, 0xfb41bd6b,
	    0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils$5.inherits(SHA512, BlockHash$3);
	var _512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  minimalisticAssert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);

	    c0_hi = s0_512_hi(ah, al);
	    c0_lo = s0_512_lo(ah, al);
	    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
	    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64$1(this.h, 0, ah, al);
	  sum64$1(this.h, 2, bh, bl);
	  sum64$1(this.h, 4, ch, cl);
	  sum64$1(this.h, 6, dh, dl);
	  sum64$1(this.h, 8, eh, el);
	  sum64$1(this.h, 10, fh, fl);
	  sum64$1(this.h, 12, gh, gl);
	  sum64$1(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h, 'big');
	  else
	    return utils$5.split32(this.h, 'big');
	};

	function ch64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 28);
	  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 28);
	  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 14);
	  var c1_hi = rotr64_hi$1(xh, xl, 18);
	  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 14);
	  var c1_lo = rotr64_lo$1(xh, xl, 18);
	  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 1);
	  var c1_hi = rotr64_hi$1(xh, xl, 8);
	  var c2_hi = shr64_hi$1(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 1);
	  var c1_lo = rotr64_lo$1(xh, xl, 8);
	  var c2_lo = shr64_lo$1(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 19);
	  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi$1(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 19);
	  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo$1(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  _512.call(this);
	  this.h = [
	    0xcbbb9d5d, 0xc1059ed8,
	    0x629a292a, 0x367cd507,
	    0x9159015a, 0x3070dd17,
	    0x152fecd8, 0xf70e5939,
	    0x67332667, 0xffc00b31,
	    0x8eb44a87, 0x68581511,
	    0xdb0c2e0d, 0x64f98fa7,
	    0x47b5481d, 0xbefa4fa4 ];
	}
	utils$5.inherits(SHA384, _512);
	var _384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils$5.split32(this.h.slice(0, 12), 'big');
	};

	var sha1$1 = _1;
	var sha224$2 = _224;
	var sha256$2 = _256;
	var sha384$2 = _384;
	var sha512$2 = _512;

	var sha$1 = {
		sha1: sha1$1,
		sha224: sha224$2,
		sha256: sha256$2,
		sha384: sha384$2,
		sha512: sha512$2
	};

	var rotl32$2 = utils$5.rotl32;
	var sum32$3 = utils$5.sum32;
	var sum32_3$1 = utils$5.sum32_3;
	var sum32_4$2 = utils$5.sum32_4;
	var BlockHash$4 = common.BlockHash;

	function RIPEMD160$1() {
	  if (!(this instanceof RIPEMD160$1))
	    return new RIPEMD160$1();

	  BlockHash$4.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils$5.inherits(RIPEMD160$1, BlockHash$4);
	var ripemd160$1 = RIPEMD160$1;

	RIPEMD160$1.blockSize = 512;
	RIPEMD160$1.outSize = 160;
	RIPEMD160$1.hmacStrength = 192;
	RIPEMD160$1.padLength = 64;

	RIPEMD160$1.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32$3(
	      rotl32$2(
	        sum32_4$2(A, f(j, B, C, D), msg[r$1[j] + start], K$4(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32$2(C, 10);
	    C = B;
	    B = T;
	    T = sum32$3(
	      rotl32$2(
	        sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32$2(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3$1(this.h[1], C, Dh);
	  this.h[1] = sum32_3$1(this.h[2], D, Eh);
	  this.h[2] = sum32_3$1(this.h[3], E, Ah);
	  this.h[3] = sum32_3$1(this.h[4], A, Bh);
	  this.h[4] = sum32_3$1(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160$1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$5.toHex32(this.h, 'little');
	  else
	    return utils$5.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K$4(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r$1 = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var ripemd = {
		ripemd160: ripemd160$1
	};

	function Hmac$3(hash, key, enc) {
	  if (!(this instanceof Hmac$3))
	    return new Hmac$3(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils$5.toArray(key, enc));
	}
	var hmac = Hmac$3;

	Hmac$3.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  minimalisticAssert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac$3.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac$3.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};

	var hash_1 = createCommonjsModule(function (module, exports) {
	var hash = exports;

	hash.utils = utils$5;
	hash.common = common;
	hash.sha = sha$1;
	hash.ripemd = ripemd;
	hash.hmac = hmac;

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;
	});

	var secp256k1 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
	      ]
	    ]
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
	      ]
	    ]
	  }
	};

	var curves_1 = createCommonjsModule(function (module, exports) {

	var curves = exports;




	var assert = elliptic_1.utils.assert;

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new elliptic_1.curve.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new elliptic_1.curve.edwards(options);
	  else
	    this.curve = new elliptic_1.curve.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve
	      });
	      return curve;
	    }
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash_1.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
	  ]
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash_1.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
	  ]
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash_1.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
	  ]
	});

	defineCurve('p384', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 ffffffff',
	  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 fffffffc',
	  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
	     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
	  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
	     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
	  hash: hash_1.sha384,
	  gRed: false,
	  g: [
	    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
	    '5502f25d bf55296c 3a545e38 72760ab7',
	    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
	    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
	  ]
	});

	defineCurve('p521', {
	  type: 'short',
	  prime: null,
	  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff',
	  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff fffffffc',
	  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
	     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
	     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
	  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
	     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
	  hash: hash_1.sha512,
	  gRed: false,
	  g: [
	    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
	    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
	    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
	    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
	    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
	    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
	  ]
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '1',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash_1.sha256,
	  gRed: false,
	  g: [
	    '9'
	  ]
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash_1.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658'
	  ]
	});

	var pre;
	try {
	  pre = secp256k1;
	} catch (e) {
	  pre = undefined;
	}

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash_1.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3'
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15'
	    }
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    pre
	  ]
	});
	});

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this._reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
	  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
	  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
	  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	var hmacDrbg = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this._reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash_1.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils_1.toArray(entropy, entropyEnc);
	  add = utils_1.toArray(add, addEnc);

	  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this._reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this._reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils_1.toArray(add, addEnc || 'hex');
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this._reseed++;
	  return utils_1.encode(res, enc);
	};

	var utils$6 = elliptic_1.utils;
	var assert$4 = utils$6.assert;

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	var key$1 = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new bn(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    // Montgomery points only have an `x` coordinate.
	    // Weierstrass/Edwards points on the other hand have both `x` and
	    // `y` coordinates.
	    if (this.ec.curve.type === 'mont') {
	      assert$4(key.x, 'Need x coordinate');
	    } else if (this.ec.curve.type === 'short' ||
	               this.ec.curve.type === 'edwards') {
	      assert$4(key.x && key.y, 'Need both x and y coordinate');
	    }
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};

	var utils$7 = elliptic_1.utils;
	var assert$5 = utils$7.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert$5(options.r && options.s, 'Signature without r or s');
	  this.r = new bn(options.r, 16);
	  this.s = new bn(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	var signature = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;
	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	  }
	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils$7.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0 && (r[1] & 0x80)) {
	    r = r.slice(1);
	  }
	  if (s[0] === 0 && (s[1] & 0x80)) {
	    s = s.slice(1);
	  }

	  this.r = new bn(r);
	  this.s = new bn(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils$7.encode(res, enc);
	};

	var utils$8 = elliptic_1.utils;
	var assert$6 = utils$8.assert;




	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert$6(elliptic_1.curves.hasOwnProperty(options), 'Unknown curve ' + options);

	    options = elliptic_1.curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof elliptic_1.curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	var ec = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new key$1(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return key$1.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return key$1.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new hmacDrbg({
	    hash: this.hash,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	    entropy: options.entropy || elliptic_1.rand(this.hash.hmacStrength),
	    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
	    nonce: this.n.toArray()
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new bn(2));
	  do {
	    var priv = new bn(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  } while (true);
	};

	EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new bn(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray('be', bytes);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray('be', bytes);

	  // Instantiate Hmac_DRBG
	  var drbg = new hmacDrbg({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8'
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new bn(1));

	  for (var iter = 0; true; iter++) {
	    var k = options.k ?
	        options.k(iter) :
	        new bn(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new signature({ r: r, s: s, recoveryParam: recoveryParam });
	  }
	};

	EC.prototype.verify = function verify(msg, signature$$1, key, enc) {
	  msg = this._truncateToN(new bn(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature$$1 = new signature(signature$$1, 'hex');

	  // Perform primitive values validation
	  var r = signature$$1.r;
	  var s = signature$$1.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);

	  if (!this.curve._maxwellTrick) {
	    var p = this.g.mulAdd(u1, key.getPublic(), u2);
	    if (p.isInfinity())
	      return false;

	    return p.getX().umod(this.n).cmp(r) === 0;
	  }

	  // NOTE: Greg Maxwell's trick, inspired by:
	  // https://git.io/vad3K

	  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  // Compare `p.x` of Jacobian point with `r`,
	  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
	  // inverse of `p.z^2`
	  return p.eqXToP(r);
	};

	EC.prototype.recoverPubKey = function(msg, signature$$1, j, enc) {
	  assert$6((3 & j) === j, 'The recovery param is more than two bits');
	  signature$$1 = new signature(signature$$1, enc);

	  var n = this.n;
	  var e = new bn(msg);
	  var r = signature$$1.r;
	  var s = signature$$1.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var rInv = signature$$1.r.invm(n);
	  var s1 = n.sub(e).mul(rInv).umod(n);
	  var s2 = s.mul(rInv).umod(n);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  return this.g.mulAdd(s1, r, s2);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature$$1, Q, enc) {
	  signature$$1 = new signature(signature$$1, enc);
	  if (signature$$1.recoveryParam !== null)
	    return signature$$1.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime;
	    try {
	      Qprime = this.recoverPubKey(e, signature$$1, i);
	    } catch (e) {
	      continue;
	    }

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};

	var utils$9 = elliptic_1.utils;
	var assert$7 = utils$9.assert;
	var parseBytes = utils$9.parseBytes;
	var cachedProperty = utils$9.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair$1(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair$1)
	    return pub;
	  return new KeyPair$1(eddsa, { pub: pub });
	};

	KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair$1)
	    return secret;
	  return new KeyPair$1(eddsa, { secret: secret });
	};

	KeyPair$1.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair$1, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair$1, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair$1, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair$1, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair$1, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair$1, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair$1.prototype.sign = function sign(message) {
	  assert$7(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair$1.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair$1.prototype.getSecret = function getSecret(enc) {
	  assert$7(this._secret, 'KeyPair is public only');
	  return utils$9.encode(this.secret(), enc);
	};

	KeyPair$1.prototype.getPublic = function getPublic(enc) {
	  return utils$9.encode(this.pubBytes(), enc);
	};

	var key$2 = KeyPair$1;

	var utils$a = elliptic_1.utils;
	var assert$8 = utils$a.assert;
	var cachedProperty$1 = utils$a.cachedProperty;
	var parseBytes$1 = utils$a.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature$1(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes$1(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength)
	    };
	  }

	  assert$8(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof bn)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty$1(Signature$1, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty$1(Signature$1, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty$1(Signature$1, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty$1(Signature$1, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature$1.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature$1.prototype.toHex = function toHex() {
	  return utils$a.encode(this.toBytes(), 'hex').toUpperCase();
	};

	var signature$1 = Signature$1;

	var utils$b = elliptic_1.utils;
	var assert$9 = utils$b.assert;
	var parseBytes$2 = utils$b.parseBytes;



	function EDDSA(curve) {
	  assert$9(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  var curve = elliptic_1.curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash_1.sha512;
	}

	var eddsa = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes$2(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	               .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes$2(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils$b.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return key$2.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return key$2.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof signature$1)
	    return sig;
	  return new signature$1(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils$b.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils$b.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils$b.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};

	var require$$0$1 = ( _package$1 && _package ) || _package$1;

	var elliptic_1 = createCommonjsModule(function (module, exports) {

	var elliptic = exports;

	elliptic.version = require$$0$1.version;
	elliptic.utils = utils_1$1;
	elliptic.rand = brorand;
	elliptic.curve = curve_1;
	elliptic.curves = curves_1;

	// Protocols
	elliptic.ec = ec;
	elliptic.eddsa = eddsa;
	});

	/*
	from https://github.com/substack/vm-browserify/blob/bfd7c5f59edec856dc7efe0b77a4f6b2fa20f226/index.js

	MIT license no Copyright holder mentioned
	*/


	function Object_keys(obj) {
	  if (Object.keys) return Object.keys(obj)
	  else {
	    var res = [];
	    for (var key in obj) res.push(key);
	    return res;
	  }
	}

	function forEach$1(xs, fn) {
	  if (xs.forEach) return xs.forEach(fn)
	  else
	    for (var i = 0; i < xs.length; i++) {
	      fn(xs[i], i, xs);
	    }
	}
	var _defineProp;

	function defineProp(obj, name, value) {
	  if (typeof _defineProp !== 'function') {
	    _defineProp = createDefineProp;
	  }
	  _defineProp(obj, name, value);
	}

	function createDefineProp() {
	  try {
	    Object.defineProperty({}, '_', {});
	    return function(obj, name, value) {
	      Object.defineProperty(obj, name, {
	        writable: true,
	        enumerable: false,
	        configurable: true,
	        value: value
	      });
	    };
	  } catch (e) {
	    return function(obj, name, value) {
	      obj[name] = value;
	    };
	  }
	}

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	  'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	  'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	  'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	  'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'
	];

	function Context() {}
	Context.prototype = {};

	function Script(code) {
	  if (!(this instanceof Script)) return new Script(code);
	  this.code = code;
	}
	function otherRunInContext(code, context) {
	  var args = Object_keys(global);
	  args.push('with (this.__ctx__){return eval(this.__code__)}');
	  var fn = Function.apply(null, args);
	  return fn.apply({
	    __code__: code,
	    __ctx__: context
	  });
	}
	Script.prototype.runInContext = function(context) {
	  if (!(context instanceof Context)) {
	    throw new TypeError('needs a \'context\' argument.');
	  }
	  if (global.document) {
	    var iframe = global.document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';

	    global.document.body.appendChild(iframe);

	    var win = iframe.contentWindow;
	    var wEval = win.eval,
	      wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	      // win.eval() magically appears when this is called in IE:
	      wExecScript.call(win, 'null');
	      wEval = win.eval;
	    }

	    forEach$1(Object_keys(context), function(key) {
	      win[key] = context[key];
	    });
	    forEach$1(globals, function(key) {
	      if (context[key]) {
	        win[key] = context[key];
	      }
	    });

	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);

	    forEach$1(Object_keys(win), function(key) {
	      // Avoid copying circular objects like `top` and `window` by only
	      // updating existing context properties or new properties in the `win`
	      // that was only introduced after the eval.
	      if (key in context || indexOf$1(winKeys, key) === -1) {
	        context[key] = win[key];
	      }
	    });

	    forEach$1(globals, function(key) {
	      if (!(key in context)) {
	        defineProp(context, key, win[key]);
	      }
	    });
	    global.document.body.removeChild(iframe);

	    return res;
	  }
	  return otherRunInContext(this.code, context);
	};

	Script.prototype.runInThisContext = function() {
	  var fn = new Function('code', 'return eval(code);');
	  return fn.call(global, this.code); // maybe...
	};

	Script.prototype.runInNewContext = function(context) {
	  var ctx = createContext(context);
	  var res = this.runInContext(ctx);
	  if (context) {
	    forEach$1(Object_keys(ctx), function(key) {
	      context[key] = ctx[key];
	    });
	  }

	  return res;
	};


	function createScript(code) {
	  return new Script(code);
	}

	function createContext(context) {
	  if (isContext(context)) {
	    return context;
	  }
	  var copy = new Context();
	  if (typeof context === 'object') {
	    forEach$1(Object_keys(context), function(key) {
	      copy[key] = context[key];
	    });
	  }
	  return copy;
	}
	function runInContext(code, contextifiedSandbox, options) {
	  var script = new Script(code, options);
	  return script.runInContext(contextifiedSandbox, options);
	}
	function runInThisContext(code, options) {
	  var script = new Script(code, options);
	  return script.runInThisContext(options);
	}
	function isContext(context) {
	  return context instanceof Context;
	}
	function runInNewContext(code, sandbox, options) {
	  var script = new Script(code, options);
	  return script.runInNewContext(sandbox, options);
	}
	var vm = {
	  runInContext: runInContext,
	  isContext: isContext,
	  createContext: createContext,
	  createScript: createScript,
	  Script: Script,
	  runInThisContext: runInThisContext,
	  runInNewContext: runInNewContext
	};


	/*
	from indexOf
	@ author tjholowaychuk
	@ license MIT
	*/
	var _indexOf = [].indexOf;

	function indexOf$1(arr, obj){
	  if (_indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}

	var vm$1 = /*#__PURE__*/Object.freeze({
		Script: Script,
		createScript: createScript,
		createContext: createContext,
		runInContext: runInContext,
		runInThisContext: runInThisContext,
		isContext: isContext,
		runInNewContext: runInNewContext,
		default: vm
	});

	var require$$0$2 = ( vm$1 && vm ) || vm$1;

	var api_1 = createCommonjsModule(function (module, exports) {
	var api = exports;

	api.define = function define(name, body) {
	  return new Entity(name, body);
	};

	function Entity(name, body) {
	  this.name = name;
	  this.body = body;

	  this.decoders = {};
	  this.encoders = {};
	}
	Entity.prototype._createNamed = function createNamed(base) {
	  var named;
	  try {
	    named = require$$0$2.runInThisContext(
	      '(function ' + this.name + '(entity) {\n' +
	      '  this._initNamed(entity);\n' +
	      '})'
	    );
	  } catch (e) {
	    named = function (entity) {
	      this._initNamed(entity);
	    };
	  }
	  inherits_browser(named, base);
	  named.prototype._initNamed = function initnamed(entity) {
	    base.call(this, entity);
	  };

	  return new named(this);
	};

	Entity.prototype._getDecoder = function _getDecoder(enc) {
	  enc = enc || 'der';
	  // Lazily create decoder
	  if (!this.decoders.hasOwnProperty(enc))
	    this.decoders[enc] = this._createNamed(asn1_1.decoders[enc]);
	  return this.decoders[enc];
	};

	Entity.prototype.decode = function decode(data, enc, options) {
	  return this._getDecoder(enc).decode(data, options);
	};

	Entity.prototype._getEncoder = function _getEncoder(enc) {
	  enc = enc || 'der';
	  // Lazily create encoder
	  if (!this.encoders.hasOwnProperty(enc))
	    this.encoders[enc] = this._createNamed(asn1_1.encoders[enc]);
	  return this.encoders[enc];
	};

	Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
	  return this._getEncoder(enc).encode(data, reporter);
	};
	});

	function Reporter(options) {
	  this._reporterState = {
	    obj: null,
	    path: [],
	    options: options || {},
	    errors: []
	  };
	}
	var Reporter_1 = Reporter;

	Reporter.prototype.isError = function isError(obj) {
	  return obj instanceof ReporterError;
	};

	Reporter.prototype.save = function save() {
	  var state = this._reporterState;

	  return { obj: state.obj, pathLen: state.path.length };
	};

	Reporter.prototype.restore = function restore(data) {
	  var state = this._reporterState;

	  state.obj = data.obj;
	  state.path = state.path.slice(0, data.pathLen);
	};

	Reporter.prototype.enterKey = function enterKey(key) {
	  return this._reporterState.path.push(key);
	};

	Reporter.prototype.exitKey = function exitKey(index) {
	  var state = this._reporterState;

	  state.path = state.path.slice(0, index - 1);
	};

	Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
	  var state = this._reporterState;

	  this.exitKey(index);
	  if (state.obj !== null)
	    state.obj[key] = value;
	};

	Reporter.prototype.path = function path() {
	  return this._reporterState.path.join('/');
	};

	Reporter.prototype.enterObject = function enterObject() {
	  var state = this._reporterState;

	  var prev = state.obj;
	  state.obj = {};
	  return prev;
	};

	Reporter.prototype.leaveObject = function leaveObject(prev) {
	  var state = this._reporterState;

	  var now = state.obj;
	  state.obj = prev;
	  return now;
	};

	Reporter.prototype.error = function error(msg) {
	  var err;
	  var state = this._reporterState;

	  var inherited = msg instanceof ReporterError;
	  if (inherited) {
	    err = msg;
	  } else {
	    err = new ReporterError(state.path.map(function(elem) {
	      return '[' + JSON.stringify(elem) + ']';
	    }).join(''), msg.message || msg, msg.stack);
	  }

	  if (!state.options.partial)
	    throw err;

	  if (!inherited)
	    state.errors.push(err);

	  return err;
	};

	Reporter.prototype.wrapResult = function wrapResult(result) {
	  var state = this._reporterState;
	  if (!state.options.partial)
	    return result;

	  return {
	    result: this.isError(result) ? null : result,
	    errors: state.errors
	  };
	};

	function ReporterError(path, msg) {
	  this.path = path;
	  this.rethrow(msg);
	}inherits_browser(ReporterError, Error);

	ReporterError.prototype.rethrow = function rethrow(msg) {
	  this.message = msg + ' at: ' + (this.path || '(shallow)');
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, ReporterError);

	  if (!this.stack) {
	    try {
	      // IE only adds stack when thrown
	      throw new Error(this.message);
	    } catch (e) {
	      this.stack = e.stack;
	    }
	  }
	  return this;
	};

	var reporter = {
		Reporter: Reporter_1
	};

	var Reporter$1 = base_1.Reporter;
	var Buffer$t = require$$0.Buffer;

	function DecoderBuffer(base, options) {
	  Reporter$1.call(this, options);
	  if (!Buffer$t.isBuffer(base)) {
	    this.error('Input not Buffer');
	    return;
	  }

	  this.base = base;
	  this.offset = 0;
	  this.length = base.length;
	}
	inherits_browser(DecoderBuffer, Reporter$1);
	var DecoderBuffer_1 = DecoderBuffer;

	DecoderBuffer.prototype.save = function save() {
	  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
	};

	DecoderBuffer.prototype.restore = function restore(save) {
	  // Return skipped data
	  var res = new DecoderBuffer(this.base);
	  res.offset = save.offset;
	  res.length = this.offset;

	  this.offset = save.offset;
	  Reporter$1.prototype.restore.call(this, save.reporter);

	  return res;
	};

	DecoderBuffer.prototype.isEmpty = function isEmpty() {
	  return this.offset === this.length;
	};

	DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
	  if (this.offset + 1 <= this.length)
	    return this.base.readUInt8(this.offset++, true);
	  else
	    return this.error(fail || 'DecoderBuffer overrun');
	};

	DecoderBuffer.prototype.skip = function skip(bytes, fail) {
	  if (!(this.offset + bytes <= this.length))
	    return this.error(fail || 'DecoderBuffer overrun');

	  var res = new DecoderBuffer(this.base);

	  // Share reporter state
	  res._reporterState = this._reporterState;

	  res.offset = this.offset;
	  res.length = this.offset + bytes;
	  this.offset += bytes;
	  return res;
	};

	DecoderBuffer.prototype.raw = function raw(save) {
	  return this.base.slice(save ? save.offset : this.offset, this.length);
	};

	function EncoderBuffer(value, reporter) {
	  if (Array.isArray(value)) {
	    this.length = 0;
	    this.value = value.map(function(item) {
	      if (!(item instanceof EncoderBuffer))
	        item = new EncoderBuffer(item, reporter);
	      this.length += item.length;
	      return item;
	    }, this);
	  } else if (typeof value === 'number') {
	    if (!(0 <= value && value <= 0xff))
	      return reporter.error('non-byte EncoderBuffer value');
	    this.value = value;
	    this.length = 1;
	  } else if (typeof value === 'string') {
	    this.value = value;
	    this.length = Buffer$t.byteLength(value);
	  } else if (Buffer$t.isBuffer(value)) {
	    this.value = value;
	    this.length = value.length;
	  } else {
	    return reporter.error('Unsupported type: ' + typeof value);
	  }
	}
	var EncoderBuffer_1 = EncoderBuffer;

	EncoderBuffer.prototype.join = function join(out, offset) {
	  if (!out)
	    out = new Buffer$t(this.length);
	  if (!offset)
	    offset = 0;

	  if (this.length === 0)
	    return out;

	  if (Array.isArray(this.value)) {
	    this.value.forEach(function(item) {
	      item.join(out, offset);
	      offset += item.length;
	    });
	  } else {
	    if (typeof this.value === 'number')
	      out[offset] = this.value;
	    else if (typeof this.value === 'string')
	      out.write(this.value, offset);
	    else if (Buffer$t.isBuffer(this.value))
	      this.value.copy(out, offset);
	    offset += this.length;
	  }

	  return out;
	};

	var buffer = {
		DecoderBuffer: DecoderBuffer_1,
		EncoderBuffer: EncoderBuffer_1
	};

	var Reporter$2 = base_1.Reporter;
	var EncoderBuffer$1 = base_1.EncoderBuffer;
	var DecoderBuffer$1 = base_1.DecoderBuffer;


	// Supported tags
	var tags = [
	  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
	  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
	  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
	  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
	];

	// Public methods list
	var methods = [
	  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
	  'any', 'contains'
	].concat(tags);

	// Overrided methods list
	var overrided = [
	  '_peekTag', '_decodeTag', '_use',
	  '_decodeStr', '_decodeObjid', '_decodeTime',
	  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

	  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
	  '_encodeNull', '_encodeInt', '_encodeBool'
	];

	function Node(enc, parent) {
	  var state = {};
	  this._baseState = state;

	  state.enc = enc;

	  state.parent = parent || null;
	  state.children = null;

	  // State
	  state.tag = null;
	  state.args = null;
	  state.reverseArgs = null;
	  state.choice = null;
	  state.optional = false;
	  state.any = false;
	  state.obj = false;
	  state.use = null;
	  state.useDecoder = null;
	  state.key = null;
	  state['default'] = null;
	  state.explicit = null;
	  state.implicit = null;
	  state.contains = null;

	  // Should create new instance on each method
	  if (!state.parent) {
	    state.children = [];
	    this._wrap();
	  }
	}
	var node = Node;

	var stateProps = [
	  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
	  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
	  'implicit', 'contains'
	];

	Node.prototype.clone = function clone() {
	  var state = this._baseState;
	  var cstate = {};
	  stateProps.forEach(function(prop) {
	    cstate[prop] = state[prop];
	  });
	  var res = new this.constructor(cstate.parent);
	  res._baseState = cstate;
	  return res;
	};

	Node.prototype._wrap = function wrap() {
	  var state = this._baseState;
	  methods.forEach(function(method) {
	    this[method] = function _wrappedMethod() {
	      var clone = new this.constructor(this);
	      state.children.push(clone);
	      return clone[method].apply(clone, arguments);
	    };
	  }, this);
	};

	Node.prototype._init = function init(body) {
	  var state = this._baseState;

	  minimalisticAssert(state.parent === null);
	  body.call(this);

	  // Filter children
	  state.children = state.children.filter(function(child) {
	    return child._baseState.parent === this;
	  }, this);
	  minimalisticAssert.equal(state.children.length, 1, 'Root node can have only one child');
	};

	Node.prototype._useArgs = function useArgs(args) {
	  var state = this._baseState;

	  // Filter children and args
	  var children = args.filter(function(arg) {
	    return arg instanceof this.constructor;
	  }, this);
	  args = args.filter(function(arg) {
	    return !(arg instanceof this.constructor);
	  }, this);

	  if (children.length !== 0) {
	    minimalisticAssert(state.children === null);
	    state.children = children;

	    // Replace parent to maintain backward link
	    children.forEach(function(child) {
	      child._baseState.parent = this;
	    }, this);
	  }
	  if (args.length !== 0) {
	    minimalisticAssert(state.args === null);
	    state.args = args;
	    state.reverseArgs = args.map(function(arg) {
	      if (typeof arg !== 'object' || arg.constructor !== Object)
	        return arg;

	      var res = {};
	      Object.keys(arg).forEach(function(key) {
	        if (key == (key | 0))
	          key |= 0;
	        var value = arg[key];
	        res[value] = key;
	      });
	      return res;
	    });
	  }
	};

	//
	// Overrided methods
	//

	overrided.forEach(function(method) {
	  Node.prototype[method] = function _overrided() {
	    var state = this._baseState;
	    throw new Error(method + ' not implemented for encoding: ' + state.enc);
	  };
	});

	//
	// Public methods
	//

	tags.forEach(function(tag) {
	  Node.prototype[tag] = function _tagMethod() {
	    var state = this._baseState;
	    var args = Array.prototype.slice.call(arguments);

	    minimalisticAssert(state.tag === null);
	    state.tag = tag;

	    this._useArgs(args);

	    return this;
	  };
	});

	Node.prototype.use = function use(item) {
	  minimalisticAssert(item);
	  var state = this._baseState;

	  minimalisticAssert(state.use === null);
	  state.use = item;

	  return this;
	};

	Node.prototype.optional = function optional() {
	  var state = this._baseState;

	  state.optional = true;

	  return this;
	};

	Node.prototype.def = function def(val) {
	  var state = this._baseState;

	  minimalisticAssert(state['default'] === null);
	  state['default'] = val;
	  state.optional = true;

	  return this;
	};

	Node.prototype.explicit = function explicit(num) {
	  var state = this._baseState;

	  minimalisticAssert(state.explicit === null && state.implicit === null);
	  state.explicit = num;

	  return this;
	};

	Node.prototype.implicit = function implicit(num) {
	  var state = this._baseState;

	  minimalisticAssert(state.explicit === null && state.implicit === null);
	  state.implicit = num;

	  return this;
	};

	Node.prototype.obj = function obj() {
	  var state = this._baseState;
	  var args = Array.prototype.slice.call(arguments);

	  state.obj = true;

	  if (args.length !== 0)
	    this._useArgs(args);

	  return this;
	};

	Node.prototype.key = function key(newKey) {
	  var state = this._baseState;

	  minimalisticAssert(state.key === null);
	  state.key = newKey;

	  return this;
	};

	Node.prototype.any = function any() {
	  var state = this._baseState;

	  state.any = true;

	  return this;
	};

	Node.prototype.choice = function choice(obj) {
	  var state = this._baseState;

	  minimalisticAssert(state.choice === null);
	  state.choice = obj;
	  this._useArgs(Object.keys(obj).map(function(key) {
	    return obj[key];
	  }));

	  return this;
	};

	Node.prototype.contains = function contains(item) {
	  var state = this._baseState;

	  minimalisticAssert(state.use === null);
	  state.contains = item;

	  return this;
	};

	//
	// Decoding
	//

	Node.prototype._decode = function decode(input, options) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return input.wrapResult(state.children[0]._decode(input, options));

	  var result = state['default'];
	  var present = true;

	  var prevKey = null;
	  if (state.key !== null)
	    prevKey = input.enterKey(state.key);

	  // Check if tag is there
	  if (state.optional) {
	    var tag = null;
	    if (state.explicit !== null)
	      tag = state.explicit;
	    else if (state.implicit !== null)
	      tag = state.implicit;
	    else if (state.tag !== null)
	      tag = state.tag;

	    if (tag === null && !state.any) {
	      // Trial and Error
	      var save = input.save();
	      try {
	        if (state.choice === null)
	          this._decodeGeneric(state.tag, input, options);
	        else
	          this._decodeChoice(input, options);
	        present = true;
	      } catch (e) {
	        present = false;
	      }
	      input.restore(save);
	    } else {
	      present = this._peekTag(input, tag, state.any);

	      if (input.isError(present))
	        return present;
	    }
	  }

	  // Push object on stack
	  var prevObj;
	  if (state.obj && present)
	    prevObj = input.enterObject();

	  if (present) {
	    // Unwrap explicit values
	    if (state.explicit !== null) {
	      var explicit = this._decodeTag(input, state.explicit);
	      if (input.isError(explicit))
	        return explicit;
	      input = explicit;
	    }

	    var start = input.offset;

	    // Unwrap implicit and normal values
	    if (state.use === null && state.choice === null) {
	      if (state.any)
	        var save = input.save();
	      var body = this._decodeTag(
	        input,
	        state.implicit !== null ? state.implicit : state.tag,
	        state.any
	      );
	      if (input.isError(body))
	        return body;

	      if (state.any)
	        result = input.raw(save);
	      else
	        input = body;
	    }

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), start, input.length, 'tagged');

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), input.offset, input.length, 'content');

	    // Select proper method for tag
	    if (state.any)
	      result = result;
	    else if (state.choice === null)
	      result = this._decodeGeneric(state.tag, input, options);
	    else
	      result = this._decodeChoice(input, options);

	    if (input.isError(result))
	      return result;

	    // Decode children
	    if (!state.any && state.choice === null && state.children !== null) {
	      state.children.forEach(function decodeChildren(child) {
	        // NOTE: We are ignoring errors here, to let parser continue with other
	        // parts of encoded data
	        child._decode(input, options);
	      });
	    }

	    // Decode contained/encoded by schema, only in bit or octet strings
	    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
	      var data = new DecoderBuffer$1(result);
	      result = this._getUse(state.contains, input._reporterState.obj)
	          ._decode(data, options);
	    }
	  }

	  // Pop object
	  if (state.obj && present)
	    result = input.leaveObject(prevObj);

	  // Set key
	  if (state.key !== null && (result !== null || present === true))
	    input.leaveKey(prevKey, state.key, result);
	  else if (prevKey !== null)
	    input.exitKey(prevKey);

	  return result;
	};

	Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
	  var state = this._baseState;

	  if (tag === 'seq' || tag === 'set')
	    return null;
	  if (tag === 'seqof' || tag === 'setof')
	    return this._decodeList(input, tag, state.args[0], options);
	  else if (/str$/.test(tag))
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'objid' && state.args)
	    return this._decodeObjid(input, state.args[0], state.args[1], options);
	  else if (tag === 'objid')
	    return this._decodeObjid(input, null, null, options);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._decodeTime(input, tag, options);
	  else if (tag === 'null_')
	    return this._decodeNull(input, options);
	  else if (tag === 'bool')
	    return this._decodeBool(input, options);
	  else if (tag === 'objDesc')
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'int' || tag === 'enum')
	    return this._decodeInt(input, state.args && state.args[0], options);

	  if (state.use !== null) {
	    return this._getUse(state.use, input._reporterState.obj)
	        ._decode(input, options);
	  } else {
	    return input.error('unknown tag: ' + tag);
	  }
	};

	Node.prototype._getUse = function _getUse(entity, obj) {

	  var state = this._baseState;
	  // Create altered use decoder if implicit is set
	  state.useDecoder = this._use(entity, obj);
	  minimalisticAssert(state.useDecoder._baseState.parent === null);
	  state.useDecoder = state.useDecoder._baseState.children[0];
	  if (state.implicit !== state.useDecoder._baseState.implicit) {
	    state.useDecoder = state.useDecoder.clone();
	    state.useDecoder._baseState.implicit = state.implicit;
	  }
	  return state.useDecoder;
	};

	Node.prototype._decodeChoice = function decodeChoice(input, options) {
	  var state = this._baseState;
	  var result = null;
	  var match = false;

	  Object.keys(state.choice).some(function(key) {
	    var save = input.save();
	    var node = state.choice[key];
	    try {
	      var value = node._decode(input, options);
	      if (input.isError(value))
	        return false;

	      result = { type: key, value: value };
	      match = true;
	    } catch (e) {
	      input.restore(save);
	      return false;
	    }
	    return true;
	  }, this);

	  if (!match)
	    return input.error('Choice not matched');

	  return result;
	};

	//
	// Encoding
	//

	Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
	  return new EncoderBuffer$1(data, this.reporter);
	};

	Node.prototype._encode = function encode(data, reporter, parent) {
	  var state = this._baseState;
	  if (state['default'] !== null && state['default'] === data)
	    return;

	  var result = this._encodeValue(data, reporter, parent);
	  if (result === undefined)
	    return;

	  if (this._skipDefault(result, reporter, parent))
	    return;

	  return result;
	};

	Node.prototype._encodeValue = function encode(data, reporter, parent) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return state.children[0]._encode(data, reporter || new Reporter$2());

	  var result = null;

	  // Set reporter to share it with a child class
	  this.reporter = reporter;

	  // Check if data is there
	  if (state.optional && data === undefined) {
	    if (state['default'] !== null)
	      data = state['default'];
	    else
	      return;
	  }

	  // Encode children first
	  var content = null;
	  var primitive = false;
	  if (state.any) {
	    // Anything that was given is translated to buffer
	    result = this._createEncoderBuffer(data);
	  } else if (state.choice) {
	    result = this._encodeChoice(data, reporter);
	  } else if (state.contains) {
	    content = this._getUse(state.contains, parent)._encode(data, reporter);
	    primitive = true;
	  } else if (state.children) {
	    content = state.children.map(function(child) {
	      if (child._baseState.tag === 'null_')
	        return child._encode(null, reporter, data);

	      if (child._baseState.key === null)
	        return reporter.error('Child should have a key');
	      var prevKey = reporter.enterKey(child._baseState.key);

	      if (typeof data !== 'object')
	        return reporter.error('Child expected, but input is not object');

	      var res = child._encode(data[child._baseState.key], reporter, data);
	      reporter.leaveKey(prevKey);

	      return res;
	    }, this).filter(function(child) {
	      return child;
	    });
	    content = this._createEncoderBuffer(content);
	  } else {
	    if (state.tag === 'seqof' || state.tag === 'setof') {
	      // TODO(indutny): this should be thrown on DSL level
	      if (!(state.args && state.args.length === 1))
	        return reporter.error('Too many args for : ' + state.tag);

	      if (!Array.isArray(data))
	        return reporter.error('seqof/setof, but data is not Array');

	      var child = this.clone();
	      child._baseState.implicit = null;
	      content = this._createEncoderBuffer(data.map(function(item) {
	        var state = this._baseState;

	        return this._getUse(state.args[0], data)._encode(item, reporter);
	      }, child));
	    } else if (state.use !== null) {
	      result = this._getUse(state.use, parent)._encode(data, reporter);
	    } else {
	      content = this._encodePrimitive(state.tag, data);
	      primitive = true;
	    }
	  }

	  // Encode data itself
	  var result;
	  if (!state.any && state.choice === null) {
	    var tag = state.implicit !== null ? state.implicit : state.tag;
	    var cls = state.implicit === null ? 'universal' : 'context';

	    if (tag === null) {
	      if (state.use === null)
	        reporter.error('Tag could be omitted only for .use()');
	    } else {
	      if (state.use === null)
	        result = this._encodeComposite(tag, primitive, cls, content);
	    }
	  }

	  // Wrap in explicit
	  if (state.explicit !== null)
	    result = this._encodeComposite(state.explicit, false, 'context', result);

	  return result;
	};

	Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
	  var state = this._baseState;

	  var node = state.choice[data.type];
	  if (!node) {
	    minimalisticAssert(
	        false,
	        data.type + ' not found in ' +
	            JSON.stringify(Object.keys(state.choice)));
	  }
	  return node._encode(data.value, reporter);
	};

	Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
	  var state = this._baseState;

	  if (/str$/.test(tag))
	    return this._encodeStr(data, tag);
	  else if (tag === 'objid' && state.args)
	    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._encodeObjid(data, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._encodeTime(data, tag);
	  else if (tag === 'null_')
	    return this._encodeNull();
	  else if (tag === 'int' || tag === 'enum')
	    return this._encodeInt(data, state.args && state.reverseArgs[0]);
	  else if (tag === 'bool')
	    return this._encodeBool(data);
	  else if (tag === 'objDesc')
	    return this._encodeStr(data, tag);
	  else
	    throw new Error('Unsupported tag: ' + tag);
	};

	Node.prototype._isNumstr = function isNumstr(str) {
	  return /^[0-9 ]*$/.test(str);
	};

	Node.prototype._isPrintstr = function isPrintstr(str) {
	  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
	};

	var base_1 = createCommonjsModule(function (module, exports) {
	var base = exports;

	base.Reporter = reporter.Reporter;
	base.DecoderBuffer = buffer.DecoderBuffer;
	base.EncoderBuffer = buffer.EncoderBuffer;
	base.Node = node;
	});

	var der = createCommonjsModule(function (module, exports) {
	exports.tagClass = {
	  0: 'universal',
	  1: 'application',
	  2: 'context',
	  3: 'private'
	};
	exports.tagClassByName = constants_1._reverse(exports.tagClass);

	exports.tag = {
	  0x00: 'end',
	  0x01: 'bool',
	  0x02: 'int',
	  0x03: 'bitstr',
	  0x04: 'octstr',
	  0x05: 'null_',
	  0x06: 'objid',
	  0x07: 'objDesc',
	  0x08: 'external',
	  0x09: 'real',
	  0x0a: 'enum',
	  0x0b: 'embed',
	  0x0c: 'utf8str',
	  0x0d: 'relativeOid',
	  0x10: 'seq',
	  0x11: 'set',
	  0x12: 'numstr',
	  0x13: 'printstr',
	  0x14: 't61str',
	  0x15: 'videostr',
	  0x16: 'ia5str',
	  0x17: 'utctime',
	  0x18: 'gentime',
	  0x19: 'graphstr',
	  0x1a: 'iso646str',
	  0x1b: 'genstr',
	  0x1c: 'unistr',
	  0x1d: 'charstr',
	  0x1e: 'bmpstr'
	};
	exports.tagByName = constants_1._reverse(exports.tag);
	});
	var der_1 = der.tagClass;
	var der_2 = der.tagClassByName;
	var der_3 = der.tag;
	var der_4 = der.tagByName;

	var constants_1 = createCommonjsModule(function (module, exports) {
	var constants = exports;

	// Helper
	constants._reverse = function reverse(map) {
	  var res = {};

	  Object.keys(map).forEach(function(key) {
	    // Convert key to integer if it is stringified
	    if ((key | 0) == key)
	      key = key | 0;

	    var value = map[key];
	    res[value] = key;
	  });

	  return res;
	};

	constants.der = der;
	});

	var base$1 = asn1_1.base;
	var bignum = asn1_1.bignum;

	// Import DER constants
	var der$1 = asn1_1.constants.der;

	function DERDecoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	}var der_1$1 = DERDecoder;

	DERDecoder.prototype.decode = function decode(data, options) {
	  if (!(data instanceof base$1.DecoderBuffer))
	    data = new base$1.DecoderBuffer(data, options);

	  return this.tree._decode(data, options);
	};

	// Tree methods

	function DERNode(parent) {
	  base$1.Node.call(this, 'der', parent);
	}
	inherits_browser(DERNode, base$1.Node);

	DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
	  if (buffer.isEmpty())
	    return false;

	  var state = buffer.save();
	  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  buffer.restore(state);

	  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
	    (decodedTag.tagStr + 'of') === tag || any;
	};

	DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
	  var decodedTag = derDecodeTag(buffer,
	                                'Failed to decode tag of "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  var len = derDecodeLen(buffer,
	                         decodedTag.primitive,
	                         'Failed to get length of "' + tag + '"');

	  // Failure
	  if (buffer.isError(len))
	    return len;

	  if (!any &&
	      decodedTag.tag !== tag &&
	      decodedTag.tagStr !== tag &&
	      decodedTag.tagStr + 'of' !== tag) {
	    return buffer.error('Failed to match tag: "' + tag + '"');
	  }

	  if (decodedTag.primitive || len !== null)
	    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

	  // Indefinite length... find END tag
	  var state = buffer.save();
	  var res = this._skipUntilEnd(
	      buffer,
	      'Failed to skip indefinite length body: "' + this.tag + '"');
	  if (buffer.isError(res))
	    return res;

	  len = buffer.offset - state.offset;
	  buffer.restore(state);
	  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
	};

	DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
	  while (true) {
	    var tag = derDecodeTag(buffer, fail);
	    if (buffer.isError(tag))
	      return tag;
	    var len = derDecodeLen(buffer, tag.primitive, fail);
	    if (buffer.isError(len))
	      return len;

	    var res;
	    if (tag.primitive || len !== null)
	      res = buffer.skip(len);
	    else
	      res = this._skipUntilEnd(buffer, fail);

	    // Failure
	    if (buffer.isError(res))
	      return res;

	    if (tag.tagStr === 'end')
	      break;
	  }
	};

	DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
	                                                    options) {
	  var result = [];
	  while (!buffer.isEmpty()) {
	    var possibleEnd = this._peekTag(buffer, 'end');
	    if (buffer.isError(possibleEnd))
	      return possibleEnd;

	    var res = decoder.decode(buffer, 'der', options);
	    if (buffer.isError(res) && possibleEnd)
	      break;
	    result.push(res);
	  }
	  return result;
	};

	DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
	  if (tag === 'bitstr') {
	    var unused = buffer.readUInt8();
	    if (buffer.isError(unused))
	      return unused;
	    return { unused: unused, data: buffer.raw() };
	  } else if (tag === 'bmpstr') {
	    var raw = buffer.raw();
	    if (raw.length % 2 === 1)
	      return buffer.error('Decoding of string type: bmpstr length mismatch');

	    var str = '';
	    for (var i = 0; i < raw.length / 2; i++) {
	      str += String.fromCharCode(raw.readUInt16BE(i * 2));
	    }
	    return str;
	  } else if (tag === 'numstr') {
	    var numstr = buffer.raw().toString('ascii');
	    if (!this._isNumstr(numstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'numstr unsupported characters');
	    }
	    return numstr;
	  } else if (tag === 'octstr') {
	    return buffer.raw();
	  } else if (tag === 'objDesc') {
	    return buffer.raw();
	  } else if (tag === 'printstr') {
	    var printstr = buffer.raw().toString('ascii');
	    if (!this._isPrintstr(printstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'printstr unsupported characters');
	    }
	    return printstr;
	  } else if (/str$/.test(tag)) {
	    return buffer.raw().toString();
	  } else {
	    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
	  }
	};

	DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
	  var result;
	  var identifiers = [];
	  var ident = 0;
	  while (!buffer.isEmpty()) {
	    var subident = buffer.readUInt8();
	    ident <<= 7;
	    ident |= subident & 0x7f;
	    if ((subident & 0x80) === 0) {
	      identifiers.push(ident);
	      ident = 0;
	    }
	  }
	  if (subident & 0x80)
	    identifiers.push(ident);

	  var first = (identifiers[0] / 40) | 0;
	  var second = identifiers[0] % 40;

	  if (relative)
	    result = identifiers;
	  else
	    result = [first, second].concat(identifiers.slice(1));

	  if (values) {
	    var tmp = values[result.join(' ')];
	    if (tmp === undefined)
	      tmp = values[result.join('.')];
	    if (tmp !== undefined)
	      result = tmp;
	  }

	  return result;
	};

	DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
	  var str = buffer.raw().toString();
	  if (tag === 'gentime') {
	    var year = str.slice(0, 4) | 0;
	    var mon = str.slice(4, 6) | 0;
	    var day = str.slice(6, 8) | 0;
	    var hour = str.slice(8, 10) | 0;
	    var min = str.slice(10, 12) | 0;
	    var sec = str.slice(12, 14) | 0;
	  } else if (tag === 'utctime') {
	    var year = str.slice(0, 2) | 0;
	    var mon = str.slice(2, 4) | 0;
	    var day = str.slice(4, 6) | 0;
	    var hour = str.slice(6, 8) | 0;
	    var min = str.slice(8, 10) | 0;
	    var sec = str.slice(10, 12) | 0;
	    if (year < 70)
	      year = 2000 + year;
	    else
	      year = 1900 + year;
	  } else {
	    return buffer.error('Decoding ' + tag + ' time is not supported yet');
	  }

	  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
	};

	DERNode.prototype._decodeNull = function decodeNull(buffer) {
	  return null;
	};

	DERNode.prototype._decodeBool = function decodeBool(buffer) {
	  var res = buffer.readUInt8();
	  if (buffer.isError(res))
	    return res;
	  else
	    return res !== 0;
	};

	DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
	  // Bigint, return as it is (assume big endian)
	  var raw = buffer.raw();
	  var res = new bignum(raw);

	  if (values)
	    res = values[res.toString(10)] || res;

	  return res;
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getDecoder('der').tree;
	};

	// Utility methods

	function derDecodeTag(buf, fail) {
	  var tag = buf.readUInt8(fail);
	  if (buf.isError(tag))
	    return tag;

	  var cls = der$1.tagClass[tag >> 6];
	  var primitive = (tag & 0x20) === 0;

	  // Multi-octet tag - load
	  if ((tag & 0x1f) === 0x1f) {
	    var oct = tag;
	    tag = 0;
	    while ((oct & 0x80) === 0x80) {
	      oct = buf.readUInt8(fail);
	      if (buf.isError(oct))
	        return oct;

	      tag <<= 7;
	      tag |= oct & 0x7f;
	    }
	  } else {
	    tag &= 0x1f;
	  }
	  var tagStr = der$1.tag[tag];

	  return {
	    cls: cls,
	    primitive: primitive,
	    tag: tag,
	    tagStr: tagStr
	  };
	}

	function derDecodeLen(buf, primitive, fail) {
	  var len = buf.readUInt8(fail);
	  if (buf.isError(len))
	    return len;

	  // Indefinite form
	  if (!primitive && len === 0x80)
	    return null;

	  // Definite form
	  if ((len & 0x80) === 0) {
	    // Short form
	    return len;
	  }

	  // Long form
	  var num = len & 0x7f;
	  if (num > 4)
	    return buf.error('length octect is too long');

	  len = 0;
	  for (var i = 0; i < num; i++) {
	    len <<= 8;
	    var j = buf.readUInt8(fail);
	    if (buf.isError(j))
	      return j;
	    len |= j;
	  }

	  return len;
	}

	var Buffer$u = require$$0.Buffer;



	function PEMDecoder(entity) {
	  der_1$1.call(this, entity);
	  this.enc = 'pem';
	}inherits_browser(PEMDecoder, der_1$1);
	var pem = PEMDecoder;

	PEMDecoder.prototype.decode = function decode(data, options) {
	  var lines = data.toString().split(/[\r\n]+/g);

	  var label = options.label.toUpperCase();

	  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
	  var start = -1;
	  var end = -1;
	  for (var i = 0; i < lines.length; i++) {
	    var match = lines[i].match(re);
	    if (match === null)
	      continue;

	    if (match[2] !== label)
	      continue;

	    if (start === -1) {
	      if (match[1] !== 'BEGIN')
	        break;
	      start = i;
	    } else {
	      if (match[1] !== 'END')
	        break;
	      end = i;
	      break;
	    }
	  }
	  if (start === -1 || end === -1)
	    throw new Error('PEM section not found for: ' + label);

	  var base64 = lines.slice(start + 1, end).join('');
	  // Remove excessive symbols
	  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

	  var input = new Buffer$u(base64, 'base64');
	  return der_1$1.prototype.decode.call(this, input, options);
	};

	var decoders_1 = createCommonjsModule(function (module, exports) {
	var decoders = exports;

	decoders.der = der_1$1;
	decoders.pem = pem;
	});

	var Buffer$v = require$$0.Buffer;


	var base$2 = asn1_1.base;

	// Import DER constants
	var der$2 = asn1_1.constants.der;

	function DEREncoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode$1();
	  this.tree._init(entity.body);
	}var der_1$2 = DEREncoder;

	DEREncoder.prototype.encode = function encode(data, reporter) {
	  return this.tree._encode(data, reporter).join();
	};

	// Tree methods

	function DERNode$1(parent) {
	  base$2.Node.call(this, 'der', parent);
	}
	inherits_browser(DERNode$1, base$2.Node);

	DERNode$1.prototype._encodeComposite = function encodeComposite(tag,
	                                                              primitive,
	                                                              cls,
	                                                              content) {
	  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

	  // Short form
	  if (content.length < 0x80) {
	    var header = new Buffer$v(2);
	    header[0] = encodedTag;
	    header[1] = content.length;
	    return this._createEncoderBuffer([ header, content ]);
	  }

	  // Long form
	  // Count octets required to store length
	  var lenOctets = 1;
	  for (var i = content.length; i >= 0x100; i >>= 8)
	    lenOctets++;

	  var header = new Buffer$v(1 + 1 + lenOctets);
	  header[0] = encodedTag;
	  header[1] = 0x80 | lenOctets;

	  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
	    header[i] = j & 0xff;

	  return this._createEncoderBuffer([ header, content ]);
	};

	DERNode$1.prototype._encodeStr = function encodeStr(str, tag) {
	  if (tag === 'bitstr') {
	    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
	  } else if (tag === 'bmpstr') {
	    var buf = new Buffer$v(str.length * 2);
	    for (var i = 0; i < str.length; i++) {
	      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
	    }
	    return this._createEncoderBuffer(buf);
	  } else if (tag === 'numstr') {
	    if (!this._isNumstr(str)) {
	      return this.reporter.error('Encoding of string type: numstr supports ' +
	                                 'only digits and space');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'printstr') {
	    if (!this._isPrintstr(str)) {
	      return this.reporter.error('Encoding of string type: printstr supports ' +
	                                 'only latin upper and lower case letters, ' +
	                                 'digits, space, apostrophe, left and rigth ' +
	                                 'parenthesis, plus sign, comma, hyphen, ' +
	                                 'dot, slash, colon, equal sign, ' +
	                                 'question mark');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (/str$/.test(tag)) {
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'objDesc') {
	    return this._createEncoderBuffer(str);
	  } else {
	    return this.reporter.error('Encoding of string type: ' + tag +
	                               ' unsupported');
	  }
	};

	DERNode$1.prototype._encodeObjid = function encodeObjid(id, values, relative) {
	  if (typeof id === 'string') {
	    if (!values)
	      return this.reporter.error('string objid given, but no values map found');
	    if (!values.hasOwnProperty(id))
	      return this.reporter.error('objid not found in values map');
	    id = values[id].split(/[\s\.]+/g);
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  } else if (Array.isArray(id)) {
	    id = id.slice();
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  }

	  if (!Array.isArray(id)) {
	    return this.reporter.error('objid() should be either array or string, ' +
	                               'got: ' + JSON.stringify(id));
	  }

	  if (!relative) {
	    if (id[1] >= 40)
	      return this.reporter.error('Second objid identifier OOB');
	    id.splice(0, 2, id[0] * 40 + id[1]);
	  }

	  // Count number of octets
	  var size = 0;
	  for (var i = 0; i < id.length; i++) {
	    var ident = id[i];
	    for (size++; ident >= 0x80; ident >>= 7)
	      size++;
	  }

	  var objid = new Buffer$v(size);
	  var offset = objid.length - 1;
	  for (var i = id.length - 1; i >= 0; i--) {
	    var ident = id[i];
	    objid[offset--] = ident & 0x7f;
	    while ((ident >>= 7) > 0)
	      objid[offset--] = 0x80 | (ident & 0x7f);
	  }

	  return this._createEncoderBuffer(objid);
	};

	function two(num) {
	  if (num < 10)
	    return '0' + num;
	  else
	    return num;
	}

	DERNode$1.prototype._encodeTime = function encodeTime(time, tag) {
	  var str;
	  var date = new Date(time);

	  if (tag === 'gentime') {
	    str = [
	      two(date.getFullYear()),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else if (tag === 'utctime') {
	    str = [
	      two(date.getFullYear() % 100),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else {
	    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
	  }

	  return this._encodeStr(str, 'octstr');
	};

	DERNode$1.prototype._encodeNull = function encodeNull() {
	  return this._createEncoderBuffer('');
	};

	DERNode$1.prototype._encodeInt = function encodeInt(num, values) {
	  if (typeof num === 'string') {
	    if (!values)
	      return this.reporter.error('String int or enum given, but no values map');
	    if (!values.hasOwnProperty(num)) {
	      return this.reporter.error('Values map doesn\'t contain: ' +
	                                 JSON.stringify(num));
	    }
	    num = values[num];
	  }

	  // Bignum, assume big endian
	  if (typeof num !== 'number' && !Buffer$v.isBuffer(num)) {
	    var numArray = num.toArray();
	    if (!num.sign && numArray[0] & 0x80) {
	      numArray.unshift(0);
	    }
	    num = new Buffer$v(numArray);
	  }

	  if (Buffer$v.isBuffer(num)) {
	    var size = num.length;
	    if (num.length === 0)
	      size++;

	    var out = new Buffer$v(size);
	    num.copy(out);
	    if (num.length === 0)
	      out[0] = 0;
	    return this._createEncoderBuffer(out);
	  }

	  if (num < 0x80)
	    return this._createEncoderBuffer(num);

	  if (num < 0x100)
	    return this._createEncoderBuffer([0, num]);

	  var size = 1;
	  for (var i = num; i >= 0x100; i >>= 8)
	    size++;

	  var out = new Array(size);
	  for (var i = out.length - 1; i >= 0; i--) {
	    out[i] = num & 0xff;
	    num >>= 8;
	  }
	  if(out[0] & 0x80) {
	    out.unshift(0);
	  }

	  return this._createEncoderBuffer(new Buffer$v(out));
	};

	DERNode$1.prototype._encodeBool = function encodeBool(value) {
	  return this._createEncoderBuffer(value ? 0xff : 0);
	};

	DERNode$1.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getEncoder('der').tree;
	};

	DERNode$1.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
	  var state = this._baseState;
	  var i;
	  if (state['default'] === null)
	    return false;

	  var data = dataBuffer.join();
	  if (state.defaultBuffer === undefined)
	    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

	  if (data.length !== state.defaultBuffer.length)
	    return false;

	  for (i=0; i < data.length; i++)
	    if (data[i] !== state.defaultBuffer[i])
	      return false;

	  return true;
	};

	// Utility methods

	function encodeTag(tag, primitive, cls, reporter) {
	  var res;

	  if (tag === 'seqof')
	    tag = 'seq';
	  else if (tag === 'setof')
	    tag = 'set';

	  if (der$2.tagByName.hasOwnProperty(tag))
	    res = der$2.tagByName[tag];
	  else if (typeof tag === 'number' && (tag | 0) === tag)
	    res = tag;
	  else
	    return reporter.error('Unknown tag: ' + tag);

	  if (res >= 0x1f)
	    return reporter.error('Multi-octet tag encoding unsupported');

	  if (!primitive)
	    res |= 0x20;

	  res |= (der$2.tagClassByName[cls || 'universal'] << 6);

	  return res;
	}

	function PEMEncoder(entity) {
	  der_1$2.call(this, entity);
	  this.enc = 'pem';
	}inherits_browser(PEMEncoder, der_1$2);
	var pem$1 = PEMEncoder;

	PEMEncoder.prototype.encode = function encode(data, options) {
	  var buf = der_1$2.prototype.encode.call(this, data);

	  var p = buf.toString('base64');
	  var out = [ '-----BEGIN ' + options.label + '-----' ];
	  for (var i = 0; i < p.length; i += 64)
	    out.push(p.slice(i, i + 64));
	  out.push('-----END ' + options.label + '-----');
	  return out.join('\n');
	};

	var encoders_1 = createCommonjsModule(function (module, exports) {
	var encoders = exports;

	encoders.der = der_1$2;
	encoders.pem = pem$1;
	});

	var asn1_1 = createCommonjsModule(function (module, exports) {
	var asn1 = exports;

	asn1.bignum = bn;

	asn1.define = api_1.define;
	asn1.base = base_1;
	asn1.constants = constants_1;
	asn1.decoders = decoders_1;
	asn1.encoders = encoders_1;
	});

	var Time = asn1_1.define('Time', function () {
	  this.choice({
	    utcTime: this.utctime(),
	    generalTime: this.gentime()
	  });
	});

	var AttributeTypeValue = asn1_1.define('AttributeTypeValue', function () {
	  this.seq().obj(
	    this.key('type').objid(),
	    this.key('value').any()
	  );
	});

	var AlgorithmIdentifier = asn1_1.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('parameters').optional()
	  );
	});

	var SubjectPublicKeyInfo = asn1_1.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPublicKey').bitstr()
	  );
	});

	var RelativeDistinguishedName = asn1_1.define('RelativeDistinguishedName', function () {
	  this.setof(AttributeTypeValue);
	});

	var RDNSequence = asn1_1.define('RDNSequence', function () {
	  this.seqof(RelativeDistinguishedName);
	});

	var Name = asn1_1.define('Name', function () {
	  this.choice({
	    rdnSequence: this.use(RDNSequence)
	  });
	});

	var Validity = asn1_1.define('Validity', function () {
	  this.seq().obj(
	    this.key('notBefore').use(Time),
	    this.key('notAfter').use(Time)
	  );
	});

	var Extension = asn1_1.define('Extension', function () {
	  this.seq().obj(
	    this.key('extnID').objid(),
	    this.key('critical').bool().def(false),
	    this.key('extnValue').octstr()
	  );
	});

	var TBSCertificate = asn1_1.define('TBSCertificate', function () {
	  this.seq().obj(
	    this.key('version').explicit(0).int(),
	    this.key('serialNumber').int(),
	    this.key('signature').use(AlgorithmIdentifier),
	    this.key('issuer').use(Name),
	    this.key('validity').use(Validity),
	    this.key('subject').use(Name),
	    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
	    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
	    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
	    this.key('extensions').explicit(3).seqof(Extension).optional()
	  );
	});

	var X509Certificate = asn1_1.define('X509Certificate', function () {
	  this.seq().obj(
	    this.key('tbsCertificate').use(TBSCertificate),
	    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
	    this.key('signatureValue').bitstr()
	  );
	});

	var certificate = X509Certificate;

	var certificate$1 = certificate;

	var RSAPrivateKey = asn1_1.define('RSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('modulus').int(),
	    this.key('publicExponent').int(),
	    this.key('privateExponent').int(),
	    this.key('prime1').int(),
	    this.key('prime2').int(),
	    this.key('exponent1').int(),
	    this.key('exponent2').int(),
	    this.key('coefficient').int()
	  );
	});
	var RSAPrivateKey_1 = RSAPrivateKey;

	var RSAPublicKey = asn1_1.define('RSAPublicKey', function () {
	  this.seq().obj(
	    this.key('modulus').int(),
	    this.key('publicExponent').int()
	  );
	});
	var RSAPublicKey_1 = RSAPublicKey;

	var PublicKey = asn1_1.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier$1),
	    this.key('subjectPublicKey').bitstr()
	  );
	});
	var PublicKey_1 = PublicKey;

	var AlgorithmIdentifier$1 = asn1_1.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('none').null_().optional(),
	    this.key('curve').objid().optional(),
	    this.key('params').seq().obj(
	      this.key('p').int(),
	      this.key('q').int(),
	      this.key('g').int()
	    ).optional()
	  );
	});

	var PrivateKeyInfo = asn1_1.define('PrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('algorithm').use(AlgorithmIdentifier$1),
	    this.key('subjectPrivateKey').octstr()
	  );
	});
	var PrivateKey = PrivateKeyInfo;
	var EncryptedPrivateKeyInfo = asn1_1.define('EncryptedPrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').seq().obj(
	      this.key('id').objid(),
	      this.key('decrypt').seq().obj(
	        this.key('kde').seq().obj(
	          this.key('id').objid(),
	          this.key('kdeparams').seq().obj(
	            this.key('salt').octstr(),
	            this.key('iters').int()
	          )
	        ),
	        this.key('cipher').seq().obj(
	          this.key('algo').objid(),
	          this.key('iv').octstr()
	        )
	      )
	    ),
	    this.key('subjectPrivateKey').octstr()
	  );
	});

	var EncryptedPrivateKey = EncryptedPrivateKeyInfo;

	var DSAPrivateKey = asn1_1.define('DSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('p').int(),
	    this.key('q').int(),
	    this.key('g').int(),
	    this.key('pub_key').int(),
	    this.key('priv_key').int()
	  );
	});
	var DSAPrivateKey_1 = DSAPrivateKey;

	var DSAparam = asn1_1.define('DSAparam', function () {
	  this.int();
	});

	var ECPrivateKey = asn1_1.define('ECPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('privateKey').octstr(),
	    this.key('parameters').optional().explicit(0).use(ECParameters),
	    this.key('publicKey').optional().explicit(1).bitstr()
	  );
	});
	var ECPrivateKey_1 = ECPrivateKey;

	var ECParameters = asn1_1.define('ECParameters', function () {
	  this.choice({
	    namedCurve: this.objid()
	  });
	});

	var signature$2 = asn1_1.define('signature', function () {
	  this.seq().obj(
	    this.key('r').int(),
	    this.key('s').int()
	  );
	});

	var asn1_1$1 = {
		certificate: certificate$1,
		RSAPrivateKey: RSAPrivateKey_1,
		RSAPublicKey: RSAPublicKey_1,
		PublicKey: PublicKey_1,
		PrivateKey: PrivateKey,
		EncryptedPrivateKey: EncryptedPrivateKey,
		DSAPrivateKey: DSAPrivateKey_1,
		DSAparam: DSAparam,
		ECPrivateKey: ECPrivateKey_1,
		signature: signature$2
	};

	var aesid = {
		"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
		"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
		"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
		"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
		"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
		"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
		"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
		"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
		"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
		"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
		"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
		"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
	};

	var aesid$1 = /*#__PURE__*/Object.freeze({
		default: aesid
	});

	// adapted from https://github.com/apatil/pemstrip
	var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m;
	var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m;
	var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m;


	var fixProc = function (okey, password) {
	  var key = okey.toString();
	  var match = key.match(findProc);
	  var decrypted;
	  if (!match) {
	    var match2 = key.match(fullRegex);
	    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64');
	  } else {
	    var suite = 'aes' + match[1];
	    var iv = new Buffer(match[2], 'hex');
	    var cipherText = new Buffer(match[3].replace(/[\r\n]/g, ''), 'base64');
	    var cipherKey = evp_bytestokey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
	    var out = [];
	    var cipher = browser$5.createDecipheriv(suite, cipherKey, iv);
	    out.push(cipher.update(cipherText));
	    out.push(cipher.final());
	    decrypted = Buffer.concat(out);
	  }
	  var tag = key.match(startRegex)[1];
	  return {
	    tag: tag,
	    data: decrypted
	  }
	};

	var aesid$2 = ( aesid$1 && aesid ) || aesid$1;

	var parseAsn1 = parseKeys;

	function parseKeys (buffer) {
	  var password;
	  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
	    password = buffer.passphrase;
	    buffer = buffer.key;
	  }
	  if (typeof buffer === 'string') {
	    buffer = new Buffer(buffer);
	  }

	  var stripped = fixProc(buffer, password);

	  var type = stripped.tag;
	  var data = stripped.data;
	  var subtype, ndata;
	  switch (type) {
	    case 'CERTIFICATE':
	      ndata = asn1_1$1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
	      // falls through
	    case 'PUBLIC KEY':
	      if (!ndata) {
	        ndata = asn1_1$1.PublicKey.decode(data, 'der');
	      }
	      subtype = ndata.algorithm.algorithm.join('.');
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1_1$1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
	        case '1.2.840.10045.2.1':
	          ndata.subjectPrivateKey = ndata.subjectPublicKey;
	          return {
	            type: 'ec',
	            data: ndata
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.pub_key = asn1_1$1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
	          return {
	            type: 'dsa',
	            data: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'ENCRYPTED PRIVATE KEY':
	      data = asn1_1$1.EncryptedPrivateKey.decode(data, 'der');
	      data = decrypt$2(data, password);
	      // falls through
	    case 'PRIVATE KEY':
	      ndata = asn1_1$1.PrivateKey.decode(data, 'der');
	      subtype = ndata.algorithm.algorithm.join('.');
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1_1$1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
	        case '1.2.840.10045.2.1':
	          return {
	            curve: ndata.algorithm.curve,
	            privateKey: asn1_1$1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.priv_key = asn1_1$1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
	          return {
	            type: 'dsa',
	            params: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'RSA PUBLIC KEY':
	      return asn1_1$1.RSAPublicKey.decode(data, 'der')
	    case 'RSA PRIVATE KEY':
	      return asn1_1$1.RSAPrivateKey.decode(data, 'der')
	    case 'DSA PRIVATE KEY':
	      return {
	        type: 'dsa',
	        params: asn1_1$1.DSAPrivateKey.decode(data, 'der')
	      }
	    case 'EC PRIVATE KEY':
	      data = asn1_1$1.ECPrivateKey.decode(data, 'der');
	      return {
	        curve: data.parameters.value,
	        privateKey: data.privateKey
	      }
	    default: throw new Error('unknown key type ' + type)
	  }
	}
	parseKeys.signature = asn1_1$1.signature;
	function decrypt$2 (data, password) {
	  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
	  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
	  var algo = aesid$2[data.algorithm.decrypt.cipher.algo.join('.')];
	  var iv = data.algorithm.decrypt.cipher.iv;
	  var cipherText = data.subjectPrivateKey;
	  var keylen = parseInt(algo.split('-')[1], 10) / 8;
	  var key = browser$4.pbkdf2Sync(password, salt, iters, keylen);
	  var cipher = browser$5.createDecipheriv(algo, key, iv);
	  var out = [];
	  out.push(cipher.update(cipherText));
	  out.push(cipher.final());
	  return Buffer.concat(out)
	}

	var curves = {
		"1.3.132.0.10": "secp256k1",
		"1.3.132.0.33": "p224",
		"1.2.840.10045.3.1.1": "p192",
		"1.2.840.10045.3.1.7": "p256",
		"1.3.132.0.34": "p384",
		"1.3.132.0.35": "p521"
	};

	var curves$1 = /*#__PURE__*/Object.freeze({
		default: curves
	});

	var curves$2 = ( curves$1 && curves ) || curves$1;

	// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js


	var EC$1 = elliptic_1.ec;




	function sign (hash, key, hashType, signType, tag) {
	  var priv = parseAsn1(key);
	  if (priv.curve) {
	    // rsa keys can be interpreted as ecdsa ones in openssl
	    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
	    return ecSign(hash, priv)
	  } else if (priv.type === 'dsa') {
	    if (signType !== 'dsa') throw new Error('wrong private key type')
	    return dsaSign(hash, priv, hashType)
	  } else {
	    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
	  }
	  hash = Buffer.concat([tag, hash]);
	  var len = priv.modulus.byteLength();
	  var pad = [ 0, 1 ];
	  while (hash.length + pad.length + 1 < len) pad.push(0xff);
	  pad.push(0x00);
	  var i = -1;
	  while (++i < hash.length) pad.push(hash[i]);

	  var out = browserifyRsa(pad, priv);
	  return out
	}

	function ecSign (hash, priv) {
	  var curveId = curves$2[priv.curve.join('.')];
	  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

	  var curve = new EC$1(curveId);
	  var key = curve.keyFromPrivate(priv.privateKey);
	  var out = key.sign(hash);

	  return new Buffer(out.toDER())
	}

	function dsaSign (hash, priv, algo) {
	  var x = priv.params.priv_key;
	  var p = priv.params.p;
	  var q = priv.params.q;
	  var g = priv.params.g;
	  var r = new bn(0);
	  var k;
	  var H = bits2int(hash, q).mod(q);
	  var s = false;
	  var kv = getKey(x, q, hash, algo);
	  while (s === false) {
	    k = makeKey(q, kv, algo);
	    r = makeR(g, k, p, q);
	    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
	    if (s.cmpn(0) === 0) {
	      s = false;
	      r = new bn(0);
	    }
	  }
	  return toDER(r, s)
	}

	function toDER (r, s) {
	  r = r.toArray();
	  s = s.toArray();

	  // Pad values
	  if (r[0] & 0x80) r = [ 0 ].concat(r);
	  if (s[0] & 0x80) s = [ 0 ].concat(s);

	  var total = r.length + s.length + 4;
	  var res = [ 0x30, total, 0x02, r.length ];
	  res = res.concat(r, [ 0x02, s.length ], s);
	  return new Buffer(res)
	}

	function getKey (x, q, hash, algo) {
	  x = new Buffer(x.toArray());
	  if (x.length < q.byteLength()) {
	    var zeros = new Buffer(q.byteLength() - x.length);
	    zeros.fill(0);
	    x = Buffer.concat([ zeros, x ]);
	  }
	  var hlen = hash.length;
	  var hbits = bits2octets(hash, q);
	  var v = new Buffer(hlen);
	  v.fill(1);
	  var k = new Buffer(hlen);
	  k.fill(0);
	  k = browser$3(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest();
	  v = browser$3(algo, k).update(v).digest();
	  k = browser$3(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest();
	  v = browser$3(algo, k).update(v).digest();
	  return { k: k, v: v }
	}

	function bits2int (obits, q) {
	  var bits = new bn(obits);
	  var shift = (obits.length << 3) - q.bitLength();
	  if (shift > 0) bits.ishrn(shift);
	  return bits
	}

	function bits2octets (bits, q) {
	  bits = bits2int(bits, q);
	  bits = bits.mod(q);
	  var out = new Buffer(bits.toArray());
	  if (out.length < q.byteLength()) {
	    var zeros = new Buffer(q.byteLength() - out.length);
	    zeros.fill(0);
	    out = Buffer.concat([ zeros, out ]);
	  }
	  return out
	}

	function makeKey (q, kv, algo) {
	  var t;
	  var k;

	  do {
	    t = new Buffer(0);

	    while (t.length * 8 < q.bitLength()) {
	      kv.v = browser$3(algo, kv.k).update(kv.v).digest();
	      t = Buffer.concat([ t, kv.v ]);
	    }

	    k = bits2int(t, q);
	    kv.k = browser$3(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest();
	    kv.v = browser$3(algo, kv.k).update(kv.v).digest();
	  } while (k.cmp(q) !== -1)

	  return k
	}

	function makeR (g, k, p, q) {
	  return g.toRed(bn.mont(p)).redPow(k).fromRed().mod(q)
	}

	var sign_1 = sign;
	var getKey_1 = getKey;
	var makeKey_1 = makeKey;
	sign_1.getKey = getKey_1;
	sign_1.makeKey = makeKey_1;

	// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js

	var EC$2 = elliptic_1.ec;



	function verify (sig, hash, key, signType, tag) {
	  var pub = parseAsn1(key);
	  if (pub.type === 'ec') {
	    // rsa keys can be interpreted as ecdsa ones in openssl
	    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
	    return ecVerify(sig, hash, pub)
	  } else if (pub.type === 'dsa') {
	    if (signType !== 'dsa') throw new Error('wrong public key type')
	    return dsaVerify(sig, hash, pub)
	  } else {
	    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
	  }
	  hash = Buffer.concat([tag, hash]);
	  var len = pub.modulus.byteLength();
	  var pad = [ 1 ];
	  var padNum = 0;
	  while (hash.length + pad.length + 2 < len) {
	    pad.push(0xff);
	    padNum++;
	  }
	  pad.push(0x00);
	  var i = -1;
	  while (++i < hash.length) {
	    pad.push(hash[i]);
	  }
	  pad = new Buffer(pad);
	  var red = bn.mont(pub.modulus);
	  sig = new bn(sig).toRed(red);

	  sig = sig.redPow(new bn(pub.publicExponent));
	  sig = new Buffer(sig.fromRed().toArray());
	  var out = padNum < 8 ? 1 : 0;
	  len = Math.min(sig.length, pad.length);
	  if (sig.length !== pad.length) out = 1;

	  i = -1;
	  while (++i < len) out |= sig[i] ^ pad[i];
	  return out === 0
	}

	function ecVerify (sig, hash, pub) {
	  var curveId = curves$2[pub.data.algorithm.curve.join('.')];
	  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

	  var curve = new EC$2(curveId);
	  var pubkey = pub.data.subjectPrivateKey.data;

	  return curve.verify(hash, sig, pubkey)
	}

	function dsaVerify (sig, hash, pub) {
	  var p = pub.data.p;
	  var q = pub.data.q;
	  var g = pub.data.g;
	  var y = pub.data.pub_key;
	  var unpacked = parseAsn1.signature.decode(sig, 'der');
	  var s = unpacked.s;
	  var r = unpacked.r;
	  checkValue(s, q);
	  checkValue(r, q);
	  var montp = bn.mont(p);
	  var w = s.invm(q);
	  var v = g.toRed(montp)
	    .redPow(new bn(hash).mul(w).mod(q))
	    .fromRed()
	    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
	    .mod(p)
	    .mod(q);
	  return v.cmp(r) === 0
	}

	function checkValue (b, q) {
	  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
	  if (b.cmp(q) >= q) throw new Error('invalid sig')
	}

	var verify_1 = verify;

	Object.keys(algorithms$2).forEach(function (key) {
	  algorithms$2[key].id = new Buffer(algorithms$2[key].id, 'hex');
	  algorithms$2[key.toLowerCase()] = algorithms$2[key];
	});

	function Sign (algorithm) {
	  require$$1.Writable.call(this);

	  var data = algorithms$2[algorithm];
	  if (!data) throw new Error('Unknown message digest')

	  this._hashType = data.hash;
	  this._hash = browser$2(data.hash);
	  this._tag = data.id;
	  this._signType = data.sign;
	}
	inherits_browser(Sign, require$$1.Writable);

	Sign.prototype._write = function _write (data, _, done) {
	  this._hash.update(data);
	  done();
	};

	Sign.prototype.update = function update (data, enc) {
	  if (typeof data === 'string') data = new Buffer(data, enc);

	  this._hash.update(data);
	  return this
	};

	Sign.prototype.sign = function signMethod (key, enc) {
	  this.end();
	  var hash = this._hash.digest();
	  var sig = sign_1(hash, key, this._hashType, this._signType, this._tag);

	  return enc ? sig.toString(enc) : sig
	};

	function Verify (algorithm) {
	  require$$1.Writable.call(this);

	  var data = algorithms$2[algorithm];
	  if (!data) throw new Error('Unknown message digest')

	  this._hash = browser$2(data.hash);
	  this._tag = data.id;
	  this._signType = data.sign;
	}
	inherits_browser(Verify, require$$1.Writable);

	Verify.prototype._write = function _write (data, _, done) {
	  this._hash.update(data);
	  done();
	};

	Verify.prototype.update = function update (data, enc) {
	  if (typeof data === 'string') data = new Buffer(data, enc);

	  this._hash.update(data);
	  return this
	};

	Verify.prototype.verify = function verifyMethod (key, sig, enc) {
	  if (typeof sig === 'string') sig = new Buffer(sig, enc);

	  this.end();
	  var hash = this._hash.digest();
	  return verify_1(sig, hash, key, this._signType, this._tag)
	};

	function createSign (algorithm) {
	  return new Sign(algorithm)
	}

	function createVerify (algorithm) {
	  return new Verify(algorithm)
	}

	var browser$8 = {
	  Sign: createSign,
	  Verify: createVerify,
	  createSign: createSign,
	  createVerify: createVerify
	};

	var browser$9 = function createECDH (curve) {
	  return new ECDH(curve)
	};

	var aliases = {
	  secp256k1: {
	    name: 'secp256k1',
	    byteLength: 32
	  },
	  secp224r1: {
	    name: 'p224',
	    byteLength: 28
	  },
	  prime256v1: {
	    name: 'p256',
	    byteLength: 32
	  },
	  prime192v1: {
	    name: 'p192',
	    byteLength: 24
	  },
	  ed25519: {
	    name: 'ed25519',
	    byteLength: 32
	  },
	  secp384r1: {
	    name: 'p384',
	    byteLength: 48
	  },
	  secp521r1: {
	    name: 'p521',
	    byteLength: 66
	  }
	};

	aliases.p224 = aliases.secp224r1;
	aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
	aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
	aliases.p384 = aliases.secp384r1;
	aliases.p521 = aliases.secp521r1;

	function ECDH (curve) {
	  this.curveType = aliases[curve];
	  if (!this.curveType) {
	    this.curveType = {
	      name: curve
	    };
	  }
	  this.curve = new elliptic_1.ec(this.curveType.name); // eslint-disable-line new-cap
	  this.keys = void 0;
	}

	ECDH.prototype.generateKeys = function (enc, format) {
	  this.keys = this.curve.genKeyPair();
	  return this.getPublicKey(enc, format)
	};

	ECDH.prototype.computeSecret = function (other, inenc, enc) {
	  inenc = inenc || 'utf8';
	  if (!Buffer.isBuffer(other)) {
	    other = new Buffer(other, inenc);
	  }
	  var otherPub = this.curve.keyFromPublic(other).getPublic();
	  var out = otherPub.mul(this.keys.getPrivate()).getX();
	  return formatReturnValue$1(out, enc, this.curveType.byteLength)
	};

	ECDH.prototype.getPublicKey = function (enc, format) {
	  var key = this.keys.getPublic(format === 'compressed', true);
	  if (format === 'hybrid') {
	    if (key[key.length - 1] % 2) {
	      key[0] = 7;
	    } else {
	      key[0] = 6;
	    }
	  }
	  return formatReturnValue$1(key, enc)
	};

	ECDH.prototype.getPrivateKey = function (enc) {
	  return formatReturnValue$1(this.keys.getPrivate(), enc)
	};

	ECDH.prototype.setPublicKey = function (pub, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(pub)) {
	    pub = new Buffer(pub, enc);
	  }
	  this.keys._importPublic(pub);
	  return this
	};

	ECDH.prototype.setPrivateKey = function (priv, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(priv)) {
	    priv = new Buffer(priv, enc);
	  }

	  var _priv = new bn(priv);
	  _priv = _priv.toString(16);
	  this.keys = this.curve.genKeyPair();
	  this.keys._importPrivate(_priv);
	  return this
	};

	function formatReturnValue$1 (bn$$1, enc, len) {
	  if (!Array.isArray(bn$$1)) {
	    bn$$1 = bn$$1.toArray();
	  }
	  var buf = new Buffer(bn$$1);
	  if (len && buf.length < len) {
	    var zeros = new Buffer(len - buf.length);
	    zeros.fill(0);
	    buf = Buffer.concat([zeros, buf]);
	  }
	  if (!enc) {
	    return buf
	  } else {
	    return buf.toString(enc)
	  }
	}

	var mgf = function (seed, len) {
	  var t = new Buffer('');
	  var  i = 0, c;
	  while (t.length < len) {
	    c = i2ops(i++);
	    t = Buffer.concat([t, browser$2('sha1').update(seed).update(c).digest()]);
	  }
	  return t.slice(0, len);
	};

	function i2ops(c) {
	  var out = new Buffer(4);
	  out.writeUInt32BE(c,0);
	  return out;
	}

	var xor = function xor(a, b) {
	  var len = a.length;
	  var i = -1;
	  while (++i < len) {
	    a[i] ^= b[i];
	  }
	  return a
	};

	function withPublic(paddedMsg, key) {
	  return new Buffer(paddedMsg
	    .toRed(bn.mont(key.modulus))
	    .redPow(new bn(key.publicExponent))
	    .fromRed()
	    .toArray());
	}

	var withPublic_1 = withPublic;

	var publicEncrypt = function publicEncrypt(public_key, msg, reverse) {
	  var padding;
	  if (public_key.padding) {
	    padding = public_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  var key = parseAsn1(public_key);
	  var paddedMsg;
	  if (padding === 4) {
	    paddedMsg = oaep(key, msg);
	  } else if (padding === 1) {
	    paddedMsg = pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    paddedMsg = new bn(msg);
	    if (paddedMsg.cmp(key.modulus) >= 0) {
	      throw new Error('data too long for modulus');
	    }
	  } else {
	    throw new Error('unknown padding');
	  }
	  if (reverse) {
	    return browserifyRsa(paddedMsg, key);
	  } else {
	    return withPublic_1(paddedMsg, key);
	  }
	};

	function oaep(key, msg){
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = browser$2('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (mLen > k - hLen2 - 2) {
	    throw new Error('message too long');
	  }
	  var ps = new Buffer(k - mLen - hLen2 - 2);
	  ps.fill(0);
	  var dblen = k - hLen - 1;
	  var seed = browser(hLen);
	  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
	  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
	  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
	}
	function pkcs1(key, msg, reverse){
	  var mLen = msg.length;
	  var k = key.modulus.byteLength();
	  if (mLen > k - 11) {
	    throw new Error('message too long');
	  }
	  var ps;
	  if (reverse) {
	    ps = new Buffer(k - mLen - 3);
	    ps.fill(0xff);
	  } else {
	    ps = nonZero(k - mLen - 3);
	  }
	  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
	}
	function nonZero(len, crypto) {
	  var out = new Buffer(len);
	  var i = 0;
	  var cache = browser(len*2);
	  var cur = 0;
	  var num;
	  while (i < len) {
	    if (cur === cache.length) {
	      cache = browser(len*2);
	      cur = 0;
	    }
	    num = cache[cur++];
	    if (num) {
	      out[i++] = num;
	    }
	  }
	  return out;
	}

	var privateDecrypt = function privateDecrypt(private_key, enc, reverse) {
	  var padding;
	  if (private_key.padding) {
	    padding = private_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  
	  var key = parseAsn1(private_key);
	  var k = key.modulus.byteLength();
	  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
	    throw new Error('decryption error');
	  }
	  var msg;
	  if (reverse) {
	    msg = withPublic_1(new bn(enc), key);
	  } else {
	    msg = browserifyRsa(enc, key);
	  }
	  var zBuffer = new Buffer(k - msg.length);
	  zBuffer.fill(0);
	  msg = Buffer.concat([zBuffer, msg], k);
	  if (padding === 4) {
	    return oaep$1(key, msg);
	  } else if (padding === 1) {
	    return pkcs1$1(key, msg, reverse);
	  } else if (padding === 3) {
	    return msg;
	  } else {
	    throw new Error('unknown padding');
	  }
	};

	function oaep$1(key, msg){
	  var n = key.modulus;
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = browser$2('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  if (msg[0] !== 0) {
	    throw new Error('decryption error');
	  }
	  var maskedSeed = msg.slice(1, hLen + 1);
	  var maskedDb =  msg.slice(hLen + 1);
	  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
	  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
	  if (compare(iHash, db.slice(0, hLen))) {
	    throw new Error('decryption error');
	  }
	  var i = hLen;
	  while (db[i] === 0) {
	    i++;
	  }
	  if (db[i++] !== 1) {
	    throw new Error('decryption error');
	  }
	  return db.slice(i);
	}

	function pkcs1$1(key, msg, reverse){
	  var p1 = msg.slice(0, 2);
	  var i = 2;
	  var status = 0;
	  while (msg[i++] !== 0) {
	    if (i >= msg.length) {
	      status++;
	      break;
	    }
	  }
	  var ps = msg.slice(2, i - 1);
	  var p2 = msg.slice(i - 1, i);

	  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
	    status++;
	  }
	  if (ps.length < 8) {
	    status++;
	  }
	  if (status) {
	    throw new Error('decryption error');
	  }
	  return  msg.slice(i);
	}
	function compare(a, b){
	  a = new Buffer(a);
	  b = new Buffer(b);
	  var dif = 0;
	  var len = a.length;
	  if (a.length !== b.length) {
	    dif++;
	    len = Math.min(a.length, b.length);
	  }
	  var i = -1;
	  while (++i < len) {
	    dif += (a[i] ^ b[i]);
	  }
	  return dif;
	}

	var browser$a = createCommonjsModule(function (module, exports) {
	exports.publicEncrypt = publicEncrypt;
	exports.privateDecrypt = privateDecrypt;

	exports.privateEncrypt = function privateEncrypt(key, buf) {
	  return exports.publicEncrypt(key, buf, true);
	};

	exports.publicDecrypt = function publicDecrypt(key, buf) {
	  return exports.privateDecrypt(key, buf, true);
	};
	});
	var browser_1$4 = browser$a.publicEncrypt;
	var browser_2$4 = browser$a.privateDecrypt;
	var browser_3$4 = browser$a.privateEncrypt;
	var browser_4$4 = browser$a.publicDecrypt;

	var browser$b = createCommonjsModule(function (module, exports) {

	function oldBrowser () {
	  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
	}


	var Buffer = safeBuffer.Buffer;
	var kBufferMaxLength = safeBuffer.kMaxLength;
	var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	var kMaxUint32 = Math.pow(2, 32) - 1;
	function assertOffset (offset, length) {
	  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
	    throw new TypeError('offset must be a number')
	  }

	  if (offset > kMaxUint32 || offset < 0) {
	    throw new TypeError('offset must be a uint32')
	  }

	  if (offset > kBufferMaxLength || offset > length) {
	    throw new RangeError('offset out of range')
	  }
	}

	function assertSize (size, offset, length) {
	  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
	    throw new TypeError('size must be a number')
	  }

	  if (size > kMaxUint32 || size < 0) {
	    throw new TypeError('size must be a uint32')
	  }

	  if (size + offset > length || size > kBufferMaxLength) {
	    throw new RangeError('buffer too small')
	  }
	}
	if ((crypto && crypto.getRandomValues) || !process.browser) {
	  exports.randomFill = randomFill;
	  exports.randomFillSync = randomFillSync;
	} else {
	  exports.randomFill = oldBrowser;
	  exports.randomFillSync = oldBrowser;
	}
	function randomFill (buf, offset, size, cb) {
	  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  if (typeof offset === 'function') {
	    cb = offset;
	    offset = 0;
	    size = buf.length;
	  } else if (typeof size === 'function') {
	    cb = size;
	    size = buf.length - offset;
	  } else if (typeof cb !== 'function') {
	    throw new TypeError('"cb" argument must be a function')
	  }
	  assertOffset(offset, buf.length);
	  assertSize(size, offset, buf.length);
	  return actualFill(buf, offset, size, cb)
	}

	function actualFill (buf, offset, size, cb) {
	  if (process.browser) {
	    var ourBuf = buf.buffer;
	    var uint = new Uint8Array(ourBuf, offset, size);
	    crypto.getRandomValues(uint);
	    if (cb) {
	      process.nextTick(function () {
	        cb(null, buf);
	      });
	      return
	    }
	    return buf
	  }
	  if (cb) {
	    browser(size, function (err, bytes) {
	      if (err) {
	        return cb(err)
	      }
	      bytes.copy(buf, offset);
	      cb(null, buf);
	    });
	    return
	  }
	  var bytes = browser(size);
	  bytes.copy(buf, offset);
	  return buf
	}
	function randomFillSync (buf, offset, size) {
	  if (typeof offset === 'undefined') {
	    offset = 0;
	  }
	  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  assertOffset(offset, buf.length);

	  if (size === undefined) size = buf.length - offset;

	  assertSize(size, offset, buf.length);

	  return actualFill(buf, offset, size)
	}
	});
	var browser_1$5 = browser$b.randomFill;
	var browser_2$5 = browser$b.randomFillSync;

	var cryptoBrowserify = createCommonjsModule(function (module, exports) {

	exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = browser;
	exports.createHash = exports.Hash = browser$2;
	exports.createHmac = exports.Hmac = browser$3;


	var algoKeys = Object.keys(algos);
	var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);
	exports.getHashes = function () {
	  return hashes
	};


	exports.pbkdf2 = browser$4.pbkdf2;
	exports.pbkdf2Sync = browser$4.pbkdf2Sync;



	exports.Cipher = browser$6.Cipher;
	exports.createCipher = browser$6.createCipher;
	exports.Cipheriv = browser$6.Cipheriv;
	exports.createCipheriv = browser$6.createCipheriv;
	exports.Decipher = browser$6.Decipher;
	exports.createDecipher = browser$6.createDecipher;
	exports.Decipheriv = browser$6.Decipheriv;
	exports.createDecipheriv = browser$6.createDecipheriv;
	exports.getCiphers = browser$6.getCiphers;
	exports.listCiphers = browser$6.listCiphers;



	exports.DiffieHellmanGroup = browser$7.DiffieHellmanGroup;
	exports.createDiffieHellmanGroup = browser$7.createDiffieHellmanGroup;
	exports.getDiffieHellman = browser$7.getDiffieHellman;
	exports.createDiffieHellman = browser$7.createDiffieHellman;
	exports.DiffieHellman = browser$7.DiffieHellman;



	exports.createSign = browser$8.createSign;
	exports.Sign = browser$8.Sign;
	exports.createVerify = browser$8.createVerify;
	exports.Verify = browser$8.Verify;

	exports.createECDH = browser$9;



	exports.publicEncrypt = browser$a.publicEncrypt;
	exports.privateEncrypt = browser$a.privateEncrypt;
	exports.publicDecrypt = browser$a.publicDecrypt;
	exports.privateDecrypt = browser$a.privateDecrypt;

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	// ;[
	//   'createCredentials'
	// ].forEach(function (name) {
	//   exports[name] = function () {
	//     throw new Error([
	//       'sorry, ' + name + ' is not implemented yet',
	//       'we accept pull requests',
	//       'https://github.com/crypto-browserify/crypto-browserify'
	//     ].join('\n'))
	//   }
	// })



	exports.randomFill = browser$b.randomFill;
	exports.randomFillSync = browser$b.randomFillSync;

	exports.createCredentials = function () {
	  throw new Error([
	    'sorry, createCredentials is not implemented yet',
	    'we accept pull requests',
	    'https://github.com/crypto-browserify/crypto-browserify'
	  ].join('\n'))
	};

	exports.constants = {
	  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
	  'DH_CHECK_P_NOT_PRIME': 1,
	  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
	  'DH_NOT_SUITABLE_GENERATOR': 8,
	  'NPN_ENABLED': 1,
	  'ALPN_ENABLED': 1,
	  'RSA_PKCS1_PADDING': 1,
	  'RSA_SSLV23_PADDING': 2,
	  'RSA_NO_PADDING': 3,
	  'RSA_PKCS1_OAEP_PADDING': 4,
	  'RSA_X931_PADDING': 5,
	  'RSA_PKCS1_PSS_PADDING': 6,
	  'POINT_CONVERSION_COMPRESSED': 2,
	  'POINT_CONVERSION_UNCOMPRESSED': 4,
	  'POINT_CONVERSION_HYBRID': 6
	};
	});
	var cryptoBrowserify_1 = cryptoBrowserify.randomBytes;
	var cryptoBrowserify_2 = cryptoBrowserify.rng;
	var cryptoBrowserify_3 = cryptoBrowserify.pseudoRandomBytes;
	var cryptoBrowserify_4 = cryptoBrowserify.prng;
	var cryptoBrowserify_5 = cryptoBrowserify.createHash;
	var cryptoBrowserify_6 = cryptoBrowserify.Hash;
	var cryptoBrowserify_7 = cryptoBrowserify.createHmac;
	var cryptoBrowserify_8 = cryptoBrowserify.Hmac;
	var cryptoBrowserify_9 = cryptoBrowserify.getHashes;
	var cryptoBrowserify_10 = cryptoBrowserify.pbkdf2;
	var cryptoBrowserify_11 = cryptoBrowserify.pbkdf2Sync;
	var cryptoBrowserify_12 = cryptoBrowserify.Cipher;
	var cryptoBrowserify_13 = cryptoBrowserify.createCipher;
	var cryptoBrowserify_14 = cryptoBrowserify.Cipheriv;
	var cryptoBrowserify_15 = cryptoBrowserify.createCipheriv;
	var cryptoBrowserify_16 = cryptoBrowserify.Decipher;
	var cryptoBrowserify_17 = cryptoBrowserify.createDecipher;
	var cryptoBrowserify_18 = cryptoBrowserify.Decipheriv;
	var cryptoBrowserify_19 = cryptoBrowserify.createDecipheriv;
	var cryptoBrowserify_20 = cryptoBrowserify.getCiphers;
	var cryptoBrowserify_21 = cryptoBrowserify.listCiphers;
	var cryptoBrowserify_22 = cryptoBrowserify.DiffieHellmanGroup;
	var cryptoBrowserify_23 = cryptoBrowserify.createDiffieHellmanGroup;
	var cryptoBrowserify_24 = cryptoBrowserify.getDiffieHellman;
	var cryptoBrowserify_25 = cryptoBrowserify.createDiffieHellman;
	var cryptoBrowserify_26 = cryptoBrowserify.DiffieHellman;
	var cryptoBrowserify_27 = cryptoBrowserify.createSign;
	var cryptoBrowserify_28 = cryptoBrowserify.Sign;
	var cryptoBrowserify_29 = cryptoBrowserify.createVerify;
	var cryptoBrowserify_30 = cryptoBrowserify.Verify;
	var cryptoBrowserify_31 = cryptoBrowserify.createECDH;
	var cryptoBrowserify_32 = cryptoBrowserify.publicEncrypt;
	var cryptoBrowserify_33 = cryptoBrowserify.privateEncrypt;
	var cryptoBrowserify_34 = cryptoBrowserify.publicDecrypt;
	var cryptoBrowserify_35 = cryptoBrowserify.privateDecrypt;
	var cryptoBrowserify_36 = cryptoBrowserify.randomFill;
	var cryptoBrowserify_37 = cryptoBrowserify.randomFillSync;
	var cryptoBrowserify_38 = cryptoBrowserify.createCredentials;
	var cryptoBrowserify_39 = cryptoBrowserify.constants;

	// base-x encoding
	// Forked from https://github.com/cryptocoinjs/bs58
	// Originally written by Mike Hearn for BitcoinJ
	// Copyright (c) 2011 Google Inc
	// Ported to JavaScript by Stefan Thomas
	// Merged Buffer refactorings from base58-native by Stephen Pair
	// Copyright (c) 2013 BitPay Inc

	var baseX = function base (ALPHABET) {
	  var ALPHABET_MAP = {};
	  var BASE = ALPHABET.length;
	  var LEADER = ALPHABET.charAt(0);

	  // pre-compute lookup table
	  for (var i = 0; i < ALPHABET.length; i++) {
	    ALPHABET_MAP[ALPHABET.charAt(i)] = i;
	  }

	  function encode (source) {
	    if (source.length === 0) return ''

	    var digits = [0];
	    for (var i = 0; i < source.length; ++i) {
	      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
	        carry += digits[j] << 8;
	        digits[j] = carry % BASE;
	        carry = (carry / BASE) | 0;
	      }

	      while (carry > 0) {
	        digits.push(carry % BASE);
	        carry = (carry / BASE) | 0;
	      }
	    }

	    var string = '';

	    // deal with leading zeros
	    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET[0];
	    // convert digits to a string
	    for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]];

	    return string
	  }

	  function decodeUnsafe (string) {
	    if (string.length === 0) return []

	    var bytes = [0];
	    for (var i = 0; i < string.length; i++) {
	      var value = ALPHABET_MAP[string[i]];
	      if (value === undefined) return

	      for (var j = 0, carry = value; j < bytes.length; ++j) {
	        carry += bytes[j] * BASE;
	        bytes[j] = carry & 0xff;
	        carry >>= 8;
	      }

	      while (carry > 0) {
	        bytes.push(carry & 0xff);
	        carry >>= 8;
	      }
	    }

	    // deal with leading zeros
	    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
	      bytes.push(0);
	    }

	    return bytes.reverse()
	  }

	  function decode (string) {
	    var array = decodeUnsafe(string);
	    if (array) return array

	    throw new Error('Non-base' + BASE + ' character')
	  }

	  return {
	    encode: encode,
	    decodeUnsafe: decodeUnsafe,
	    decode: decode
	  }
	};

	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

	var bs58 = baseX(ALPHABET);

	var encode = (data, prefix = '00', encoding = 'hex') => {
	  if (typeof data === 'string') {
	    data = new Buffer(data, encoding);
	  }
	  if (!(data instanceof Buffer)) {
	    throw new TypeError('"data" argument must be an Array of Buffers')
	  }
	  if (!(prefix instanceof Buffer)) {
	    prefix = new Buffer(prefix, encoding);
	  }
	  let hash = Buffer.concat([prefix, data]);
	  hash = cryptoBrowserify.createHash('sha256').update(hash).digest();
	  hash = cryptoBrowserify.createHash('sha256').update(hash).digest();
	  hash = Buffer.concat([prefix, data,  hash.slice(0, 4)]);
	  return bs58.encode(hash)
	};

	var decode = (string, encoding) => {
	  const buffer = new Buffer(bs58.decode(string));
	  let prefix = buffer.slice(0, 1);
	  let data = buffer.slice(1, -4);
	  let hash = Buffer.concat([prefix, data]);
	  hash = cryptoBrowserify.createHash('sha256').update(hash).digest();
	  hash = cryptoBrowserify.createHash('sha256').update(hash).digest();
	  buffer.slice(-4).forEach((check, index) => {
	    if (check !== hash[index]) {
	      throw new Error('Invalid checksum')
	    }
	  });
	  if (encoding) {
	    prefix = prefix.toString(encoding);
	    data = data.toString(encoding);
	  }
	  return { prefix, data }
	};

	var base58check = {
		encode: encode,
		decode: decode
	};

	var encodeAddress = function encodeAddress(byteArray) {
	    return base58check.encode(Buffer.from(byteArray), ADDRESS_PREFIXES.ACCOUNT);
	};

	var decodeAddress = function decodeAddress(address) {
	    return base58check.decode(address).data;
	};

	/*
	tansaction = {
	    hash : byte of base64 
	    nonce : uint
	    from : byte of base58
	    to : byte of base58
	    amount : uint
	    payload : byte of base64
	    sign : byte of base64
	    type : int
	}
	*/

	function transactionToTx(tx) {
	    var msgtxbody = new rpcTypes.TxBody();
	    msgtxbody.setNonce(tx.nonce);
	    msgtxbody.setAccount(decodeAddress(tx.from));
	    msgtxbody.setRecipient(decodeAddress(tx.to));
	    msgtxbody.setAmount(tx.amount);
	    if (tx.payload != null) {
	        msgtxbody.setPayload(tx.payload);
	    }
	    msgtxbody.setSign(tx.sign);
	    msgtxbody.setType(tx.type);
	    var msgtx = new rpcTypes.Tx();

	    if (tx.hash != null) {
	        msgtx.setHash(tx.hash);
	    }
	    msgtx.setBody(msgtxbody);

	    return msgtx;
	}

	function txToTransaction(tx) {
	    var transaction = {};
	    transaction.hash = tx.getHash_asB64();
	    transaction.nonce = tx.getBody().getNonce();
	    transaction.from = encodeAddress(tx.getBody().getAccount_asU8());
	    transaction.to = encodeAddress(tx.getBody().getRecipient_asU8());
	    transaction.amount = tx.getBody().getAmount();
	    transaction.payload = tx.getBody().getPayload();
	    transaction.sign = tx.getBody().getSign_asB64();
	    transaction.type = tx.getBody().getType();
	    return transaction;
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var Accounts = function () {
	    function Accounts(aergo) {
	        classCallCheck(this, Accounts);

	        this.client = aergo.client;
	    }

	    createClass(Accounts, [{
	        key: 'create',
	        value: function create(passphrase) {
	            var _this = this;

	            return new Promise(function (resolve, reject) {
	                var personal = new rpc_pb_2();
	                personal.setPassphrase(passphrase);
	                try {
	                    _this.client.createAccount(personal, function (err, rsp) {
	                        if (err) {
	                            reject(err);
	                        } else {
	                            var createdAddress = rsp.getAddress_asU8();
	                            resolve(encodeAddress(createdAddress));
	                        }
	                    });
	                } catch (exception) {
	                    reject(exception);
	                }
	            });
	        }
	    }, {
	        key: 'get',
	        value: function get$$1() {
	            var _this2 = this;

	            return new Promise(function (resolve, reject) {
	                var empty = new rpc_pb_1();
	                try {
	                    _this2.client.getAccounts(empty, function (err, rsp) {
	                        if (err) {
	                            reject(err);
	                        } else {
	                            var accounts = rsp.getAccountsList();
	                            var addresses = accounts.map(function (account) {
	                                return encodeAddress(account.getAddress_asU8());
	                            });
	                            resolve(addresses);
	                        }
	                    });
	                } catch (exception) {
	                    reject(exception);
	                }
	            });
	        }
	    }, {
	        key: 'unlock',
	        value: function unlock(address, passphrase) {
	            var _this3 = this;

	            return new Promise(function (resolve, reject) {
	                var account = new rpc_pb_3();
	                account.setAddress(decodeAddress(address));

	                var personal = new rpc_pb_2();
	                personal.setPassphrase(passphrase);
	                personal.setAccount(account);

	                try {
	                    _this3.client.unlockAccount(personal, function (err, rsp) {
	                        if (err) {
	                            reject(err);
	                        } else {
	                            var createdAddress = rsp.getAddress_asU8();
	                            resolve(encodeAddress(createdAddress));
	                        }
	                    });
	                } catch (exception) {
	                    reject(exception);
	                }
	            });
	        }
	    }, {
	        key: 'lock',
	        value: function lock(address, passphrase) {
	            var _this4 = this;

	            return new Promise(function (resolve, reject) {
	                var account = new rpc_pb_3();
	                account.setAddress(decodeAddress(address));

	                var personal = new rpc_pb_2();
	                personal.setPassphrase(passphrase);
	                personal.setAccount(account);

	                try {
	                    _this4.client.lockAccount(personal, function (err, rsp) {
	                        if (err) {
	                            reject(err);
	                        } else {
	                            var createdAddress = rsp.getAddress_asU8();
	                            resolve(encodeAddress(createdAddress));
	                        }
	                    });
	                } catch (exception) {
	                    reject(exception);
	                }
	            });
	        }
	    }, {
	        key: 'signTransaction',
	        value: function signTransaction(tx) {
	            var _this5 = this;

	            return new Promise(function (resolve, reject) {
	                var msgtxbody = new rpc_pb_6();
	                msgtxbody.setNonce(tx.nonce);
	                msgtxbody.setAccount(decodeAddress(tx.from));
	                msgtxbody.setRecipient(decodeAddress(tx.to));
	                msgtxbody.setAmount(tx.amount);
	                msgtxbody.setPayload(tx.payload);
	                msgtxbody.setType(tx.type);

	                var msgtx = new rpc_pb_7();
	                msgtx.setBody(msgtxbody);

	                _this5.client.signTX(msgtx, function (err, signedtx) {
	                    if (err == null) {
	                        resolve(txToTransaction(signedtx));
	                    } else {
	                        reject(err);
	                    }
	                });
	            });
	        }
	    }]);
	    return Accounts;
	}();

	var CommitStatus = rpcTypes.CommitStatus;

	var fromHexString = function fromHexString(hexString) {
	    return new Uint8Array(hexString.match(/.{1,2}/g).map(function (byte) {
	        return parseInt(byte, 16);
	    }));
	};

	var fromNumber = function fromNumber(d) {
	    var arr = new Uint8Array(8);
	    for (var i = 0, j = 1; i < 8; i++, j *= 0x100) {
	        arr[i] = d / j & 0xff;
	    }
	    return arr;
	};

	var errorMessageForCode = function errorMessageForCode(code) {
	    var errorMessage = 'UNDEFINED_ERROR';
	    if (code && code < Object.values(CommitStatus).length) {
	        errorMessage = Object.keys(CommitStatus)[Object.values(CommitStatus).indexOf(code)];
	    }
	    return errorMessage;
	};

	var kCustomPromisifiedSymbol = Symbol('util.promisify.custom');

	function promisify(original, context) {
	    if (typeof context === 'undefined') {
	        context = this;
	    }
	    if (typeof original !== 'function') {
	        throw new Error('original', 'Function', original);
	    }

	    function fn() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        return new Promise(function (resolve, reject) {
	            original.call.apply(original, [context].concat(args, [function (err, value) {
	                if (err) {
	                    return reject(err);
	                }
	                resolve(value);
	            }]));
	        });
	    }

	    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

	    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	        value: fn, enumerable: false, writable: false, configurable: true
	    });
	    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
	}

	var CommitStatus$1 = rpcTypes.CommitStatus;

	var AergoClient = function () {
	    function AergoClient(config) {
	        classCallCheck(this, AergoClient);

	        this.version = 0.1;
	        this.config = _extends({
	            url: '127.0.0.1:7845' }, config);
	        this.client = this.initClient(this.config);
	        this.accounts = new Accounts(this);
	    }

	    createClass(AergoClient, [{
	        key: 'initClient',
	        value: function initClient(config) {
	            // platform-specific override
	        }
	    }, {
	        key: 'getConfig',
	        value: function getConfig() {
	            return this.config;
	        }
	    }, {
	        key: 'isConnected',
	        value: function isConnected() {
	            return false;
	        }
	    }, {
	        key: 'blockchain',
	        value: function blockchain() {
	            var empty = new rpcTypes.Empty();
	            return promisify(this.client.blockchain, this.client)(empty);
	        }

	        // Get transaction information in the aergo node. 
	        // if transaction is in the block return result with block hash and index.

	    }, {
	        key: 'getTransaction',
	        value: function getTransaction(txhash) {
	            var _this = this;

	            var singleBytes = new rpcTypes.SingleBytes();
	            singleBytes.setValue(txhash);
	            return new Promise(function (resolve, reject) {
	                _this.client.getBlockTX(singleBytes, function (err, result) {
	                    if (err) {
	                        _this.client.getTX(singleBytes, function (err, result) {
	                            if (err) {
	                                reject(err);
	                            } else {
	                                var res = {};
	                                res.tx = txToTransaction(result);
	                                resolve(res);
	                            }
	                        });
	                    } else {
	                        var res = {};
	                        res.block = result.getTxidx();
	                        res.tx = txToTransaction(result.getTx());
	                        resolve(res);
	                    }
	                });
	            });
	        }
	    }, {
	        key: 'getBlock',
	        value: function getBlock(hashOrNumber) {
	            if (typeof hashOrNumber === 'string') {
	                hashOrNumber = fromHexString(hashOrNumber);
	            } else if (typeof hashOrNumber === 'number') {
	                hashOrNumber = fromNumber(hashOrNumber);
	            }
	            var singleBytes = new rpcTypes.SingleBytes();
	            singleBytes.setValue(hashOrNumber);
	            return promisify(this.client.getBlock, this.client)(singleBytes);
	        }
	    }, {
	        key: 'getState',
	        value: function getState(address) {
	            var singleBytes = new rpcTypes.SingleBytes();
	            singleBytes.setValue(decodeAddress(address));
	            return promisify(this.client.getState, this.client)(singleBytes);
	        }
	    }, {
	        key: 'getNonce',
	        value: function getNonce(address) {
	            var singleBytes = new rpcTypes.SingleBytes();
	            singleBytes.setValue(decodeAddress(address));
	            return promisify(this.client.getState, this.client)(singleBytes).then(function (state) {
	                return state.getNonce();
	            });
	        }
	    }, {
	        key: 'verifyTransaction',
	        value: function verifyTransaction(tx) {
	            return promisify(this.client.verifyTX, this.client)(transactionToTx(tx));
	        }
	    }, {
	        key: 'sendTransaction',
	        value: function sendTransaction(tx) {
	            var _this2 = this;

	            return new Promise(function (resolve, reject) {
	                var txs = new rpcTypes.TxList();
	                txs.addTxs(transactionToTx(tx), 0);
	                _this2.client.commitTX(txs, function (err, result) {
	                    if (err == null && result.getResultsList()[0].getError()) {
	                        err = new Error();
	                        err.code = result.getResultsList()[0].getError();
	                        err.message = errorMessageForCode(err.code);
	                    }
	                    if (err) {
	                        reject(err);
	                    } else {
	                        resolve(result.getResultsList()[0].getHash_asB64());
	                    }
	                });
	            });
	        }
	    }, {
	        key: 'getTransactionReceipt',
	        value: function getTransactionReceipt(hash, callback) {
	            // eslint-disable-line
	            return true;
	        }
	    }]);
	    return AergoClient;
	}();

	// This function is written in JS (ES5) to avoid an issue with TypeScript targeting ES5, but requiring Symbol.iterator
	function iterateHeaders(headers, callback) {
	  var iterator = headers[Symbol.iterator]();
	  var entry = iterator.next();
	  while(!entry.done) {
	    callback(entry.value[0]);
	    entry = iterator.next();
	  }
	}

	function iterateHeadersKeys(headers, callback) {
	  var iterator = headers.keys();
	  var entry = iterator.next();
	  while(!entry.done) {
	    callback(entry.value);
	    entry = iterator.next();
	  }
	}

	var iterateHeaders_1 = {
	  iterateHeaders: iterateHeaders,
	  iterateHeadersKeys: iterateHeadersKeys
	};

	var util$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	function normalizeName(name) {
	    if (typeof name !== "string") {
	        name = String(name);
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	        throw new TypeError("Invalid character in header field name");
	    }
	    return name.toLowerCase();
	}
	exports.normalizeName = normalizeName;
	function normalizeValue(value) {
	    if (typeof value !== "string") {
	        value = String(value);
	    }
	    return value;
	}
	exports.normalizeValue = normalizeValue;
	function getHeaderValues(headersAsNative, key) {
	    var headers = toWindowHeaders(headersAsNative);
	    if (headers instanceof Headers && headers.getAll) {
	        return headers.getAll(key);
	    }
	    var getValue = headers.get(key);
	    if (getValue && typeof getValue === "string") {
	        return [getValue];
	    }
	    return getValue;
	}
	exports.getHeaderValues = getHeaderValues;
	function toWindowHeaders(headersAsNative) {
	    return headersAsNative;
	}
	function getHeaderKeys(headersAsNative) {
	    var headers = toWindowHeaders(headersAsNative);
	    var asMap = {};
	    var keys = [];
	    if (headers.keys) {
	        iterateHeaders_1.iterateHeadersKeys(headers, function (key) {
	            if (!asMap[key]) {
	                asMap[key] = true;
	                keys.push(key);
	            }
	        });
	    }
	    else if (headers.forEach) {
	        headers.forEach(function (_, key) {
	            if (!asMap[key]) {
	                asMap[key] = true;
	                keys.push(key);
	            }
	        });
	    }
	    else {
	        iterateHeaders_1.iterateHeaders(headers, function (entry) {
	            var key = entry[0];
	            if (!asMap[key]) {
	                asMap[key] = true;
	                keys.push(key);
	            }
	        });
	    }
	    return keys;
	}
	exports.getHeaderKeys = getHeaderKeys;
	function splitHeaderValue(str) {
	    var values = [];
	    var commaSpaceValues = str.split(", ");
	    commaSpaceValues.forEach(function (commaSpaceValue) {
	        commaSpaceValue.split(",").forEach(function (commaValue) {
	            values.push(commaValue);
	        });
	    });
	    return values;
	}
	exports.splitHeaderValue = splitHeaderValue;

	});

	unwrapExports(util$1);
	var util_1 = util$1.normalizeName;
	var util_2 = util$1.normalizeValue;
	var util_3 = util$1.getHeaderValues;
	var util_4 = util$1.getHeaderKeys;
	var util_5 = util$1.splitHeaderValue;

	var BrowserHeaders_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	function isBrowserHeaders(arg) {
	    return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
	}
	var BrowserHeaders = (function () {
	    function BrowserHeaders(init, options) {
	        if (init === void 0) { init = {}; }
	        if (options === void 0) { options = { splitValues: false }; }
	        var _this = this;
	        this.headersMap = {};
	        if (init) {
	            if (typeof Headers !== "undefined" && init instanceof Headers) {
	                var keys = util$1.getHeaderKeys(init);
	                keys.forEach(function (key) {
	                    var values = util$1.getHeaderValues(init, key);
	                    values.forEach(function (value) {
	                        if (options.splitValues) {
	                            _this.append(key, util$1.splitHeaderValue(value));
	                        }
	                        else {
	                            _this.append(key, value);
	                        }
	                    });
	                });
	            }
	            else if (isBrowserHeaders(init)) {
	                init.forEach(function (key, values) {
	                    _this.append(key, values);
	                });
	            }
	            else if (typeof Map !== "undefined" && init instanceof Map) {
	                var asMap = init;
	                asMap.forEach(function (value, key) {
	                    _this.append(key, value);
	                });
	            }
	            else if (typeof init === "string") {
	                this.appendFromString(init);
	            }
	            else if (typeof init === "object") {
	                Object.getOwnPropertyNames(init).forEach(function (key) {
	                    var asObject = init;
	                    var values = asObject[key];
	                    if (Array.isArray(values)) {
	                        values.forEach(function (value) {
	                            _this.append(key, value);
	                        });
	                    }
	                    else {
	                        _this.append(key, values);
	                    }
	                });
	            }
	        }
	    }
	    BrowserHeaders.prototype.appendFromString = function (str) {
	        var pairs = str.split("\r\n");
	        for (var i = 0; i < pairs.length; i++) {
	            var p = pairs[i];
	            var index = p.indexOf(":");
	            if (index > 0) {
	                var key = p.substring(0, index).trim();
	                var value = p.substring(index + 1).trim();
	                this.append(key, value);
	            }
	        }
	    };
	    BrowserHeaders.prototype.delete = function (key, value) {
	        var normalizedKey = util$1.normalizeName(key);
	        if (value === undefined) {
	            delete this.headersMap[normalizedKey];
	        }
	        else {
	            var existing = this.headersMap[normalizedKey];
	            if (existing) {
	                var index = existing.indexOf(value);
	                if (index >= 0) {
	                    existing.splice(index, 1);
	                }
	                if (existing.length === 0) {
	                    delete this.headersMap[normalizedKey];
	                }
	            }
	        }
	    };
	    BrowserHeaders.prototype.append = function (key, value) {
	        var _this = this;
	        var normalizedKey = util$1.normalizeName(key);
	        if (!Array.isArray(this.headersMap[normalizedKey])) {
	            this.headersMap[normalizedKey] = [];
	        }
	        if (Array.isArray(value)) {
	            value.forEach(function (arrayValue) {
	                _this.headersMap[normalizedKey].push(util$1.normalizeValue(arrayValue));
	            });
	        }
	        else {
	            this.headersMap[normalizedKey].push(util$1.normalizeValue(value));
	        }
	    };
	    BrowserHeaders.prototype.set = function (key, value) {
	        var normalizedKey = util$1.normalizeName(key);
	        if (Array.isArray(value)) {
	            var normalized_1 = [];
	            value.forEach(function (arrayValue) {
	                normalized_1.push(util$1.normalizeValue(arrayValue));
	            });
	            this.headersMap[normalizedKey] = normalized_1;
	        }
	        else {
	            this.headersMap[normalizedKey] = [util$1.normalizeValue(value)];
	        }
	    };
	    BrowserHeaders.prototype.has = function (key, value) {
	        var keyArray = this.headersMap[util$1.normalizeName(key)];
	        var keyExists = Array.isArray(keyArray);
	        if (!keyExists) {
	            return false;
	        }
	        if (value !== undefined) {
	            var normalizedValue = util$1.normalizeValue(value);
	            return keyArray.indexOf(normalizedValue) >= 0;
	        }
	        else {
	            return true;
	        }
	    };
	    BrowserHeaders.prototype.get = function (key) {
	        var values = this.headersMap[util$1.normalizeName(key)];
	        if (values !== undefined) {
	            return values.concat();
	        }
	        return [];
	    };
	    BrowserHeaders.prototype.forEach = function (callback) {
	        var _this = this;
	        Object.getOwnPropertyNames(this.headersMap)
	            .forEach(function (key) {
	            callback(key, _this.headersMap[key]);
	        }, this);
	    };
	    BrowserHeaders.prototype.toHeaders = function () {
	        if (typeof Headers !== "undefined") {
	            var headers_1 = new Headers();
	            this.forEach(function (key, values) {
	                values.forEach(function (value) {
	                    headers_1.append(key, value);
	                });
	            });
	            return headers_1;
	        }
	        else {
	            throw new Error("Headers class is not defined");
	        }
	    };
	    return BrowserHeaders;
	}());
	exports.BrowserHeaders = BrowserHeaders;

	});

	unwrapExports(BrowserHeaders_1);
	var BrowserHeaders_2 = BrowserHeaders_1.BrowserHeaders;

	var lib = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;

	});

	unwrapExports(lib);
	var lib_1 = lib.BrowserHeaders;

	var metadata = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.Metadata = lib.BrowserHeaders;

	});

	unwrapExports(metadata);
	var metadata_1 = metadata.Metadata;

	var debug_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function debug() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    if (console.debug) {
	        console.debug.apply(null, args);
	    }
	    else {
	        console.log.apply(null, args);
	    }
	}
	exports.debug = debug;

	});

	unwrapExports(debug_1);
	var debug_2 = debug_1.debug;

	var detach_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var awaitingExecution = null;
	function runCallbacks() {
	    if (awaitingExecution) {
	        var thisCallbackSet = awaitingExecution;
	        awaitingExecution = null;
	        for (var i = 0; i < thisCallbackSet.length; i++) {
	            try {
	                thisCallbackSet[i]();
	            }
	            catch (e) {
	                if (awaitingExecution === null) {
	                    awaitingExecution = [];
	                    setTimeout(function () {
	                        runCallbacks();
	                    }, 0);
	                }
	                for (var k = thisCallbackSet.length - 1; k > i; k--) {
	                    awaitingExecution.unshift(thisCallbackSet[k]);
	                }
	                throw e;
	            }
	        }
	    }
	}
	function detach(cb) {
	    if (awaitingExecution !== null) {
	        awaitingExecution.push(cb);
	        return;
	    }
	    awaitingExecution = [cb];
	    setTimeout(function () {
	        runCallbacks();
	    }, 0);
	}
	exports.default = detach;

	});

	unwrapExports(detach_1);

	var fetch_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	function fetchRequest(options) {
	    options.debug && debug_1.debug("fetchRequest", options);
	    return new Fetch(options);
	}
	exports.default = fetchRequest;
	var Fetch = (function () {
	    function Fetch(transportOptions) {
	        this.cancelled = false;
	        this.controller = window.AbortController && new AbortController();
	        this.options = transportOptions;
	    }
	    Fetch.prototype.pump = function (readerArg, res) {
	        var _this = this;
	        this.reader = readerArg;
	        if (this.cancelled) {
	            this.options.debug && debug_1.debug("Fetch.pump.cancel at first pump");
	            this.reader.cancel();
	            return;
	        }
	        this.reader.read()
	            .then(function (result) {
	            if (result.done) {
	                detach_1.default(function () {
	                    _this.options.onEnd();
	                });
	                return res;
	            }
	            detach_1.default(function () {
	                _this.options.onChunk(result.value);
	            });
	            _this.pump(_this.reader, res);
	            return;
	        });
	    };
	    Fetch.prototype.send = function (msgBytes) {
	        var _this = this;
	        fetch(this.options.url, {
	            headers: this.metadata.toHeaders(),
	            method: "POST",
	            body: msgBytes,
	            credentials: "same-origin",
	            signal: this.controller && this.controller.signal
	        }).then(function (res) {
	            _this.options.debug && debug_1.debug("Fetch.response", res);
	            detach_1.default(function () {
	                _this.options.onHeaders(new metadata.Metadata(res.headers), res.status);
	            });
	            if (res.body) {
	                _this.pump(res.body.getReader(), res);
	                return;
	            }
	            return res;
	        }).catch(function (err) {
	            if (_this.cancelled) {
	                _this.options.debug && debug_1.debug("Fetch.catch - request cancelled");
	                return;
	            }
	            _this.options.debug && debug_1.debug("Fetch.catch", err.message);
	            detach_1.default(function () {
	                _this.options.onEnd(err);
	            });
	        });
	    };
	    Fetch.prototype.sendMessage = function (msgBytes) {
	        this.send(msgBytes);
	    };
	    Fetch.prototype.finishSend = function () {
	    };
	    Fetch.prototype.start = function (metadata$$1) {
	        this.metadata = metadata$$1;
	    };
	    Fetch.prototype.cancel = function () {
	        this.cancelled = true;
	        if (this.reader) {
	            this.options.debug && debug_1.debug("Fetch.abort.cancel");
	            this.reader.cancel();
	        }
	        else {
	            this.options.debug && debug_1.debug("Fetch.abort.cancel before reader");
	        }
	        if (this.controller) {
	            this.controller.abort();
	        }
	    };
	    return Fetch;
	}());
	function detectFetchSupport() {
	    return typeof Response !== "undefined" && Response.prototype.hasOwnProperty("body") && typeof Headers === "function";
	}
	exports.detectFetchSupport = detectFetchSupport;

	});

	unwrapExports(fetch_1);
	var fetch_2 = fetch_1.detectFetchSupport;

	var xhr = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	function xhrRequest(options) {
	    options.debug && debug_1.debug("xhrRequest", options);
	    return new XHR(options);
	}
	exports.default = xhrRequest;
	var XHR = (function () {
	    function XHR(transportOptions) {
	        this.options = transportOptions;
	    }
	    XHR.prototype.onProgressEvent = function () {
	        var _this = this;
	        this.options.debug && debug_1.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
	        var rawText = this.xhr.response.substr(this.index);
	        this.index = this.xhr.response.length;
	        var asArrayBuffer = stringToArrayBuffer(rawText);
	        detach_1.default(function () {
	            _this.options.onChunk(asArrayBuffer);
	        });
	    };
	    XHR.prototype.onLoadEvent = function () {
	        var _this = this;
	        this.options.debug && debug_1.debug("XHR.onLoadEvent");
	        detach_1.default(function () {
	            _this.options.onEnd();
	        });
	    };
	    XHR.prototype.onStateChange = function () {
	        var _this = this;
	        this.options.debug && debug_1.debug("XHR.onStateChange", this.xhr.readyState);
	        if (this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
	            detach_1.default(function () {
	                _this.options.onHeaders(new metadata.Metadata(_this.xhr.getAllResponseHeaders()), _this.xhr.status);
	            });
	        }
	    };
	    XHR.prototype.sendMessage = function (msgBytes) {
	        this.xhr.send(msgBytes);
	    };
	    XHR.prototype.finishSend = function () {
	    };
	    XHR.prototype.start = function (metadata$$1) {
	        var _this = this;
	        this.metadata = metadata$$1;
	        var xhr = new XMLHttpRequest();
	        this.xhr = xhr;
	        xhr.open("POST", this.options.url);
	        xhr.responseType = "text";
	        xhr.overrideMimeType("text/plain; charset=x-user-defined");
	        this.metadata.forEach(function (key, values) {
	            xhr.setRequestHeader(key, values.join(", "));
	        });
	        xhr.addEventListener("readystatechange", this.onStateChange.bind(this));
	        xhr.addEventListener("progress", this.onProgressEvent.bind(this));
	        xhr.addEventListener("loadend", this.onLoadEvent.bind(this));
	        xhr.addEventListener("error", function (err) {
	            _this.options.debug && debug_1.debug("XHR.error", err);
	            detach_1.default(function () {
	                _this.options.onEnd(err.error);
	            });
	        });
	    };
	    XHR.prototype.cancel = function () {
	        this.options.debug && debug_1.debug("XHR.abort");
	        this.xhr.abort();
	    };
	    return XHR;
	}());
	function codePointAtPolyfill(str, index) {
	    var code = str.charCodeAt(index);
	    if (code >= 0xd800 && code <= 0xdbff) {
	        var surr = str.charCodeAt(index + 1);
	        if (surr >= 0xdc00 && surr <= 0xdfff) {
	            code = 0x10000 + ((code - 0xd800) << 10) + (surr - 0xdc00);
	        }
	    }
	    return code;
	}
	function stringToArrayBuffer(str) {
	    var asArray = new Uint8Array(str.length);
	    var arrayIndex = 0;
	    for (var i = 0; i < str.length; i++) {
	        var codePoint = String.prototype.codePointAt ? str.codePointAt(i) : codePointAtPolyfill(str, i);
	        asArray[arrayIndex++] = codePoint & 0xFF;
	    }
	    return asArray;
	}
	exports.stringToArrayBuffer = stringToArrayBuffer;
	function detectXHRSupport() {
	    return typeof XMLHttpRequest !== "undefined" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
	}
	exports.detectXHRSupport = detectXHRSupport;

	});

	unwrapExports(xhr);
	var xhr_1 = xhr.stringToArrayBuffer;
	var xhr_2 = xhr.detectXHRSupport;

	var xhrUtil = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var xhr;
	function getXHR() {
	    if (xhr !== undefined)
	        return xhr;
	    if (XMLHttpRequest) {
	        xhr = new XMLHttpRequest();
	        try {
	            xhr.open("GET", "https://localhost");
	        }
	        catch (e) { }
	    }
	    return xhr;
	}
	function xhrSupportsResponseType(type) {
	    var xhr = getXHR();
	    if (!xhr) {
	        return false;
	    }
	    try {
	        xhr.responseType = type;
	        return xhr.responseType === type;
	    }
	    catch (e) { }
	    return false;
	}
	exports.xhrSupportsResponseType = xhrSupportsResponseType;

	});

	unwrapExports(xhrUtil);
	var xhrUtil_1 = xhrUtil.xhrSupportsResponseType;

	var mozXhr = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });




	function mozXhrRequest(options) {
	    options.debug && debug_1.debug("mozXhrRequest", options);
	    return new MozXHR(options);
	}
	exports.default = mozXhrRequest;
	var MozXHR = (function () {
	    function MozXHR(transportOptions) {
	        this.options = transportOptions;
	    }
	    MozXHR.prototype.onProgressEvent = function () {
	        var _this = this;
	        var resp = this.xhr.response;
	        this.options.debug && debug_1.debug("MozXHR.onProgressEvent: ", new Uint8Array(resp));
	        detach_1.default(function () {
	            _this.options.onChunk(new Uint8Array(resp));
	        });
	    };
	    MozXHR.prototype.onLoadEvent = function () {
	        var _this = this;
	        this.options.debug && debug_1.debug("MozXHR.onLoadEvent");
	        detach_1.default(function () {
	            _this.options.onEnd();
	        });
	    };
	    MozXHR.prototype.onStateChange = function () {
	        var _this = this;
	        this.options.debug && debug_1.debug("MozXHR.onStateChange", this.xhr.readyState);
	        this.options.debug && debug_1.debug("MozXHR.XMLHttpRequest.HEADERS_RECEIVED", XMLHttpRequest.HEADERS_RECEIVED);
	        if (this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
	            detach_1.default(function () {
	                _this.options.onHeaders(new metadata.Metadata(_this.xhr.getAllResponseHeaders()), _this.xhr.status);
	            });
	        }
	    };
	    MozXHR.prototype.sendMessage = function (msgBytes) {
	        this.options.debug && debug_1.debug("MozXHR.sendMessage");
	        this.xhr.send(msgBytes);
	    };
	    MozXHR.prototype.finishSend = function () {
	    };
	    MozXHR.prototype.start = function (metadata$$1) {
	        var _this = this;
	        this.options.debug && debug_1.debug("MozXHR.start");
	        this.metadata = metadata$$1;
	        var xhr = new XMLHttpRequest();
	        this.xhr = xhr;
	        xhr.open("POST", this.options.url);
	        xhr.responseType = "moz-chunked-arraybuffer";
	        this.metadata.forEach(function (key, values) {
	            xhr.setRequestHeader(key, values.join(", "));
	        });
	        xhr.addEventListener("readystatechange", this.onStateChange.bind(this));
	        xhr.addEventListener("progress", this.onProgressEvent.bind(this));
	        xhr.addEventListener("loadend", this.onLoadEvent.bind(this));
	        xhr.addEventListener("error", function (err) {
	            _this.options.debug && debug_1.debug("MozXHR.error", err);
	            detach_1.default(function () {
	                _this.options.onEnd(err.error);
	            });
	        });
	    };
	    MozXHR.prototype.cancel = function () {
	        this.options.debug && debug_1.debug("MozXHR.cancel");
	        this.xhr.abort();
	    };
	    return MozXHR;
	}());
	function detectMozXHRSupport() {
	    return typeof XMLHttpRequest !== "undefined" && xhrUtil.xhrSupportsResponseType("moz-chunked-arraybuffer");
	}
	exports.detectMozXHRSupport = detectMozXHRSupport;

	});

	unwrapExports(mozXhr);
	var mozXhr_1 = mozXhr.detectMozXHRSupport;

	var nodeHttp = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });




	function nodeHttpRequest(options) {
	    options.debug && console.log("nodeHttpRequest", options);
	    return new NodeHttp(options);
	}
	exports.default = nodeHttpRequest;
	var NodeHttp = (function () {
	    function NodeHttp(transportOptions) {
	        this.options = transportOptions;
	    }
	    NodeHttp.prototype.sendMessage = function (msgBytes) {
	        this.request.write(toBuffer(msgBytes));
	        this.request.end();
	    };
	    NodeHttp.prototype.finishSend = function () {
	    };
	    NodeHttp.prototype.responseCallback = function (response) {
	        var _this = this;
	        this.options.debug && console.log("NodeHttp.response", response.statusCode);
	        var headers = filterHeadersForUndefined(response.headers);
	        this.options.onHeaders(new metadata.Metadata(headers), response.statusCode);
	        response.on("data", function (chunk) {
	            _this.options.debug && console.log("NodeHttp.data", chunk);
	            _this.options.onChunk(toArrayBuffer(chunk));
	        });
	        response.on("end", function () {
	            _this.options.debug && console.log("NodeHttp.end");
	            _this.options.onEnd();
	        });
	    };
	    NodeHttp.prototype.start = function (metadata$$1) {
	        var _this = this;
	        var headers = {};
	        metadata$$1.forEach(function (key, values) {
	            headers[key] = values.join(", ");
	        });
	        var parsedUrl = url.parse(this.options.url);
	        var httpOptions = {
	            host: parsedUrl.hostname,
	            port: parsedUrl.port ? parseInt(parsedUrl.port) : undefined,
	            path: parsedUrl.path,
	            headers: headers,
	            method: "POST"
	        };
	        if (parsedUrl.protocol === "https:") {
	            this.request = https.request(httpOptions, this.responseCallback.bind(this));
	        }
	        else {
	            this.request = http.request(httpOptions, this.responseCallback.bind(this));
	        }
	        this.request.on("error", function (err) {
	            _this.options.debug && console.log("NodeHttp.error", err);
	            _this.options.onEnd(err);
	        });
	    };
	    NodeHttp.prototype.cancel = function () {
	        this.options.debug && console.log("NodeHttp.abort");
	        this.request.abort();
	    };
	    return NodeHttp;
	}());
	function filterHeadersForUndefined(headers) {
	    var filteredHeaders = {};
	    for (var key in headers) {
	        var value = headers[key];
	        if (headers.hasOwnProperty(key)) {
	            if (value !== undefined) {
	                filteredHeaders[key] = value;
	            }
	        }
	    }
	    return filteredHeaders;
	}
	function toArrayBuffer(buf) {
	    var view = new Uint8Array(buf.length);
	    for (var i = 0; i < buf.length; i++) {
	        view[i] = buf[i];
	    }
	    return view;
	}
	function toBuffer(ab) {
	    var buf = new Buffer(ab.byteLength);
	    for (var i = 0; i < buf.length; i++) {
	        buf[i] = ab[i];
	    }
	    return buf;
	}
	function detectNodeHTTPSupport() {
	    return module.exports;
	}
	exports.detectNodeHTTPSupport = detectNodeHTTPSupport;

	});

	unwrapExports(nodeHttp);
	var nodeHttp_1 = nodeHttp.detectNodeHTTPSupport;

	var ChunkParser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var HEADER_SIZE = 5;
	var isAllowedControlChars = function (char) { return char === 0x9 || char === 0xa || char === 0xd; };
	function isValidHeaderAscii(val) {
	    return isAllowedControlChars(val) || (val >= 0x20 && val <= 0x7e);
	}
	function decodeASCII(input) {
	    for (var i = 0; i !== input.length; ++i) {
	        if (!isValidHeaderAscii(input[i])) {
	            throw new Error("Metadata is not valid (printable) ASCII");
	        }
	    }
	    return String.fromCharCode.apply(String, Array.prototype.slice.call(input));
	}
	exports.decodeASCII = decodeASCII;
	function encodeASCII(input) {
	    var encoded = new Uint8Array(input.length);
	    for (var i = 0; i !== input.length; ++i) {
	        var charCode = input.charCodeAt(i);
	        if (!isValidHeaderAscii(charCode)) {
	            throw new Error("Metadata contains invalid ASCII");
	        }
	        encoded[i] = charCode;
	    }
	    return encoded;
	}
	exports.encodeASCII = encodeASCII;
	function isTrailerHeader(headerView) {
	    return (headerView.getUint8(0) & 0x80) === 0x80;
	}
	function parseTrailerData(msgData) {
	    return new metadata.Metadata(decodeASCII(msgData));
	}
	function readLengthFromHeader(headerView) {
	    return headerView.getUint32(1, false);
	}
	function hasEnoughBytes(buffer, position, byteCount) {
	    return buffer.byteLength - position >= byteCount;
	}
	function sliceUint8Array(buffer, from, to) {
	    if (buffer.slice) {
	        return buffer.slice(from, to);
	    }
	    var end = buffer.length;
	    if (to !== undefined) {
	        end = to;
	    }
	    var num = end - from;
	    var array = new Uint8Array(num);
	    var arrayIndex = 0;
	    for (var i = from; i < end; i++) {
	        array[arrayIndex++] = buffer[i];
	    }
	    return array;
	}
	var ChunkType;
	(function (ChunkType) {
	    ChunkType[ChunkType["MESSAGE"] = 1] = "MESSAGE";
	    ChunkType[ChunkType["TRAILERS"] = 2] = "TRAILERS";
	})(ChunkType = exports.ChunkType || (exports.ChunkType = {}));
	var ChunkParser = (function () {
	    function ChunkParser() {
	        this.buffer = null;
	        this.position = 0;
	    }
	    ChunkParser.prototype.parse = function (bytes, flush) {
	        if (bytes.length === 0 && flush) {
	            return [];
	        }
	        var chunkData = [];
	        if (this.buffer == null) {
	            this.buffer = bytes;
	            this.position = 0;
	        }
	        else if (this.position === this.buffer.byteLength) {
	            this.buffer = bytes;
	            this.position = 0;
	        }
	        else {
	            var remaining = this.buffer.byteLength - this.position;
	            var newBuf = new Uint8Array(remaining + bytes.byteLength);
	            var fromExisting = sliceUint8Array(this.buffer, this.position);
	            newBuf.set(fromExisting, 0);
	            var latestDataBuf = new Uint8Array(bytes);
	            newBuf.set(latestDataBuf, remaining);
	            this.buffer = newBuf;
	            this.position = 0;
	        }
	        while (true) {
	            if (!hasEnoughBytes(this.buffer, this.position, HEADER_SIZE)) {
	                return chunkData;
	            }
	            var headerBuffer = sliceUint8Array(this.buffer, this.position, this.position + HEADER_SIZE);
	            var headerView = new DataView(headerBuffer.buffer, headerBuffer.byteOffset, headerBuffer.byteLength);
	            var msgLength = readLengthFromHeader(headerView);
	            if (!hasEnoughBytes(this.buffer, this.position, HEADER_SIZE + msgLength)) {
	                return chunkData;
	            }
	            var messageData = sliceUint8Array(this.buffer, this.position + HEADER_SIZE, this.position + HEADER_SIZE + msgLength);
	            this.position += HEADER_SIZE + msgLength;
	            if (isTrailerHeader(headerView)) {
	                chunkData.push({ chunkType: ChunkType.TRAILERS, trailers: parseTrailerData(messageData) });
	                return chunkData;
	            }
	            else {
	                chunkData.push({ chunkType: ChunkType.MESSAGE, data: messageData });
	            }
	        }
	    };
	    return ChunkParser;
	}());
	exports.ChunkParser = ChunkParser;

	});

	unwrapExports(ChunkParser_1);
	var ChunkParser_2 = ChunkParser_1.decodeASCII;
	var ChunkParser_3 = ChunkParser_1.encodeASCII;
	var ChunkParser_4 = ChunkParser_1.ChunkType;
	var ChunkParser_5 = ChunkParser_1.ChunkParser;

	var websocket = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var WebsocketSignal;
	(function (WebsocketSignal) {
	    WebsocketSignal[WebsocketSignal["FINISH_SEND"] = 1] = "FINISH_SEND";
	})(WebsocketSignal || (WebsocketSignal = {}));
	var finishSendFrame = new Uint8Array([1]);
	function websocketRequest(options) {
	    options.debug && debug_1.debug("websocketRequest", options);
	    var webSocketAddress = constructWebSocketAddress(options.url);
	    var sendQueue = [];
	    var ws;
	    function sendToWebsocket(toSend) {
	        if (toSend === WebsocketSignal.FINISH_SEND) {
	            ws.send(finishSendFrame);
	        }
	        else {
	            var byteArray = toSend;
	            var c = new Int8Array(byteArray.byteLength + 1);
	            c.set(new Uint8Array([0]));
	            c.set(byteArray, 1);
	            ws.send(c);
	        }
	    }
	    return {
	        sendMessage: function (msgBytes) {
	            if (!ws || ws.readyState === ws.CONNECTING) {
	                sendQueue.push(msgBytes);
	            }
	            else {
	                sendToWebsocket(msgBytes);
	            }
	        },
	        finishSend: function () {
	            if (!ws || ws.readyState === ws.CONNECTING) {
	                sendQueue.push(WebsocketSignal.FINISH_SEND);
	            }
	            else {
	                sendToWebsocket(WebsocketSignal.FINISH_SEND);
	            }
	        },
	        start: function (metadata) {
	            ws = new WebSocket(webSocketAddress, ["grpc-websockets"]);
	            ws.binaryType = "arraybuffer";
	            ws.onopen = function () {
	                options.debug && debug_1.debug("websocketRequest.onopen");
	                ws.send(headersToBytes(metadata));
	                sendQueue.forEach(function (toSend) {
	                    sendToWebsocket(toSend);
	                });
	            };
	            ws.onclose = function (closeEvent) {
	                options.debug && debug_1.debug("websocketRequest.onclose", closeEvent);
	                detach_1.default(function () {
	                    options.onEnd();
	                });
	            };
	            ws.onerror = function (error) {
	                options.debug && debug_1.debug("websocketRequest.onerror", error);
	            };
	            ws.onmessage = function (e) {
	                detach_1.default(function () {
	                    options.onChunk(new Uint8Array(e.data));
	                });
	            };
	        },
	        cancel: function () {
	            options.debug && debug_1.debug("websocket.abort");
	            detach_1.default(function () {
	                ws.close();
	            });
	        }
	    };
	}
	exports.default = websocketRequest;
	function constructWebSocketAddress(url$$1) {
	    if (url$$1.substr(0, 8) === "https://") {
	        return "wss://" + url$$1.substr(8);
	    }
	    else if (url$$1.substr(0, 7) === "http://") {
	        return "ws://" + url$$1.substr(7);
	    }
	    throw new Error("Websocket transport constructed with non-https:// or http:// host.");
	}
	function headersToBytes(headers) {
	    var asString = "";
	    headers.forEach(function (key, values) {
	        asString += key + ": " + values.join(", ") + "\r\n";
	    });
	    return ChunkParser_1.encodeASCII(asString);
	}

	});

	unwrapExports(websocket);

	var Transport = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });





	var selectedTransport;
	function DefaultTransportFactory(transportOptions) {
	    if (transportOptions.methodDefinition.requestStream) {
	        return new Error("No transport available for client-streaming (requestStream) method");
	    }
	    if (!selectedTransport) {
	        selectedTransport = detectTransport();
	    }
	    return selectedTransport(transportOptions);
	}
	exports.DefaultTransportFactory = DefaultTransportFactory;
	function detectTransport() {
	    if (fetch_1.detectFetchSupport()) {
	        return fetch_1.default;
	    }
	    if (mozXhr.detectMozXHRSupport()) {
	        return mozXhr.default;
	    }
	    if (xhr.detectXHRSupport()) {
	        return xhr.default;
	    }
	    if (nodeHttp.detectNodeHTTPSupport()) {
	        return nodeHttp.default;
	    }
	    throw new Error("No suitable transport found for gRPC-Web");
	}
	function WebsocketTransportFactory(transportOptions) {
	    return websocket.default(transportOptions);
	}
	exports.WebsocketTransportFactory = WebsocketTransportFactory;

	});

	unwrapExports(Transport);
	var Transport_1 = Transport.DefaultTransportFactory;
	var Transport_2 = Transport.WebsocketTransportFactory;

	var Code_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Code;
	(function (Code) {
	    Code[Code["OK"] = 0] = "OK";
	    Code[Code["Canceled"] = 1] = "Canceled";
	    Code[Code["Unknown"] = 2] = "Unknown";
	    Code[Code["InvalidArgument"] = 3] = "InvalidArgument";
	    Code[Code["DeadlineExceeded"] = 4] = "DeadlineExceeded";
	    Code[Code["NotFound"] = 5] = "NotFound";
	    Code[Code["AlreadyExists"] = 6] = "AlreadyExists";
	    Code[Code["PermissionDenied"] = 7] = "PermissionDenied";
	    Code[Code["ResourceExhausted"] = 8] = "ResourceExhausted";
	    Code[Code["FailedPrecondition"] = 9] = "FailedPrecondition";
	    Code[Code["Aborted"] = 10] = "Aborted";
	    Code[Code["OutOfRange"] = 11] = "OutOfRange";
	    Code[Code["Unimplemented"] = 12] = "Unimplemented";
	    Code[Code["Internal"] = 13] = "Internal";
	    Code[Code["Unavailable"] = 14] = "Unavailable";
	    Code[Code["DataLoss"] = 15] = "DataLoss";
	    Code[Code["Unauthenticated"] = 16] = "Unauthenticated";
	})(Code = exports.Code || (exports.Code = {}));
	function httpStatusToCode(httpStatus) {
	    switch (httpStatus) {
	        case 0:
	            return Code.Internal;
	        case 200:
	            return Code.OK;
	        case 400:
	            return Code.InvalidArgument;
	        case 401:
	            return Code.Unauthenticated;
	        case 403:
	            return Code.PermissionDenied;
	        case 404:
	            return Code.NotFound;
	        case 409:
	            return Code.Aborted;
	        case 412:
	            return Code.FailedPrecondition;
	        case 429:
	            return Code.ResourceExhausted;
	        case 499:
	            return Code.Canceled;
	        case 500:
	            return Code.Unknown;
	        case 501:
	            return Code.Unimplemented;
	        case 503:
	            return Code.Unavailable;
	        case 504:
	            return Code.DeadlineExceeded;
	        default:
	            return Code.Unknown;
	    }
	}
	exports.httpStatusToCode = httpStatusToCode;

	});

	unwrapExports(Code_1);
	var Code_2 = Code_1.Code;
	var Code_3 = Code_1.httpStatusToCode;

	var util$3 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function frameRequest(request) {
	    var bytes = request.serializeBinary();
	    var frame = new ArrayBuffer(bytes.byteLength + 5);
	    new DataView(frame, 1, 4).setUint32(0, bytes.length, false);
	    new Uint8Array(frame, 5).set(bytes);
	    return new Uint8Array(frame);
	}
	exports.frameRequest = frameRequest;

	});

	unwrapExports(util$3);
	var util_1$1 = util$3.frameRequest;

	var client_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });







	function client(methodDescriptor, props) {
	    return new GrpcClient(methodDescriptor, props);
	}
	exports.client = client;
	var GrpcClient = (function () {
	    function GrpcClient(methodDescriptor, props) {
	        this.started = false;
	        this.sentFirstMessage = false;
	        this.completed = false;
	        this.closed = false;
	        this.finishedSending = false;
	        this.onHeadersCallbacks = [];
	        this.onMessageCallbacks = [];
	        this.onEndCallbacks = [];
	        this.parser = new ChunkParser_1.ChunkParser();
	        this.methodDefinition = methodDescriptor;
	        this.props = props;
	        this.createTransport();
	    }
	    GrpcClient.prototype.createTransport = function () {
	        var url$$1 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName;
	        var transportOptions = {
	            methodDefinition: this.methodDefinition,
	            debug: this.props.debug || false,
	            url: url$$1,
	            onHeaders: this.onTransportHeaders.bind(this),
	            onChunk: this.onTransportChunk.bind(this),
	            onEnd: this.onTransportEnd.bind(this),
	        };
	        var transportConstructor = this.props.transport;
	        if (transportConstructor) {
	            var constructedTransport = transportConstructor(transportOptions);
	            if (constructedTransport instanceof Error) {
	                throw constructedTransport;
	            }
	            this.transport = constructedTransport;
	        }
	        else {
	            var factoryTransport = Transport.DefaultTransportFactory(transportOptions);
	            if (factoryTransport instanceof Error) {
	                throw factoryTransport;
	            }
	            this.transport = factoryTransport;
	        }
	    };
	    GrpcClient.prototype.onTransportHeaders = function (headers, status) {
	        this.props.debug && debug_1.debug("onHeaders", headers, status);
	        if (this.closed) {
	            this.props.debug && debug_1.debug("grpc.onHeaders received after request was closed - ignoring");
	            return;
	        }
	        if (status === 0) ;
	        else {
	            this.responseHeaders = headers;
	            this.props.debug && debug_1.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
	            var code = Code_1.httpStatusToCode(status);
	            this.props.debug && debug_1.debug("onHeaders.code", code);
	            var gRPCMessage = headers.get("grpc-message") || [];
	            this.props.debug && debug_1.debug("onHeaders.gRPCMessage", gRPCMessage);
	            if (code !== Code_1.Code.OK) {
	                var statusMessage = this.decodeGRPCStatus(gRPCMessage[0]);
	                this.rawOnError(code, statusMessage);
	                return;
	            }
	            this.rawOnHeaders(headers);
	        }
	    };
	    GrpcClient.prototype.onTransportChunk = function (chunkBytes) {
	        var _this = this;
	        if (this.closed) {
	            this.props.debug && debug_1.debug("grpc.onChunk received after request was closed - ignoring");
	            return;
	        }
	        var data = [];
	        try {
	            data = this.parser.parse(chunkBytes);
	        }
	        catch (e) {
	            this.props.debug && debug_1.debug("onChunk.parsing error", e, e.message);
	            this.rawOnError(Code_1.Code.Internal, "parsing error: " + e.message);
	            return;
	        }
	        data.forEach(function (d) {
	            if (d.chunkType === ChunkParser_1.ChunkType.MESSAGE) {
	                var deserialized = _this.methodDefinition.responseType.deserializeBinary(d.data);
	                _this.rawOnMessage(deserialized);
	            }
	            else if (d.chunkType === ChunkParser_1.ChunkType.TRAILERS) {
	                if (!_this.responseHeaders) {
	                    _this.responseHeaders = new metadata.Metadata(d.trailers);
	                    _this.rawOnHeaders(_this.responseHeaders);
	                }
	                else {
	                    _this.responseTrailers = new metadata.Metadata(d.trailers);
	                    _this.props.debug && debug_1.debug("onChunk.trailers", _this.responseTrailers);
	                }
	            }
	        });
	    };
	    GrpcClient.prototype.onTransportEnd = function () {
	        this.props.debug && debug_1.debug("grpc.onEnd");
	        if (this.closed) {
	            this.props.debug && debug_1.debug("grpc.onEnd received after request was closed - ignoring");
	            return;
	        }
	        if (this.responseTrailers === undefined) {
	            if (this.responseHeaders === undefined) {
	                this.rawOnError(Code_1.Code.Unknown, "Response closed without headers");
	                return;
	            }
	            var grpcStatus_1 = getStatusFromHeaders(this.responseHeaders);
	            var grpcMessage_1 = this.responseHeaders.get("grpc-message");
	            this.props.debug && debug_1.debug("grpc.headers only response ", grpcStatus_1, grpcMessage_1);
	            if (grpcStatus_1 === null) {
	                this.rawOnEnd(Code_1.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
	                return;
	            }
	            var statusMessage_1 = this.decodeGRPCStatus(grpcMessage_1[0]);
	            this.rawOnEnd(grpcStatus_1, statusMessage_1, this.responseHeaders);
	            return;
	        }
	        var grpcStatus = getStatusFromHeaders(this.responseTrailers);
	        if (grpcStatus === null) {
	            this.rawOnError(Code_1.Code.Internal, "Response closed without grpc-status (Trailers provided)");
	            return;
	        }
	        var grpcMessage = this.responseTrailers.get("grpc-message");
	        var statusMessage = this.decodeGRPCStatus(grpcMessage[0]);
	        this.rawOnEnd(grpcStatus, statusMessage, this.responseTrailers);
	    };
	    GrpcClient.prototype.decodeGRPCStatus = function (src) {
	        if (src) {
	            try {
	                return decodeURIComponent(src);
	            }
	            catch (err) {
	                return src;
	            }
	        }
	        else {
	            return "";
	        }
	    };
	    GrpcClient.prototype.rawOnEnd = function (code, message, trailers) {
	        this.props.debug && debug_1.debug("rawOnEnd", code, message, trailers);
	        if (this.completed)
	            return;
	        this.completed = true;
	        this.onEndCallbacks.forEach(function (callback) {
	            detach_1.default(function () {
	                callback(code, message, trailers);
	            });
	        });
	    };
	    GrpcClient.prototype.rawOnHeaders = function (headers) {
	        this.props.debug && debug_1.debug("rawOnHeaders", headers);
	        if (this.completed)
	            return;
	        this.onHeadersCallbacks.forEach(function (callback) {
	            detach_1.default(function () {
	                callback(headers);
	            });
	        });
	    };
	    GrpcClient.prototype.rawOnError = function (code, msg) {
	        this.props.debug && debug_1.debug("rawOnError", code, msg);
	        if (this.completed)
	            return;
	        this.completed = true;
	        this.onEndCallbacks.forEach(function (callback) {
	            detach_1.default(function () {
	                callback(code, msg, new metadata.Metadata());
	            });
	        });
	    };
	    GrpcClient.prototype.rawOnMessage = function (res) {
	        this.props.debug && debug_1.debug("rawOnMessage", res.toObject());
	        if (this.completed)
	            return;
	        this.onMessageCallbacks.forEach(function (callback) {
	            detach_1.default(function () {
	                callback(res);
	            });
	        });
	    };
	    GrpcClient.prototype.onHeaders = function (callback) {
	        this.onHeadersCallbacks.push(callback);
	    };
	    GrpcClient.prototype.onMessage = function (callback) {
	        this.onMessageCallbacks.push(callback);
	    };
	    GrpcClient.prototype.onEnd = function (callback) {
	        this.onEndCallbacks.push(callback);
	    };
	    GrpcClient.prototype.start = function (metadata$$1) {
	        if (this.started) {
	            throw new Error("Client already started - cannot .start()");
	        }
	        this.started = true;
	        var requestHeaders = new metadata.Metadata(metadata$$1 ? metadata$$1 : {});
	        requestHeaders.set("content-type", "application/grpc-web+proto");
	        requestHeaders.set("x-grpc-web", "1");
	        this.transport.start(requestHeaders);
	    };
	    GrpcClient.prototype.send = function (msg) {
	        if (!this.started) {
	            throw new Error("Client not started - .start() must be called before .send()");
	        }
	        if (this.closed) {
	            throw new Error("Client already closed - cannot .send()");
	        }
	        if (this.finishedSending) {
	            throw new Error("Client already finished sending - cannot .send()");
	        }
	        if (!this.methodDefinition.requestStream && this.sentFirstMessage) {
	            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
	        }
	        this.sentFirstMessage = true;
	        var msgBytes = util$3.frameRequest(msg);
	        this.transport.sendMessage(msgBytes);
	    };
	    GrpcClient.prototype.finishSend = function () {
	        if (!this.started) {
	            throw new Error("Client not started - .finishSend() must be called before .close()");
	        }
	        if (this.closed) {
	            throw new Error("Client already closed - cannot .send()");
	        }
	        if (this.finishedSending) {
	            throw new Error("Client already finished sending - cannot .finishSend()");
	        }
	        this.finishedSending = true;
	        this.transport.finishSend();
	    };
	    GrpcClient.prototype.close = function () {
	        if (!this.started) {
	            throw new Error("Client not started - .start() must be called before .close()");
	        }
	        if (!this.closed) {
	            this.closed = true;
	            this.props.debug && debug_1.debug("request.abort aborting request");
	            this.transport.cancel();
	        }
	        else {
	            throw new Error("Client already closed - cannot .close()");
	        }
	    };
	    return GrpcClient;
	}());
	function getStatusFromHeaders(headers) {
	    var fromHeaders = headers.get("grpc-status") || [];
	    if (fromHeaders.length > 0) {
	        try {
	            var asString = fromHeaders[0];
	            return parseInt(asString, 10);
	        }
	        catch (e) {
	            return null;
	        }
	    }
	    return null;
	}

	});

	unwrapExports(client_1);
	var client_2 = client_1.client;

	var invoke_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	function invoke(methodDescriptor, props) {
	    if (methodDescriptor.requestStream) {
	        throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
	    }
	    var grpcClient = client_1.client(methodDescriptor, {
	        host: props.host,
	        transport: props.transport,
	        debug: props.debug,
	    });
	    if (props.onHeaders) {
	        grpcClient.onHeaders(props.onHeaders);
	    }
	    if (props.onMessage) {
	        grpcClient.onMessage(props.onMessage);
	    }
	    if (props.onEnd) {
	        grpcClient.onEnd(props.onEnd);
	    }
	    grpcClient.start(props.metadata);
	    grpcClient.send(props.request);
	    return {
	        close: function () {
	            grpcClient.close();
	        }
	    };
	}
	exports.invoke = invoke;

	});

	unwrapExports(invoke_1);
	var invoke_2 = invoke_1.invoke;

	var unary_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	function unary(methodDescriptor, props) {
	    if (methodDescriptor.responseStream) {
	        throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
	    }
	    if (methodDescriptor.requestStream) {
	        throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
	    }
	    var responseHeaders = null;
	    var responseMessage = null;
	    var grpcClient = client_1.client(methodDescriptor, {
	        host: props.host,
	        transport: props.transport,
	        debug: props.debug,
	    });
	    grpcClient.onHeaders(function (headers) {
	        responseHeaders = headers;
	    });
	    grpcClient.onMessage(function (res) {
	        responseMessage = res;
	    });
	    grpcClient.onEnd(function (status, statusMessage, trailers) {
	        props.onEnd({
	            status: status,
	            statusMessage: statusMessage,
	            headers: responseHeaders ? responseHeaders : new metadata.Metadata(),
	            message: responseMessage,
	            trailers: trailers
	        });
	    });
	    grpcClient.start(props.metadata);
	    grpcClient.send(props.request);
	    return {
	        close: function () {
	            grpcClient.close();
	        }
	    };
	}
	exports.unary = unary;

	});

	unwrapExports(unary_1);
	var unary_2 = unary_1.unary;

	var dist = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });






	var grpc;
	(function (grpc) {
	    grpc.DefaultTransportFactory = Transport.DefaultTransportFactory;
	    grpc.WebsocketTransportFactory = Transport.WebsocketTransportFactory;
	    grpc.Code = Code_1.Code;
	    grpc.Metadata = lib.BrowserHeaders;
	    function client(methodDescriptor, props) {
	        return client_1.client(methodDescriptor, props);
	    }
	    grpc.client = client;
	    grpc.invoke = invoke_1.invoke;
	    grpc.unary = unary_1.unary;
	})(grpc = exports.grpc || (exports.grpc = {}));

	});

	unwrapExports(dist);
	var dist_1 = dist.grpc;

	// package: types
	// file: rpc.proto


	var grpc = dist.grpc;

	var AergoRPCService = function () {
	  function AergoRPCService() {}
	  AergoRPCService.serviceName = "types.AergoRPCService";
	  return AergoRPCService;
	}();

	AergoRPCService.NodeState = {
	  methodName: "NodeState",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: rpc_pb$1.SingleBytes
	};

	AergoRPCService.Blockchain = {
	  methodName: "Blockchain",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Empty,
	  responseType: rpc_pb$1.BlockchainStatus
	};

	AergoRPCService.ListBlockHeaders = {
	  methodName: "ListBlockHeaders",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.ListParams,
	  responseType: rpc_pb$1.BlockHeaderList
	};

	AergoRPCService.GetBlock = {
	  methodName: "GetBlock",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.Block
	};

	AergoRPCService.GetTX = {
	  methodName: "GetTX",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.Tx
	};

	AergoRPCService.GetBlockTX = {
	  methodName: "GetBlockTX",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.TxInBlock
	};

	AergoRPCService.GetReceipt = {
	  methodName: "GetReceipt",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.Receipt
	};

	AergoRPCService.GetABI = {
	  methodName: "GetABI",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.ABI
	};

	AergoRPCService.CommitTX = {
	  methodName: "CommitTX",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: blockchain_pb$1.TxList,
	  responseType: rpc_pb$1.CommitResultList
	};

	AergoRPCService.GetState = {
	  methodName: "GetState",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.State
	};

	AergoRPCService.CreateAccount = {
	  methodName: "CreateAccount",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Personal,
	  responseType: account_pb$1.Account
	};

	AergoRPCService.GetAccounts = {
	  methodName: "GetAccounts",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Empty,
	  responseType: account_pb$1.AccountList
	};

	AergoRPCService.LockAccount = {
	  methodName: "LockAccount",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Personal,
	  responseType: account_pb$1.Account
	};

	AergoRPCService.UnlockAccount = {
	  methodName: "UnlockAccount",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Personal,
	  responseType: account_pb$1.Account
	};

	AergoRPCService.SignTX = {
	  methodName: "SignTX",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: blockchain_pb$1.Tx,
	  responseType: blockchain_pb$1.Tx
	};

	AergoRPCService.VerifyTX = {
	  methodName: "VerifyTX",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: blockchain_pb$1.Tx,
	  responseType: rpc_pb$1.VerifyResult
	};

	AergoRPCService.QueryContract = {
	  methodName: "QueryContract",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: blockchain_pb$1.Query,
	  responseType: rpc_pb$1.SingleBytes
	};

	AergoRPCService.GetPeers = {
	  methodName: "GetPeers",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.Empty,
	  responseType: rpc_pb$1.PeerList
	};

	AergoRPCService.GetVotes = {
	  methodName: "GetVotes",
	  service: AergoRPCService,
	  requestStream: false,
	  responseStream: false,
	  requestType: rpc_pb$1.SingleBytes,
	  responseType: blockchain_pb$1.VoteList
	};

	function AergoRPCServiceClient(serviceHost, options) {
	  this.serviceHost = serviceHost;
	  this.options = options || {};
	}

	AergoRPCServiceClient.prototype.nodeState = function nodeState(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.NodeState, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.blockchain = function blockchain(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.Blockchain, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.listBlockHeaders = function listBlockHeaders(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.ListBlockHeaders, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getBlock = function getBlock(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetBlock, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getTX = function getTX(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetTX, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getBlockTX = function getBlockTX(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetBlockTX, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getReceipt = function getReceipt(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetReceipt, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getABI = function getABI(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetABI, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.commitTX = function commitTX(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.CommitTX, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getState = function getState(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetState, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.createAccount = function createAccount(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.CreateAccount, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getAccounts = function getAccounts(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetAccounts, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.lockAccount = function lockAccount(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.LockAccount, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.unlockAccount = function unlockAccount(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.UnlockAccount, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.signTX = function signTX(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.SignTX, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.verifyTX = function verifyTX(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.VerifyTX, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.queryContract = function queryContract(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.QueryContract, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getPeers = function getPeers(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetPeers, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	AergoRPCServiceClient.prototype.getVotes = function getVotes(requestMessage, metadata, callback) {
	  if (arguments.length === 2) {
	    callback = arguments[1];
	  }
	  grpc.unary(AergoRPCService.GetVotes, {
	    request: requestMessage,
	    host: this.serviceHost,
	    metadata: metadata,
	    transport: this.options.transport,
	    debug: this.options.debug,
	    onEnd: function onEnd(response) {
	      if (callback) {
	        if (response.status !== grpc.Code.OK) {
	          callback(Object.assign(new Error(response.statusMessage), { code: response.status, metadata: response.trailers }), null);
	        } else {
	          callback(null, response.message);
	        }
	      }
	    }
	  });
	};

	var AergoRPCServiceClient_1 = AergoRPCServiceClient;

	AergoClient.prototype.target = 'web';

	AergoClient.prototype.initClient = function (config) {
	    return new AergoRPCServiceClient_1('http://' + config.url);
	};

	return AergoClient;

})));
